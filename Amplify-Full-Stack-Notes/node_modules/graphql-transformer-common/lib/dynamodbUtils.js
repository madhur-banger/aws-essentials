"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupHashKeyExpression = exports.applyKeyExpressionForCompositeKey = exports.applyCompositeKeyConditionExpression = exports.applyKeyConditionExpression = exports.makeCompositeKeyInputForKey = exports.makeCompositeKeyConditionInputForKey = exports.makeScalarKeyConditionForType = exports.makeScalarKeyConditionInputs = exports.makeModelScalarKeyConditionInputObject = void 0;
const graphql_1 = require("graphql");
const graphql_mapping_template_1 = require("graphql-mapping-template");
const definition_1 = require("./definition");
const ModelResourceIDs_1 = require("./ModelResourceIDs");
const STRING_KEY_CONDITIONS = ['eq', 'le', 'lt', 'ge', 'gt', 'between', 'beginsWith'];
const ID_KEY_CONDITIONS = ['eq', 'le', 'lt', 'ge', 'gt', 'between', 'beginsWith'];
const INT_KEY_CONDITIONS = ['eq', 'le', 'lt', 'ge', 'gt', 'between'];
const FLOAT_KEY_CONDITIONS = ['eq', 'le', 'lt', 'ge', 'gt', 'between'];
function getScalarKeyConditions(type) {
    switch (type) {
        case 'String':
            return STRING_KEY_CONDITIONS;
        case 'ID':
            return ID_KEY_CONDITIONS;
        case 'Int':
            return INT_KEY_CONDITIONS;
        case 'Float':
            return FLOAT_KEY_CONDITIONS;
        default:
            throw 'Valid types are String, ID, Int, Float, Boolean';
    }
}
function makeModelScalarKeyConditionInputObject(type) {
    const name = ModelResourceIDs_1.ModelResourceIDs.ModelKeyConditionInputTypeName(type);
    const conditions = getScalarKeyConditions(type);
    const fields = conditions.map((condition) => ({
        kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
        name: { kind: 'Name', value: condition },
        type: condition === 'between' ? (0, definition_1.makeListType)((0, definition_1.makeNamedType)(type)) : (0, definition_1.makeNamedType)(type),
        directives: [],
    }));
    return (0, definition_1.makeInputObjectDefinition)(name, fields);
}
exports.makeModelScalarKeyConditionInputObject = makeModelScalarKeyConditionInputObject;
const STRING_KEY_CONDITION = makeModelScalarKeyConditionInputObject('String');
const ID_KEY_CONDITION = makeModelScalarKeyConditionInputObject('ID');
const INT_KEY_CONDITION = makeModelScalarKeyConditionInputObject('Int');
const FLOAT_KEY_CONDITION = makeModelScalarKeyConditionInputObject('Float');
const SCALAR_KEY_CONDITIONS = [STRING_KEY_CONDITION, ID_KEY_CONDITION, INT_KEY_CONDITION, FLOAT_KEY_CONDITION];
function makeScalarKeyConditionInputs() {
    return SCALAR_KEY_CONDITIONS;
}
exports.makeScalarKeyConditionInputs = makeScalarKeyConditionInputs;
function makeScalarKeyConditionForType(type, nonScalarTypeResolver = undefined) {
    const baseType = (0, definition_1.getBaseType)(type);
    let resolvedScalarName;
    if ((0, definition_1.isScalar)(type)) {
        resolvedScalarName = baseType;
    }
    else if (nonScalarTypeResolver) {
        resolvedScalarName = nonScalarTypeResolver(baseType);
    }
    const inputName = ModelResourceIDs_1.ModelResourceIDs.ModelKeyConditionInputTypeName(resolvedScalarName);
    for (const key of SCALAR_KEY_CONDITIONS) {
        if (key.name.value === inputName) {
            return key;
        }
    }
}
exports.makeScalarKeyConditionForType = makeScalarKeyConditionForType;
function makeCompositeKeyConditionInputForKey(modelName, keyName, fields) {
    const name = ModelResourceIDs_1.ModelResourceIDs.ModelCompositeKeyConditionInputTypeName(modelName, keyName);
    const conditions = STRING_KEY_CONDITIONS;
    const inputValues = conditions.map((condition) => {
        const typeNode = condition === 'between'
            ? (0, definition_1.makeListType)((0, definition_1.makeNamedType)(ModelResourceIDs_1.ModelResourceIDs.ModelCompositeKeyInputTypeName(modelName, keyName)))
            : (0, definition_1.makeNamedType)(ModelResourceIDs_1.ModelResourceIDs.ModelCompositeKeyInputTypeName(modelName, keyName));
        return (0, definition_1.makeInputValueDefinition)(condition, typeNode);
    });
    return (0, definition_1.makeInputObjectDefinition)(name, inputValues);
}
exports.makeCompositeKeyConditionInputForKey = makeCompositeKeyConditionInputForKey;
function makeCompositeKeyInputForKey(modelName, keyName, fields) {
    const inputValues = fields.map((field, idx) => {
        const baseTypeName = (0, definition_1.getBaseType)(field.type);
        const nameOverride = definition_1.DEFAULT_SCALARS[baseTypeName];
        let typeNode = null;
        if (idx === fields.length - 1 && nameOverride) {
            typeNode = (0, definition_1.makeNamedType)(nameOverride);
        }
        else {
            typeNode = (0, definition_1.makeNamedType)(baseTypeName);
        }
        return (0, definition_1.makeInputValueDefinition)(field.name.value, typeNode);
    });
    const inputName = ModelResourceIDs_1.ModelResourceIDs.ModelCompositeKeyInputTypeName(modelName, keyName);
    return (0, definition_1.makeInputObjectDefinition)(inputName, inputValues);
}
exports.makeCompositeKeyInputForKey = makeCompositeKeyInputForKey;
function applyKeyConditionExpression(argName, attributeType = 'S', queryExprReference = 'query', sortKeyName, prefixVariableName) {
    const prefixValue = (value) => (prefixVariableName ? `$${prefixVariableName}#${value}` : value);
    const _sortKeyName = sortKeyName ? sortKeyName : argName;
    return (0, graphql_mapping_template_1.block)('Applying Key Condition', [
        (0, graphql_mapping_template_1.iff)((0, graphql_mapping_template_1.raw)(`!$util.isNull($ctx.args.${argName}) && !$util.isNull($ctx.args.${argName}.beginsWith)`), (0, graphql_mapping_template_1.compoundExpression)([
            (0, graphql_mapping_template_1.set)((0, graphql_mapping_template_1.ref)(`${queryExprReference}.expression`), (0, graphql_mapping_template_1.raw)(`"$${queryExprReference}.expression AND begins_with(#sortKey, :sortKey)"`)),
            (0, graphql_mapping_template_1.qref)(`$${queryExprReference}.expressionNames.put("#sortKey", "${_sortKeyName}")`),
            (0, graphql_mapping_template_1.qref)(`$${queryExprReference}.expressionValues.put(":sortKey", { "${attributeType}": "${prefixValue(`$ctx.args.${argName}.beginsWith`)}" })`),
        ])),
        (0, graphql_mapping_template_1.iff)((0, graphql_mapping_template_1.raw)(`!$util.isNull($ctx.args.${argName}) && !$util.isNull($ctx.args.${argName}.between)`), (0, graphql_mapping_template_1.compoundExpression)([
            (0, graphql_mapping_template_1.set)((0, graphql_mapping_template_1.ref)(`${queryExprReference}.expression`), (0, graphql_mapping_template_1.raw)(`"$${queryExprReference}.expression AND #sortKey BETWEEN :sortKey0 AND :sortKey1"`)),
            (0, graphql_mapping_template_1.qref)(`$${queryExprReference}.expressionNames.put("#sortKey", "${_sortKeyName}")`),
            (0, graphql_mapping_template_1.qref)(`$${queryExprReference}.expressionValues.put(":sortKey0", { "${attributeType}": "${prefixValue(`$ctx.args.${argName}.between[0]`)}" })`),
            (0, graphql_mapping_template_1.qref)(`$${queryExprReference}.expressionValues.put(":sortKey1", { "${attributeType}": "${prefixValue(`$ctx.args.${argName}.between[1]`)}" })`),
        ])),
        (0, graphql_mapping_template_1.iff)((0, graphql_mapping_template_1.raw)(`!$util.isNull($ctx.args.${argName}) && !$util.isNull($ctx.args.${argName}.eq)`), (0, graphql_mapping_template_1.compoundExpression)([
            (0, graphql_mapping_template_1.set)((0, graphql_mapping_template_1.ref)(`${queryExprReference}.expression`), (0, graphql_mapping_template_1.raw)(`"$${queryExprReference}.expression AND #sortKey = :sortKey"`)),
            (0, graphql_mapping_template_1.qref)(`$${queryExprReference}.expressionNames.put("#sortKey", "${_sortKeyName}")`),
            (0, graphql_mapping_template_1.qref)(`$${queryExprReference}.expressionValues.put(":sortKey", { "${attributeType}": "${prefixValue(`$ctx.args.${argName}.eq`)}" })`),
        ])),
        (0, graphql_mapping_template_1.iff)((0, graphql_mapping_template_1.raw)(`!$util.isNull($ctx.args.${argName}) && !$util.isNull($ctx.args.${argName}.lt)`), (0, graphql_mapping_template_1.compoundExpression)([
            (0, graphql_mapping_template_1.set)((0, graphql_mapping_template_1.ref)(`${queryExprReference}.expression`), (0, graphql_mapping_template_1.raw)(`"$${queryExprReference}.expression AND #sortKey < :sortKey"`)),
            (0, graphql_mapping_template_1.qref)(`$${queryExprReference}.expressionNames.put("#sortKey", "${_sortKeyName}")`),
            (0, graphql_mapping_template_1.qref)(`$${queryExprReference}.expressionValues.put(":sortKey", { "${attributeType}": "${prefixValue(`$ctx.args.${argName}.lt`)}" })`),
        ])),
        (0, graphql_mapping_template_1.iff)((0, graphql_mapping_template_1.raw)(`!$util.isNull($ctx.args.${argName}) && !$util.isNull($ctx.args.${argName}.le)`), (0, graphql_mapping_template_1.compoundExpression)([
            (0, graphql_mapping_template_1.set)((0, graphql_mapping_template_1.ref)(`${queryExprReference}.expression`), (0, graphql_mapping_template_1.raw)(`"$${queryExprReference}.expression AND #sortKey <= :sortKey"`)),
            (0, graphql_mapping_template_1.qref)(`$${queryExprReference}.expressionNames.put("#sortKey", "${_sortKeyName}")`),
            (0, graphql_mapping_template_1.qref)(`$${queryExprReference}.expressionValues.put(":sortKey", { "${attributeType}": "${prefixValue(`$ctx.args.${argName}.le`)}" })`),
        ])),
        (0, graphql_mapping_template_1.iff)((0, graphql_mapping_template_1.raw)(`!$util.isNull($ctx.args.${argName}) && !$util.isNull($ctx.args.${argName}.gt)`), (0, graphql_mapping_template_1.compoundExpression)([
            (0, graphql_mapping_template_1.set)((0, graphql_mapping_template_1.ref)(`${queryExprReference}.expression`), (0, graphql_mapping_template_1.raw)(`"$${queryExprReference}.expression AND #sortKey > :sortKey"`)),
            (0, graphql_mapping_template_1.qref)(`$${queryExprReference}.expressionNames.put("#sortKey", "${_sortKeyName}")`),
            (0, graphql_mapping_template_1.qref)(`$${queryExprReference}.expressionValues.put(":sortKey", { "${attributeType}": "${prefixValue(`$ctx.args.${argName}.gt`)}" })`),
        ])),
        (0, graphql_mapping_template_1.iff)((0, graphql_mapping_template_1.raw)(`!$util.isNull($ctx.args.${argName}) && !$util.isNull($ctx.args.${argName}.ge)`), (0, graphql_mapping_template_1.compoundExpression)([
            (0, graphql_mapping_template_1.set)((0, graphql_mapping_template_1.ref)(`${queryExprReference}.expression`), (0, graphql_mapping_template_1.raw)(`"$${queryExprReference}.expression AND #sortKey >= :sortKey"`)),
            (0, graphql_mapping_template_1.qref)(`$${queryExprReference}.expressionNames.put("#sortKey", "${_sortKeyName}")`),
            (0, graphql_mapping_template_1.qref)(`$${queryExprReference}.expressionValues.put(":sortKey", { "${attributeType}": "${prefixValue(`$ctx.args.${argName}.ge`)}" })`),
        ])),
    ]);
}
exports.applyKeyConditionExpression = applyKeyConditionExpression;
function applyCompositeKeyConditionExpression(keyNames, queryExprReference = 'query', sortKeyArgumentName, sortKeyAttributeName) {
    const accumulatorVar1 = 'sortKeyValue';
    const accumulatorVar2 = 'sortKeyValue2';
    const sep = ModelResourceIDs_1.ModelResourceIDs.ModelCompositeKeySeparator();
    return (0, graphql_mapping_template_1.block)('Applying Key Condition', [
        (0, graphql_mapping_template_1.set)((0, graphql_mapping_template_1.ref)(accumulatorVar1), (0, graphql_mapping_template_1.str)('')),
        (0, graphql_mapping_template_1.set)((0, graphql_mapping_template_1.ref)(accumulatorVar2), (0, graphql_mapping_template_1.str)('')),
        (0, graphql_mapping_template_1.iff)((0, graphql_mapping_template_1.raw)(`!$util.isNull($ctx.args.${sortKeyArgumentName}) && !$util.isNull($ctx.args.${sortKeyArgumentName}.beginsWith)`), (0, graphql_mapping_template_1.compoundExpression)([
            ...keyNames.map((keyName, idx) => (0, graphql_mapping_template_1.iff)((0, graphql_mapping_template_1.raw)(`!$util.isNull($ctx.args.${sortKeyArgumentName}.beginsWith.${keyName})`), idx === 0
                ? (0, graphql_mapping_template_1.set)((0, graphql_mapping_template_1.ref)(accumulatorVar1), (0, graphql_mapping_template_1.str)(`$ctx.args.${sortKeyArgumentName}.beginsWith.${keyName}`))
                : (0, graphql_mapping_template_1.set)((0, graphql_mapping_template_1.ref)(accumulatorVar1), (0, graphql_mapping_template_1.str)(`$${accumulatorVar1}${sep}$ctx.args.${sortKeyArgumentName}.beginsWith.${keyName}`)), true)),
            (0, graphql_mapping_template_1.set)((0, graphql_mapping_template_1.ref)(`${queryExprReference}.expression`), (0, graphql_mapping_template_1.raw)(`"$${queryExprReference}.expression AND begins_with(#sortKey, :sortKey)"`)),
            (0, graphql_mapping_template_1.qref)(`$${queryExprReference}.expressionNames.put("#sortKey", "${sortKeyAttributeName}")`),
            (0, graphql_mapping_template_1.qref)(`$${queryExprReference}.expressionValues.put(":sortKey", { "S": "$${accumulatorVar1}" })`),
        ])),
        (0, graphql_mapping_template_1.iff)((0, graphql_mapping_template_1.raw)(`!$util.isNull($ctx.args.${sortKeyArgumentName}) && !$util.isNull($ctx.args.${sortKeyArgumentName}.between)`), (0, graphql_mapping_template_1.compoundExpression)([
            (0, graphql_mapping_template_1.iff)((0, graphql_mapping_template_1.raw)(`$ctx.args.${sortKeyArgumentName}.between.size() != 2`), (0, graphql_mapping_template_1.raw)(`$util.error("Argument ${sortKeyArgumentName}.between expects exactly 2 elements.")`)),
            ...keyNames.map((keyName, idx) => (0, graphql_mapping_template_1.iff)((0, graphql_mapping_template_1.raw)(`!$util.isNull($ctx.args.${sortKeyArgumentName}.between[0].${keyName})`), idx === 0
                ? (0, graphql_mapping_template_1.set)((0, graphql_mapping_template_1.ref)(accumulatorVar1), (0, graphql_mapping_template_1.str)(`$ctx.args.${sortKeyArgumentName}.between[0].${keyName}`))
                : (0, graphql_mapping_template_1.set)((0, graphql_mapping_template_1.ref)(accumulatorVar1), (0, graphql_mapping_template_1.str)(`$${accumulatorVar1}${sep}$ctx.args.${sortKeyArgumentName}.between[0].${keyName}`)), true)),
            ...keyNames.map((keyName, idx) => (0, graphql_mapping_template_1.iff)((0, graphql_mapping_template_1.raw)(`!$util.isNull($ctx.args.${sortKeyArgumentName}.between[1].${keyName})`), idx === 0
                ? (0, graphql_mapping_template_1.set)((0, graphql_mapping_template_1.ref)(accumulatorVar2), (0, graphql_mapping_template_1.str)(`$ctx.args.${sortKeyArgumentName}.between[1].${keyName}`))
                : (0, graphql_mapping_template_1.set)((0, graphql_mapping_template_1.ref)(accumulatorVar2), (0, graphql_mapping_template_1.str)(`$${accumulatorVar2}${sep}$ctx.args.${sortKeyArgumentName}.between[1].${keyName}`)), true)),
            (0, graphql_mapping_template_1.set)((0, graphql_mapping_template_1.ref)(`${queryExprReference}.expression`), (0, graphql_mapping_template_1.raw)(`"$${queryExprReference}.expression AND #sortKey BETWEEN :sortKey0 AND :sortKey1"`)),
            (0, graphql_mapping_template_1.qref)(`$${queryExprReference}.expressionNames.put("#sortKey", "${sortKeyAttributeName}")`),
            (0, graphql_mapping_template_1.qref)(`$${queryExprReference}.expressionValues.put(":sortKey0", { "S": "$${accumulatorVar1}" })`),
            (0, graphql_mapping_template_1.qref)(`$${queryExprReference}.expressionValues.put(":sortKey1", { "S": "$${accumulatorVar2}" })`),
        ])),
        (0, graphql_mapping_template_1.iff)((0, graphql_mapping_template_1.raw)(`!$util.isNull($ctx.args.${sortKeyArgumentName}) && !$util.isNull($ctx.args.${sortKeyArgumentName}.eq)`), (0, graphql_mapping_template_1.compoundExpression)([
            ...keyNames.map((keyName, idx) => (0, graphql_mapping_template_1.iff)((0, graphql_mapping_template_1.raw)(`!$util.isNull($ctx.args.${sortKeyArgumentName}.eq.${keyName})`), idx === 0
                ? (0, graphql_mapping_template_1.set)((0, graphql_mapping_template_1.ref)(accumulatorVar1), (0, graphql_mapping_template_1.str)(`$ctx.args.${sortKeyArgumentName}.eq.${keyName}`))
                : (0, graphql_mapping_template_1.set)((0, graphql_mapping_template_1.ref)(accumulatorVar1), (0, graphql_mapping_template_1.str)(`$${accumulatorVar1}${sep}$ctx.args.${sortKeyArgumentName}.eq.${keyName}`)), true)),
            (0, graphql_mapping_template_1.set)((0, graphql_mapping_template_1.ref)(`${queryExprReference}.expression`), (0, graphql_mapping_template_1.raw)(`"$${queryExprReference}.expression AND #sortKey = :sortKey"`)),
            (0, graphql_mapping_template_1.qref)(`$${queryExprReference}.expressionNames.put("#sortKey", "${sortKeyAttributeName}")`),
            (0, graphql_mapping_template_1.qref)(`$${queryExprReference}.expressionValues.put(":sortKey", { "S": "$${accumulatorVar1}" })`),
        ])),
        (0, graphql_mapping_template_1.iff)((0, graphql_mapping_template_1.raw)(`!$util.isNull($ctx.args.${sortKeyArgumentName}) && !$util.isNull($ctx.args.${sortKeyArgumentName}.lt)`), (0, graphql_mapping_template_1.compoundExpression)([
            ...keyNames.map((keyName, idx) => (0, graphql_mapping_template_1.iff)((0, graphql_mapping_template_1.raw)(`!$util.isNull($ctx.args.${sortKeyArgumentName}.lt.${keyName})`), idx === 0
                ? (0, graphql_mapping_template_1.set)((0, graphql_mapping_template_1.ref)(accumulatorVar1), (0, graphql_mapping_template_1.str)(`$ctx.args.${sortKeyArgumentName}.lt.${keyName}`))
                : (0, graphql_mapping_template_1.set)((0, graphql_mapping_template_1.ref)(accumulatorVar1), (0, graphql_mapping_template_1.str)(`$${accumulatorVar1}${sep}$ctx.args.${sortKeyArgumentName}.lt.${keyName}`)), true)),
            (0, graphql_mapping_template_1.set)((0, graphql_mapping_template_1.ref)(`${queryExprReference}.expression`), (0, graphql_mapping_template_1.raw)(`"$${queryExprReference}.expression AND #sortKey < :sortKey"`)),
            (0, graphql_mapping_template_1.qref)(`$${queryExprReference}.expressionNames.put("#sortKey", "${sortKeyAttributeName}")`),
            (0, graphql_mapping_template_1.qref)(`$${queryExprReference}.expressionValues.put(":sortKey", { "S": "$${accumulatorVar1}" })`),
        ])),
        (0, graphql_mapping_template_1.iff)((0, graphql_mapping_template_1.raw)(`!$util.isNull($ctx.args.${sortKeyArgumentName}) && !$util.isNull($ctx.args.${sortKeyArgumentName}.le)`), (0, graphql_mapping_template_1.compoundExpression)([
            ...keyNames.map((keyName, idx) => (0, graphql_mapping_template_1.iff)((0, graphql_mapping_template_1.raw)(`!$util.isNull($ctx.args.${sortKeyArgumentName}.le.${keyName})`), idx === 0
                ? (0, graphql_mapping_template_1.set)((0, graphql_mapping_template_1.ref)(accumulatorVar1), (0, graphql_mapping_template_1.str)(`$ctx.args.${sortKeyArgumentName}.le.${keyName}`))
                : (0, graphql_mapping_template_1.set)((0, graphql_mapping_template_1.ref)(accumulatorVar1), (0, graphql_mapping_template_1.str)(`$${accumulatorVar1}${sep}$ctx.args.${sortKeyArgumentName}.le.${keyName}`)), true)),
            (0, graphql_mapping_template_1.set)((0, graphql_mapping_template_1.ref)(`${queryExprReference}.expression`), (0, graphql_mapping_template_1.raw)(`"$${queryExprReference}.expression AND #sortKey <= :sortKey"`)),
            (0, graphql_mapping_template_1.qref)(`$${queryExprReference}.expressionNames.put("#sortKey", "${sortKeyAttributeName}")`),
            (0, graphql_mapping_template_1.qref)(`$${queryExprReference}.expressionValues.put(":sortKey", { "S": "$${accumulatorVar1}" })`),
        ])),
        (0, graphql_mapping_template_1.iff)((0, graphql_mapping_template_1.raw)(`!$util.isNull($ctx.args.${sortKeyArgumentName}) && !$util.isNull($ctx.args.${sortKeyArgumentName}.gt)`), (0, graphql_mapping_template_1.compoundExpression)([
            ...keyNames.map((keyName, idx) => (0, graphql_mapping_template_1.iff)((0, graphql_mapping_template_1.raw)(`!$util.isNull($ctx.args.${sortKeyArgumentName}.gt.${keyName})`), idx === 0
                ? (0, graphql_mapping_template_1.set)((0, graphql_mapping_template_1.ref)(accumulatorVar1), (0, graphql_mapping_template_1.str)(`$ctx.args.${sortKeyArgumentName}.gt.${keyName}`))
                : (0, graphql_mapping_template_1.set)((0, graphql_mapping_template_1.ref)(accumulatorVar1), (0, graphql_mapping_template_1.str)(`$${accumulatorVar1}${sep}$ctx.args.${sortKeyArgumentName}.gt.${keyName}`)), true)),
            (0, graphql_mapping_template_1.set)((0, graphql_mapping_template_1.ref)(`${queryExprReference}.expression`), (0, graphql_mapping_template_1.raw)(`"$${queryExprReference}.expression AND #sortKey > :sortKey"`)),
            (0, graphql_mapping_template_1.qref)(`$${queryExprReference}.expressionNames.put("#sortKey", "${sortKeyAttributeName}")`),
            (0, graphql_mapping_template_1.qref)(`$${queryExprReference}.expressionValues.put(":sortKey", { "S": "$${accumulatorVar1}" })`),
        ])),
        (0, graphql_mapping_template_1.iff)((0, graphql_mapping_template_1.raw)(`!$util.isNull($ctx.args.${sortKeyArgumentName}) && !$util.isNull($ctx.args.${sortKeyArgumentName}.ge)`), (0, graphql_mapping_template_1.compoundExpression)([
            ...keyNames.map((keyName, idx) => (0, graphql_mapping_template_1.iff)((0, graphql_mapping_template_1.raw)(`!$util.isNull($ctx.args.${sortKeyArgumentName}.ge.${keyName})`), idx === 0
                ? (0, graphql_mapping_template_1.set)((0, graphql_mapping_template_1.ref)(accumulatorVar1), (0, graphql_mapping_template_1.str)(`$ctx.args.${sortKeyArgumentName}.ge.${keyName}`))
                : (0, graphql_mapping_template_1.set)((0, graphql_mapping_template_1.ref)(accumulatorVar1), (0, graphql_mapping_template_1.str)(`$${accumulatorVar1}${sep}$ctx.args.${sortKeyArgumentName}.ge.${keyName}`)), true)),
            (0, graphql_mapping_template_1.set)((0, graphql_mapping_template_1.ref)(`${queryExprReference}.expression`), (0, graphql_mapping_template_1.raw)(`"$${queryExprReference}.expression AND #sortKey >= :sortKey"`)),
            (0, graphql_mapping_template_1.qref)(`$${queryExprReference}.expressionNames.put("#sortKey", "${sortKeyAttributeName}")`),
            (0, graphql_mapping_template_1.qref)(`$${queryExprReference}.expressionValues.put(":sortKey", { "S": "$${accumulatorVar1}" })`),
        ])),
        (0, graphql_mapping_template_1.newline)(),
    ]);
}
exports.applyCompositeKeyConditionExpression = applyCompositeKeyConditionExpression;
function applyKeyExpressionForCompositeKey(keys, attributeTypes = ['S'], queryExprReference = 'query') {
    if (keys.length > 2) {
        const hashKeyName = keys[0];
        const hashKeyAttributeType = attributeTypes[0];
        const sortKeys = keys.slice(1);
        const sortKeyTypes = attributeTypes.slice(1);
        return (0, graphql_mapping_template_1.compoundExpression)([
            validateCompositeKeyArguments(keys),
            setupHashKeyExpression(hashKeyName, hashKeyAttributeType, queryExprReference),
            applyCompositeSortKey(sortKeys, sortKeyTypes, queryExprReference),
        ]);
    }
    else if (keys.length === 2) {
        const hashKeyName = keys[0];
        const hashKeyAttributeType = attributeTypes[0];
        const sortKeyName = keys[1];
        const sortKeyAttributeType = attributeTypes[1];
        return (0, graphql_mapping_template_1.compoundExpression)([
            validateKeyArguments(keys),
            setupHashKeyExpression(hashKeyName, hashKeyAttributeType, queryExprReference),
            applyKeyConditionExpression(sortKeyName, sortKeyAttributeType, queryExprReference),
        ]);
    }
    else if (keys.length === 1) {
        const hashKeyName = keys[0];
        const hashKeyAttributeType = attributeTypes[0];
        return setupHashKeyExpression(hashKeyName, hashKeyAttributeType, queryExprReference);
    }
}
exports.applyKeyExpressionForCompositeKey = applyKeyExpressionForCompositeKey;
function setupHashKeyExpression(hashKeyName, hashKeyAttributeType, queryExprReference) {
    return (0, graphql_mapping_template_1.iff)((0, graphql_mapping_template_1.raw)(`!$util.isNull($ctx.args.${hashKeyName})`), (0, graphql_mapping_template_1.compoundExpression)([
        (0, graphql_mapping_template_1.set)((0, graphql_mapping_template_1.ref)(`${queryExprReference}.expression`), (0, graphql_mapping_template_1.str)(`#${hashKeyName} = :${hashKeyName}`)),
        (0, graphql_mapping_template_1.set)((0, graphql_mapping_template_1.ref)(`${queryExprReference}.expressionNames`), (0, graphql_mapping_template_1.obj)({ [`#${hashKeyName}`]: (0, graphql_mapping_template_1.str)(hashKeyName) })),
        (0, graphql_mapping_template_1.set)((0, graphql_mapping_template_1.ref)(`${queryExprReference}.expressionValues`), (0, graphql_mapping_template_1.obj)({ [`:${hashKeyName}`]: (0, graphql_mapping_template_1.obj)({ [hashKeyAttributeType]: (0, graphql_mapping_template_1.str)(`$ctx.args.${hashKeyName}`) }) })),
    ]));
}
exports.setupHashKeyExpression = setupHashKeyExpression;
function applyCompositeSortKey(sortKeys, sortKeyTypes, queryExprReference) {
    if (sortKeys.length === 0) {
        return (0, graphql_mapping_template_1.newline)();
    }
    const sortKeyAttributeName = ModelResourceIDs_1.ModelResourceIDs.ModelCompositeAttributeName(sortKeys);
    const sortKeyArgumentName = ModelResourceIDs_1.ModelResourceIDs.ModelCompositeKeyArgumentName(sortKeys);
    return (0, graphql_mapping_template_1.compoundExpression)([
        applyCompositeKeyConditionExpression(sortKeys, queryExprReference, sortKeyArgumentName, sortKeyAttributeName),
    ]);
}
function validateKeyArguments(keys) {
    const exprs = [];
    if (keys.length > 1) {
        for (let index = keys.length - 1; index > 0; index--) {
            const rightKey = keys[index];
            const previousKey = keys[index - 1];
            exprs.push((0, graphql_mapping_template_1.iff)((0, graphql_mapping_template_1.raw)(`!$util.isNull($ctx.args.${rightKey}) && $util.isNull($ctx.args.${previousKey})`), (0, graphql_mapping_template_1.raw)(`$util.error("When providing argument '${rightKey}' you must also provide arguments ${keys
                .slice(0, index)
                .join(', ')}", "InvalidArgumentsError")`)));
        }
        return (0, graphql_mapping_template_1.block)('Validate key arguments.', exprs);
    }
    else {
        return (0, graphql_mapping_template_1.newline)();
    }
}
function invalidArgumentError(err) {
    return (0, graphql_mapping_template_1.raw)(`$util.error("${err}", "InvalidArgumentsError")`);
}
function validateCompositeKeyArguments(keys) {
    const sortKeys = keys.slice(1);
    const hashKey = keys[0];
    const sortKeyArgumentName = ModelResourceIDs_1.ModelResourceIDs.ModelCompositeKeyArgumentName(sortKeys);
    const exprs = [
        (0, graphql_mapping_template_1.iff)((0, graphql_mapping_template_1.raw)(`!$util.isNull($ctx.args.${sortKeyArgumentName}) && $util.isNullOrBlank($ctx.args.${hashKey})`), invalidArgumentError(`When providing argument '${sortKeyArgumentName}' you must also provide '${hashKey}'.`)),
    ];
    if (sortKeys.length > 1) {
        const loopOverKeys = (fn) => {
            const exprs = [];
            for (let index = sortKeys.length - 1; index > 0; index--) {
                const rightKey = sortKeys[index];
                const previousKey = sortKeys[index - 1];
                exprs.push(fn(rightKey, previousKey));
            }
            return (0, graphql_mapping_template_1.compoundExpression)(exprs);
        };
        const validateBetween = () => (0, graphql_mapping_template_1.compoundExpression)([
            (0, graphql_mapping_template_1.iff)((0, graphql_mapping_template_1.raw)(`$ctx.args.${sortKeyArgumentName}.between.size() != 2`), invalidArgumentError(`Argument '${sortKeyArgumentName}.between' expects exactly two elements.`)),
            loopOverKeys((rightKey, previousKey) => (0, graphql_mapping_template_1.compoundExpression)([
                (0, graphql_mapping_template_1.iff)((0, graphql_mapping_template_1.raw)(`!$util.isNullOrBlank($ctx.args.${sortKeyArgumentName}.between[0].${rightKey}) && $util.isNullOrBlank($ctx.args.${sortKeyArgumentName}.between[0].${previousKey})`), invalidArgumentError(`When providing argument '${sortKeyArgumentName}.between[0].${rightKey}' you must also provide '${sortKeyArgumentName}.between[0].${previousKey}'.`)),
                (0, graphql_mapping_template_1.iff)((0, graphql_mapping_template_1.raw)(`!$util.isNullOrBlank($ctx.args.${sortKeyArgumentName}.between[1].${rightKey}) && $util.isNullOrBlank($ctx.args.${sortKeyArgumentName}.between[1].${previousKey})`), invalidArgumentError(`When providing argument '${sortKeyArgumentName}.between[1].${rightKey}' you must also provide '${sortKeyArgumentName}.between[1].${previousKey}'.`)),
            ])),
        ]);
        const validateOtherOperation = () => loopOverKeys((rightKey, previousKey) => (0, graphql_mapping_template_1.iff)((0, graphql_mapping_template_1.raw)(`!$util.isNullOrBlank($ctx.args.${sortKeyArgumentName}.get("$operation").${rightKey}) && $util.isNullOrBlank($ctx.args.${sortKeyArgumentName}.get("$operation").${previousKey})`), invalidArgumentError(`When providing argument '${sortKeyArgumentName}.$operation.${rightKey}' you must also provide '${sortKeyArgumentName}.$operation.${previousKey}'.`)));
        exprs.push((0, graphql_mapping_template_1.iff)((0, graphql_mapping_template_1.raw)(`!$util.isNull($ctx.args.${sortKeyArgumentName})`), (0, graphql_mapping_template_1.compoundExpression)([
            (0, graphql_mapping_template_1.set)((0, graphql_mapping_template_1.ref)('sortKeyArgumentOperations'), (0, graphql_mapping_template_1.raw)(`$ctx.args.${sortKeyArgumentName}.keySet()`)),
            (0, graphql_mapping_template_1.iff)((0, graphql_mapping_template_1.raw)(`$sortKeyArgumentOperations.size() > 1`), invalidArgumentError(`Argument ${sortKeyArgumentName} must specify at most one key condition operation.`)),
            (0, graphql_mapping_template_1.forEach)((0, graphql_mapping_template_1.ref)('operation'), (0, graphql_mapping_template_1.ref)('sortKeyArgumentOperations'), [
                (0, graphql_mapping_template_1.ifElse)((0, graphql_mapping_template_1.raw)(`$operation == "between"`), validateBetween(), validateOtherOperation()),
            ]),
        ])));
        return (0, graphql_mapping_template_1.block)('Validate key arguments.', exprs);
    }
    else {
        return (0, graphql_mapping_template_1.newline)();
    }
}
//# sourceMappingURL=dynamodbUtils.js.map