"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DynamoDBMappingTemplate = exports.RESOLVER_VERSION_ID = void 0;
const ast_1 = require("./ast");
exports.RESOLVER_VERSION_ID = '2018-05-29';
class DynamoDBMappingTemplate {
    static putItem({ key, attributeValues, condition, }, version = exports.RESOLVER_VERSION_ID) {
        return (0, ast_1.obj)({
            version: (0, ast_1.str)(version),
            operation: (0, ast_1.str)('PutItem'),
            key,
            attributeValues,
            condition,
        });
    }
    static getItem({ key, isSyncEnabled }) {
        let version = exports.RESOLVER_VERSION_ID;
        if (isSyncEnabled) {
            version = '2018-05-29';
        }
        return (0, ast_1.obj)({
            version: (0, ast_1.str)(version),
            operation: (0, ast_1.str)('GetItem'),
            key,
        });
    }
    static query({ query, scanIndexForward, filter, limit, nextToken, index, }) {
        return (0, ast_1.obj)({
            version: (0, ast_1.str)(exports.RESOLVER_VERSION_ID),
            operation: (0, ast_1.str)('Query'),
            query,
            scanIndexForward,
            filter,
            limit,
            ...(nextToken ? { nextToken } : {}),
            ...(index ? { index } : {}),
        });
    }
    static listItem({ filter, limit, nextToken, scanIndexForward, query, index, }, version = exports.RESOLVER_VERSION_ID) {
        return (0, ast_1.obj)({
            version: (0, ast_1.str)(version),
            operation: (0, ast_1.str)('Scan'),
            filter,
            limit,
            nextToken,
            query,
            index,
            scanIndexForward,
        });
    }
    static syncItem({ filter, limit, nextToken, lastSync, }) {
        return (0, ast_1.compoundExpression)([
            (0, ast_1.obj)({
                version: (0, ast_1.str)('2018-05-29'),
                operation: (0, ast_1.str)('Sync'),
                limit,
                nextToken,
                lastSync,
                filter,
            }),
        ]);
    }
    static deleteItem({ key, condition, isSyncEnabled, }) {
        return (0, ast_1.obj)({
            version: (0, ast_1.str)(exports.RESOLVER_VERSION_ID),
            operation: (0, ast_1.str)('DeleteItem'),
            key,
            condition,
            ...(isSyncEnabled && { _version: (0, ast_1.ref)('util.defaultIfNull($ctx.args.input["_version"], "0")') }),
        });
    }
    static updateItem({ key, condition, objectKeyVariable, nameOverrideMap, isSyncEnabled, }) {
        const entryKeyAttributeNameVar = 'entryKeyAttributeName';
        let keyFields = [(0, ast_1.str)('id')];
        let version = exports.RESOLVER_VERSION_ID;
        if (isSyncEnabled) {
            keyFields = [...keyFields, (0, ast_1.str)('_version'), (0, ast_1.str)('_deleted'), (0, ast_1.str)('_lastChangedAt')];
            version = '2018-05-29';
        }
        const handleRename = (keyVar) => (0, ast_1.ifElse)((0, ast_1.raw)(`!$util.isNull($${nameOverrideMap}) && $${nameOverrideMap}.containsKey("${keyVar}")`), (0, ast_1.set)((0, ast_1.ref)(entryKeyAttributeNameVar), (0, ast_1.raw)(`$${nameOverrideMap}.get("${keyVar}")`)), (0, ast_1.set)((0, ast_1.ref)(entryKeyAttributeNameVar), (0, ast_1.raw)(keyVar)));
        return (0, ast_1.compoundExpression)([
            (0, ast_1.set)((0, ast_1.ref)('expNames'), (0, ast_1.obj)({})),
            (0, ast_1.set)((0, ast_1.ref)('expValues'), (0, ast_1.obj)({})),
            (0, ast_1.set)((0, ast_1.ref)('expSet'), (0, ast_1.obj)({})),
            (0, ast_1.set)((0, ast_1.ref)('expAdd'), (0, ast_1.obj)({})),
            (0, ast_1.set)((0, ast_1.ref)('expRemove'), (0, ast_1.list)([])),
            (0, ast_1.ifElse)((0, ast_1.ref)(objectKeyVariable), (0, ast_1.compoundExpression)([
                (0, ast_1.set)((0, ast_1.ref)('keyFields'), isSyncEnabled ? (0, ast_1.list)([(0, ast_1.str)('_version'), (0, ast_1.str)('_deleted'), (0, ast_1.str)('_lastChangedAt')]) : (0, ast_1.list)([])),
                (0, ast_1.forEach)((0, ast_1.ref)('entry'), (0, ast_1.ref)(`${objectKeyVariable}.entrySet()`), [(0, ast_1.qref)('$keyFields.add("$entry.key")')]),
            ]), (0, ast_1.set)((0, ast_1.ref)('keyFields'), (0, ast_1.list)(keyFields))),
            (0, ast_1.forEach)((0, ast_1.ref)('entry'), (0, ast_1.ref)(`util.map.copyAndRemoveAllKeys($context.args.input, $keyFields).entrySet()`), [
                handleRename('$entry.key'),
                (0, ast_1.ifElse)((0, ast_1.ref)('util.isNull($entry.value)'), (0, ast_1.compoundExpression)([
                    (0, ast_1.set)((0, ast_1.ref)('discard'), (0, ast_1.ref)(`expRemove.add("#$${entryKeyAttributeNameVar}")`)),
                    (0, ast_1.qref)(`$expNames.put("#$${entryKeyAttributeNameVar}", "$entry.key")`),
                ]), (0, ast_1.compoundExpression)([
                    (0, ast_1.qref)(`$expSet.put("#$${entryKeyAttributeNameVar}", ":$${entryKeyAttributeNameVar}")`),
                    (0, ast_1.qref)(`$expNames.put("#$${entryKeyAttributeNameVar}", "$entry.key")`),
                    (0, ast_1.qref)(`$expValues.put(":$${entryKeyAttributeNameVar}", $util.dynamodb.toDynamoDB($entry.value))`),
                ])),
            ]),
            (0, ast_1.set)((0, ast_1.ref)('expression'), (0, ast_1.str)('')),
            (0, ast_1.iff)((0, ast_1.raw)('!$expSet.isEmpty()'), (0, ast_1.compoundExpression)([
                (0, ast_1.set)((0, ast_1.ref)('expression'), (0, ast_1.str)('SET')),
                (0, ast_1.forEach)((0, ast_1.ref)('entry'), (0, ast_1.ref)('expSet.entrySet()'), [
                    (0, ast_1.set)((0, ast_1.ref)('expression'), (0, ast_1.str)('$expression $entry.key = $entry.value')),
                    (0, ast_1.iff)((0, ast_1.ref)('foreach.hasNext()'), (0, ast_1.set)((0, ast_1.ref)('expression'), (0, ast_1.str)('$expression,'))),
                ]),
            ])),
            (0, ast_1.iff)((0, ast_1.raw)('!$expAdd.isEmpty()'), (0, ast_1.compoundExpression)([
                (0, ast_1.set)((0, ast_1.ref)('expression'), (0, ast_1.str)('$expression ADD')),
                (0, ast_1.forEach)((0, ast_1.ref)('entry'), (0, ast_1.ref)('expAdd.entrySet()'), [
                    (0, ast_1.set)((0, ast_1.ref)('expression'), (0, ast_1.str)('$expression $entry.key $entry.value')),
                    (0, ast_1.iff)((0, ast_1.ref)('foreach.hasNext()'), (0, ast_1.set)((0, ast_1.ref)('expression'), (0, ast_1.str)('$expression,'))),
                ]),
            ])),
            (0, ast_1.iff)((0, ast_1.raw)('!$expRemove.isEmpty()'), (0, ast_1.compoundExpression)([
                (0, ast_1.set)((0, ast_1.ref)('expression'), (0, ast_1.str)('$expression REMOVE')),
                (0, ast_1.forEach)((0, ast_1.ref)('entry'), (0, ast_1.ref)('expRemove'), [
                    (0, ast_1.set)((0, ast_1.ref)('expression'), (0, ast_1.str)('$expression $entry')),
                    (0, ast_1.iff)((0, ast_1.ref)('foreach.hasNext()'), (0, ast_1.set)((0, ast_1.ref)('expression'), (0, ast_1.str)('$expression,'))),
                ]),
            ])),
            (0, ast_1.set)((0, ast_1.ref)('update'), (0, ast_1.obj)({})),
            (0, ast_1.qref)('$update.put("expression", "$expression")'),
            (0, ast_1.iff)((0, ast_1.raw)('!$expNames.isEmpty()'), (0, ast_1.qref)('$update.put("expressionNames", $expNames)')),
            (0, ast_1.iff)((0, ast_1.raw)('!$expValues.isEmpty()'), (0, ast_1.qref)('$update.put("expressionValues", $expValues)')),
            (0, ast_1.obj)({
                version: (0, ast_1.str)(version),
                operation: (0, ast_1.str)('UpdateItem'),
                key,
                update: (0, ast_1.ref)('util.toJson($update)'),
                condition,
                ...(isSyncEnabled && { _version: (0, ast_1.ref)('util.defaultIfNull($ctx.args.input["_version"], "0")') }),
            }),
        ]);
    }
    static dynamoDBResponse(isSyncEnabled, returnExpression) {
        const errorExpresion = isSyncEnabled
            ? (0, ast_1.ref)('util.error($ctx.error.message, $ctx.error.type, $ctx.result)')
            : (0, ast_1.ref)('util.error($ctx.error.message, $ctx.error.type)');
        const resultExpression = returnExpression ? returnExpression : (0, ast_1.ref)('util.toJson($ctx.result)');
        return (0, ast_1.compoundExpression)([(0, ast_1.ifElse)((0, ast_1.ref)('ctx.error'), errorExpresion, resultExpression)]);
    }
    static stringAttributeValue(value) {
        return {
            kind: 'Object',
            attributes: [['S', { kind: 'Quotes', expr: value }]],
        };
    }
    static numericAttributeValue(value) {
        return {
            kind: 'Object',
            attributes: [['N', { kind: 'Quotes', expr: value }]],
        };
    }
    static binaryAttributeValue(value) {
        return {
            kind: 'Object',
            attributes: [['B', { kind: 'Quotes', expr: value }]],
        };
    }
    static paginatedResponse() {
        return (0, ast_1.obj)({
            items: (0, ast_1.ref)('util.toJson($ctx.result.items)'),
            nextToken: (0, ast_1.ref)('util.toJson($util.defaultIfNullOrBlank($context.result.nextToken, null))'),
        });
    }
}
exports.DynamoDBMappingTemplate = DynamoDBMappingTemplate;
//# sourceMappingURL=dynamodb.js.map