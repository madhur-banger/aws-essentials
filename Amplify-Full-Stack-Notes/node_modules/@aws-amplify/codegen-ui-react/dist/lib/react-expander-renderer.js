"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReactExpanderRenderer = void 0;
const typescript_1 = require("typescript");
const imports_1 = require("./imports");
const primitive_1 = require("./primitive");
class ReactExpanderRenderer {
    constructor(expander, imports) {
        this.imports = imports;
        this.requiredUIReactImports = [primitive_1.Primitive.Expander, primitive_1.Primitive.ExpanderItem];
        this.expander = expander;
        this.requiredUIReactImports.forEach((importName) => {
            imports.addImport(imports_1.ImportSource.UI_REACT, importName);
        });
    }
    renderElement() {
        return typescript_1.factory.createJsxElement(this.createOpeningExpanderElement(), [this.createExpanderChildren()], typescript_1.factory.createJsxClosingElement(typescript_1.factory.createIdentifier(primitive_1.Primitive.Expander)));
    }
    createExpanderChildren() {
        const itemParam = typescript_1.factory.createParameterDeclaration(undefined, undefined, undefined, typescript_1.factory.createIdentifier('item'), undefined, undefined, undefined);
        return typescript_1.factory.createJsxExpression(undefined, typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier('items'), typescript_1.factory.createIdentifier('map')), undefined, [
            typescript_1.factory.createArrowFunction(undefined, undefined, [itemParam], undefined, typescript_1.factory.createToken(typescript_1.SyntaxKind.EqualsGreaterThanToken), typescript_1.factory.createParenthesizedExpression(this.createExpanderItemRow())),
        ]));
    }
    createExpanderItemRow() {
        const child = this.createExpanderItemChild();
        if (!child)
            throw new Error('could not determine ExpanderItem child to render');
        return typescript_1.factory.createJsxElement(typescript_1.factory.createJsxOpeningElement(typescript_1.factory.createIdentifier(primitive_1.Primitive.ExpanderItem), undefined, this.createExpanderItemAttributes()), [child], typescript_1.factory.createJsxClosingElement(typescript_1.factory.createIdentifier(primitive_1.Primitive.ExpanderItem)));
    }
    createExpanderItemChild() {
        const { viewConfiguration } = this.expander;
        if (viewConfiguration.type !== 'Collection') {
            throw new Error(`Cannot create ExpanderItem child for view type: ${viewConfiguration.type}`);
        }
        switch (viewConfiguration.collection.body.type) {
            case 'Amplify.ComponentSlot': {
                if (!viewConfiguration.collection.body.content.componentSlot.componentName) {
                    throw new Error('componentName must be defined');
                }
                const { componentSlot } = viewConfiguration.collection.body.content;
                this.imports.addImport(imports_1.ImportSource.UI_REACT, componentSlot.componentName);
                const attributes = Object.entries(componentSlot.bindingProperties).map(([key, value]) => {
                    const attributeValue = value.field
                        ? typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier(value.property), typescript_1.factory.createIdentifier(value.field))
                        : typescript_1.factory.createIdentifier(value.property);
                    return typescript_1.factory.createJsxAttribute(typescript_1.factory.createIdentifier(key), typescript_1.factory.createJsxExpression(undefined, attributeValue));
                });
                return typescript_1.factory.createJsxSelfClosingElement(typescript_1.factory.createIdentifier(viewConfiguration.collection.body.content.componentSlot.componentName), undefined, typescript_1.factory.createJsxAttributes(attributes));
            }
            case 'Amplify.Binding': {
                if (!viewConfiguration.collection.body.content.bindingProperty) {
                    throw new Error('bindingProperty must be defined');
                }
                const { property, field } = viewConfiguration.collection.body.content.bindingProperty;
                if (!(property && field)) {
                    throw new Error('property and field must be defined');
                }
                return typescript_1.factory.createJsxExpression(undefined, typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier(property), typescript_1.factory.createIdentifier(field)));
            }
            default: {
                // "viewConfiguration.collection.body.type" should be a "never" TS type here, so we can't reference it.
                throw new Error(`Unrecognized value for field type in viewConfiguration.collection.body`);
            }
        }
    }
    createExpanderItemAttributes() {
        var _a;
        const { viewConfiguration } = this.expander;
        if (viewConfiguration.type === 'Collection') {
            switch ((_a = viewConfiguration.collection.title) === null || _a === void 0 ? void 0 : _a.type) {
                case 'Amplify.Binding':
                    return typescript_1.factory.createJsxAttributes([
                        typescript_1.factory.createJsxAttribute(typescript_1.factory.createIdentifier('title'), typescript_1.factory.createJsxExpression(undefined, typescript_1.factory.createPropertyAccessExpression(
                        /**
                         * leaving "item" hard coded since it's controlled by the code in this package
                         * and it should never be something else in this context,
                         * but the user can still set this in the schema.
                         */
                        typescript_1.factory.createIdentifier('item'), typescript_1.factory.createIdentifier(viewConfiguration.collection.title.content.bindingProperty.field)))),
                        /**
                         * Value is needed for the expander item to expand,
                         * the user doesn't need it
                         */
                        typescript_1.factory.createJsxAttribute(typescript_1.factory.createIdentifier('value'), typescript_1.factory.createJsxExpression(undefined, typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier('item'), typescript_1.factory.createIdentifier('id')))),
                        /**
                         * Key here is for React to render a list of items
                         */
                        typescript_1.factory.createJsxAttribute(typescript_1.factory.createIdentifier('key'), typescript_1.factory.createJsxExpression(undefined, typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier('item'), typescript_1.factory.createIdentifier('id')))),
                    ]);
                default:
                    throw new Error(`Unsupported Expander title type, ${viewConfiguration.collection.title.type}`);
            }
        }
        return typescript_1.factory.createJsxAttributes([]);
    }
    createOpeningExpanderElement() {
        return typescript_1.factory.createJsxOpeningElement(typescript_1.factory.createIdentifier(primitive_1.Primitive.Expander), undefined, 
        // TODO: updating "type" here is handled in a future task
        typescript_1.factory.createJsxAttributes([
            typescript_1.factory.createJsxAttribute(typescript_1.factory.createIdentifier('type'), typescript_1.factory.createStringLiteral('multiple')),
        ]));
    }
}
exports.ReactExpanderRenderer = ReactExpanderRenderer;
//# sourceMappingURL=react-expander-renderer.js.map