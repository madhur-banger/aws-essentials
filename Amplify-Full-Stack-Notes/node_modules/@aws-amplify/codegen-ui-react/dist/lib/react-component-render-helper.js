"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasChildrenProp = exports.getSetStateName = exports.getStateName = exports.sanitizeName = exports.addBindingPropertiesImports = exports.buildCtaLayoutProperties = exports.buildFormLayoutProperties = exports.buildOpeningElementProperties = exports.buildChildElement = exports.buildConditionalAttr = exports.buildConditionalExpression = exports.getConditionalOperandExpression = exports.parseNumberOperand = exports.getSyntaxKindToken = exports.resolvePropToExpression = exports.propertyToExpression = exports.buildStateAttr = exports.buildStateExpression = exports.buildConcatAttr = exports.buildConcatExpression = exports.buildCollectionBindingAttrWithDefault = exports.buildCollectionBindingWithDefaultExpression = exports.buildCollectionBindingAttr = exports.buildCollectionBindingExpression = exports.buildFixedAttr = exports.buildFixedJsxExpression = exports.buildFixedLiteralExpression = exports.buildBindingAttrWithDefault = exports.buildBindingWithDefaultExpression = exports.buildUserAuthAttr = exports.buildBindingAttr = exports.buildBindingExpression = exports.isActionEvent = exports.isBoundEvent = exports.isDefaultValueOnly = exports.isSetStateParameter = exports.isStateProperty = exports.isConditionalProperty = exports.isConcatenatedProperty = exports.isCollectionItemBoundProperty = exports.isBoundProperty = exports.isFixedPropertyWithValue = exports.getComponentPropName = exports.getFixedComponentPropValueExpression = void 0;
/*
  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.

  Licensed under the Apache License, Version 2.0 (the "License").
  You may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
 */
const codegen_ui_1 = require("@aws-amplify/codegen-ui");
const typescript_1 = require("typescript");
const react_studio_template_renderer_helper_1 = require("./react-studio-template-renderer-helper");
const utils_1 = require("./workflow/utils");
const name_replacements_1 = __importDefault(require("./name-replacements"));
const keywords_1 = __importDefault(require("./keywords"));
const form_state_1 = require("./forms/form-renderer-helper/form-state");
function getFixedComponentPropValueExpression(prop) {
    return typescript_1.factory.createStringLiteral(prop.value.toString(), true);
}
exports.getFixedComponentPropValueExpression = getFixedComponentPropValueExpression;
function getComponentPropName(componentName) {
    if (componentName !== undefined) {
        return `${componentName}Props`;
    }
    return 'ComponentWithoutNameProps';
}
exports.getComponentPropName = getComponentPropName;
function isFixedPropertyWithValue(prop) {
    return typeof prop === 'object' && 'value' in prop;
}
exports.isFixedPropertyWithValue = isFixedPropertyWithValue;
function isBoundProperty(prop) {
    return typeof prop === 'object' && 'bindingProperties' in prop;
}
exports.isBoundProperty = isBoundProperty;
function isCollectionItemBoundProperty(prop) {
    return typeof prop === 'object' && 'collectionBindingProperties' in prop;
}
exports.isCollectionItemBoundProperty = isCollectionItemBoundProperty;
function isConcatenatedProperty(prop) {
    return typeof prop === 'object' && 'concat' in prop;
}
exports.isConcatenatedProperty = isConcatenatedProperty;
function isConditionalProperty(prop) {
    return typeof prop === 'object' && 'condition' in prop;
}
exports.isConditionalProperty = isConditionalProperty;
function isStateProperty(property) {
    return typeof property === 'object' && 'componentName' in property && 'property' in property;
}
exports.isStateProperty = isStateProperty;
function isSetStateParameter(parameter) {
    return typeof parameter === 'object' && 'componentName' in parameter && 'property' in parameter && 'set' in parameter;
}
exports.isSetStateParameter = isSetStateParameter;
function isDefaultValueOnly(prop) {
    return (typeof prop === 'object' &&
        'defaultValue' in prop &&
        !(isCollectionItemBoundProperty(prop) || isBoundProperty(prop)));
}
exports.isDefaultValueOnly = isDefaultValueOnly;
function isBoundEvent(event) {
    return typeof event === 'object' && 'bindingEvent' in event;
}
exports.isBoundEvent = isBoundEvent;
function isActionEvent(event) {
    return typeof event === 'object' && 'action' in event;
}
exports.isActionEvent = isActionEvent;
/**
 * case: has field => <prop.bindingProperties.property>?.<prop.bindingProperties.field>
 * case: no field =>  <prop.bindingProperties.property>
 */
function buildBindingExpression(prop) {
    const { bindingProperties: { property }, } = prop;
    const identifier = typescript_1.factory.createIdentifier(keywords_1.default.has(property) ? `${property}Prop` : property);
    return prop.bindingProperties.field === undefined
        ? identifier
        : typescript_1.factory.createPropertyAccessChain(identifier, typescript_1.factory.createToken(typescript_1.SyntaxKind.QuestionDotToken), prop.bindingProperties.field);
}
exports.buildBindingExpression = buildBindingExpression;
function buildBindingAttr(prop, propName) {
    const expr = buildBindingExpression(prop);
    return typescript_1.factory.createJsxAttribute(typescript_1.factory.createIdentifier(propName), typescript_1.factory.createJsxExpression(undefined, expr));
}
exports.buildBindingAttr = buildBindingAttr;
function buildAuthExpression(prop) {
    return typescript_1.factory.createElementAccessExpression(typescript_1.factory.createIdentifier('authAttributes'), typescript_1.factory.createStringLiteral(prop.userAttribute));
}
function buildUserAuthAttr(prop, propName) {
    return typescript_1.factory.createJsxAttribute(typescript_1.factory.createIdentifier(propName), typescript_1.factory.createJsxExpression(undefined, buildAuthExpression(prop)));
}
exports.buildUserAuthAttr = buildUserAuthAttr;
function buildBindingWithDefaultExpression(prop, defaultValue) {
    const rightExpr = typescript_1.factory.createStringLiteral(defaultValue);
    const leftExpr = prop.bindingProperties.field === undefined
        ? typescript_1.factory.createIdentifier(prop.bindingProperties.property)
        : typescript_1.factory.createPropertyAccessChain(typescript_1.factory.createIdentifier(prop.bindingProperties.property), typescript_1.factory.createToken(typescript_1.SyntaxKind.QuestionDotToken), prop.bindingProperties.field);
    return typescript_1.factory.createBinaryExpression(leftExpr, typescript_1.factory.createToken(typescript_1.SyntaxKind.BarBarToken), rightExpr);
}
exports.buildBindingWithDefaultExpression = buildBindingWithDefaultExpression;
function buildBindingAttrWithDefault(prop, propName, defaultValue) {
    const binaryExpr = buildBindingWithDefaultExpression(prop, defaultValue);
    return typescript_1.factory.createJsxAttribute(typescript_1.factory.createIdentifier(propName), typescript_1.factory.createJsxExpression(undefined, binaryExpr));
}
exports.buildBindingAttrWithDefault = buildBindingAttrWithDefault;
function buildFixedLiteralExpression(prop) {
    const { value, type } = prop;
    switch (typeof value) {
        case 'number':
            return typescript_1.factory.createNumericLiteral(value, undefined);
        case 'boolean':
            return value ? typescript_1.factory.createTrue() : typescript_1.factory.createFalse();
        case 'string':
            return fixedPropertyWithTypeToLiteral(value, type);
        case 'object':
            if (value instanceof Date) {
                throw new Error('Date object is not currently supported for fixed literal expression.');
            }
            return (0, react_studio_template_renderer_helper_1.jsonToLiteral)(value);
        default:
            throw new Error(`Invalid type ${typeof value} for "${value}"`);
    }
}
exports.buildFixedLiteralExpression = buildFixedLiteralExpression;
function buildFixedJsxExpression(prop) {
    const expression = buildFixedLiteralExpression(prop);
    // do not wrap strings with brackets
    if (expression.kind === typescript_1.SyntaxKind.StringLiteral) {
        return expression;
    }
    return typescript_1.factory.createJsxExpression(undefined, buildFixedLiteralExpression(prop));
}
exports.buildFixedJsxExpression = buildFixedJsxExpression;
function fixedPropertyWithTypeToLiteral(strValue, type) {
    switch (type) {
        case undefined:
        case 'String':
        case 'string':
            return typescript_1.factory.createStringLiteral(strValue);
        default:
            try {
                const parsedValue = JSON.parse(strValue);
                if (type && typeof parsedValue !== type.toLowerCase()) {
                    throw new Error(`Parsed value type "${typeof parsedValue}" and specified type "${type}" mismatch`);
                }
                switch (typeof parsedValue) {
                    case 'number':
                        return typescript_1.factory.createNumericLiteral(parsedValue, undefined);
                    case 'boolean':
                        return parsedValue ? typescript_1.factory.createTrue() : typescript_1.factory.createFalse();
                    // object, array, and null
                    default:
                        return (0, react_studio_template_renderer_helper_1.jsonToLiteral)(parsedValue);
                }
            }
            catch (e) {
                if (e instanceof SyntaxError) {
                    throw new Error(`Failed to parse value "${strValue}"`);
                }
                else {
                    throw e;
                }
            }
    }
}
function buildFixedAttr(prop, propName) {
    const expr = buildFixedJsxExpression(prop);
    return typescript_1.factory.createJsxAttribute(typescript_1.factory.createIdentifier(propName), expr);
}
exports.buildFixedAttr = buildFixedAttr;
function buildCollectionBindingExpression(prop) {
    return prop.collectionBindingProperties.field === undefined
        ? typescript_1.factory.createIdentifier('item')
        : typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier('item'), prop.collectionBindingProperties.field);
}
exports.buildCollectionBindingExpression = buildCollectionBindingExpression;
function buildCollectionBindingAttr(prop, propName) {
    const expr = buildCollectionBindingExpression(prop);
    const attr = typescript_1.factory.createJsxAttribute(typescript_1.factory.createIdentifier(propName), typescript_1.factory.createJsxExpression(undefined, expr));
    return attr;
}
exports.buildCollectionBindingAttr = buildCollectionBindingAttr;
function buildCollectionBindingWithDefaultExpression(prop, defaultValue) {
    const rightExpr = typescript_1.factory.createStringLiteral(defaultValue);
    const leftExpr = prop.collectionBindingProperties.field === undefined
        ? typescript_1.factory.createIdentifier('item')
        : typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier('item'), prop.collectionBindingProperties.field);
    return typescript_1.factory.createBinaryExpression(leftExpr, typescript_1.factory.createToken(typescript_1.SyntaxKind.BarBarToken), rightExpr);
}
exports.buildCollectionBindingWithDefaultExpression = buildCollectionBindingWithDefaultExpression;
function buildCollectionBindingAttrWithDefault(prop, propName, defaultValue) {
    const binaryExpr = buildCollectionBindingWithDefaultExpression(prop, defaultValue);
    const attr = typescript_1.factory.createJsxAttribute(typescript_1.factory.createIdentifier(propName), typescript_1.factory.createJsxExpression(undefined, binaryExpr));
    return attr;
}
exports.buildCollectionBindingAttrWithDefault = buildCollectionBindingAttrWithDefault;
function buildConcatExpression(prop) {
    const expressions = [];
    prop.concat.forEach((propItem) => {
        if (isFixedPropertyWithValue(propItem)) {
            expressions.push(buildFixedJsxExpression(propItem));
        }
        else if (isBoundProperty(propItem)) {
            const expr = propItem.defaultValue === undefined
                ? buildBindingExpression(propItem)
                : buildBindingWithDefaultExpression(propItem, propItem.defaultValue);
            expressions.push(expr);
        }
        else if ((0, codegen_ui_1.isAuthProperty)(propItem)) {
            expressions.push(buildAuthExpression(propItem));
        }
        else if (isCollectionItemBoundProperty(propItem)) {
            const expr = propItem.defaultValue === undefined
                ? buildCollectionBindingExpression(propItem)
                : buildCollectionBindingWithDefaultExpression(propItem, propItem.defaultValue);
            expressions.push(expr);
        }
        else if (isConcatenatedProperty(propItem)) {
            expressions.push(buildConcatExpression(propItem));
        }
    });
    const templateSpans = [];
    expressions.forEach((expr, index) => {
        const span = index === expressions.length - 1
            ? typescript_1.factory.createTemplateSpan(expr, typescript_1.factory.createTemplateTail('', ''))
            : typescript_1.factory.createTemplateSpan(expr, typescript_1.factory.createTemplateMiddle('', ''));
        templateSpans.push(span);
    });
    return typescript_1.factory.createTemplateExpression(typescript_1.factory.createTemplateHead('', ''), templateSpans);
}
exports.buildConcatExpression = buildConcatExpression;
function buildConcatAttr(prop, propName) {
    const expr = buildConcatExpression(prop);
    return typescript_1.factory.createJsxAttribute(typescript_1.factory.createIdentifier(propName), typescript_1.factory.createJsxExpression(undefined, expr));
}
exports.buildConcatAttr = buildConcatAttr;
function buildStateExpression(componentMetadata, { componentName, property }) {
    const childrenPropMapping = (0, utils_1.getChildPropMappingForComponentName)(componentMetadata, componentName);
    const mappedSyntheticProperty = property === childrenPropMapping ? 'children' : property;
    return typescript_1.factory.createIdentifier(getStateName({ componentName, property: mappedSyntheticProperty }));
}
exports.buildStateExpression = buildStateExpression;
function buildStateAttr(componentMetadata, prop, propName) {
    const expr = buildStateExpression(componentMetadata, prop);
    return typescript_1.factory.createJsxAttribute(typescript_1.factory.createIdentifier(propName), typescript_1.factory.createJsxExpression(undefined, expr));
}
exports.buildStateAttr = buildStateAttr;
function propertyToExpression(componentMetadata, property) {
    if (property === undefined) {
        return typescript_1.factory.createIdentifier('undefined');
    }
    if (isFixedPropertyWithValue(property)) {
        return buildFixedLiteralExpression(property);
    }
    if (isBoundProperty(property)) {
        return property.defaultValue === undefined
            ? buildBindingExpression(property)
            : buildBindingWithDefaultExpression(property, property.defaultValue);
    }
    if (isConcatenatedProperty(property)) {
        return buildConcatExpression(property);
    }
    if (isConditionalProperty(property)) {
        return buildConditionalExpression(componentMetadata, property);
    }
    if (isStateProperty(property)) {
        return buildStateExpression(componentMetadata, property);
    }
    if ((0, codegen_ui_1.isAuthProperty)(property)) {
        return buildAuthExpression(property);
    }
    throw new Error(`Invalid property: ${JSON.stringify(property)}.`);
}
exports.propertyToExpression = propertyToExpression;
function resolvePropToExpression(componentMetadata, prop) {
    if (isFixedPropertyWithValue(prop)) {
        const propValue = prop.value;
        switch (typeof propValue) {
            case 'number':
                return typescript_1.factory.createNumericLiteral(propValue, undefined);
            case 'boolean':
                return propValue ? typescript_1.factory.createTrue() : typescript_1.factory.createFalse();
            default:
                return typescript_1.factory.createStringLiteral(propValue.toString(), undefined);
        }
    }
    if (isBoundProperty(prop)) {
        const expr = prop.defaultValue === undefined
            ? buildBindingExpression(prop)
            : buildBindingWithDefaultExpression(prop, prop.defaultValue);
        return expr;
    }
    if ((0, codegen_ui_1.isAuthProperty)(prop)) {
        return buildAuthExpression(prop);
    }
    if (isCollectionItemBoundProperty(prop)) {
        const expr = prop.defaultValue === undefined
            ? buildCollectionBindingExpression(prop)
            : buildCollectionBindingWithDefaultExpression(prop, prop.defaultValue);
        return expr;
    }
    if (isConcatenatedProperty(prop)) {
        return buildConcatExpression(prop);
    }
    if (isConditionalProperty(prop)) {
        return buildConditionalExpression(componentMetadata, prop);
    }
    if (isStateProperty(prop)) {
        return buildStateExpression(componentMetadata, prop);
    }
    return typescript_1.factory.createVoidZero();
}
exports.resolvePropToExpression = resolvePropToExpression;
function getSyntaxKindToken(operator) {
    switch (operator) {
        case 'eq':
            return typescript_1.factory.createToken(typescript_1.SyntaxKind.EqualsEqualsToken);
        case 'ne':
            return typescript_1.factory.createToken(typescript_1.SyntaxKind.ExclamationEqualsToken);
        case 'le':
            return typescript_1.factory.createToken(typescript_1.SyntaxKind.LessThanEqualsToken);
        case 'lt':
            return typescript_1.factory.createToken(typescript_1.SyntaxKind.LessThanToken);
        case 'ge':
            return typescript_1.factory.createToken(typescript_1.SyntaxKind.GreaterThanEqualsToken);
        case 'gt':
            return typescript_1.factory.createToken(typescript_1.SyntaxKind.GreaterThanToken);
        /* istanbul ignore next */
        default:
            return undefined;
    }
}
exports.getSyntaxKindToken = getSyntaxKindToken;
function parseNumberOperand(operand, dataField) {
    if (dataField) {
        const numberOperandType = ['Int', 'Float'];
        if (numberOperandType.includes(dataField.dataType)) {
            const parsedOperand = parseFloat(`${operand}`);
            if (!Number.isNaN(parsedOperand) && Number.isFinite(parsedOperand)) {
                return parsedOperand;
            }
        }
    }
    return operand;
}
exports.parseNumberOperand = parseNumberOperand;
function getConditionalOperandExpression(operand, operandType) {
    if (typeof operand === 'string' && operandType && operandType !== 'string') {
        return stringValueToTypedLiteral(operand, operandType);
    }
    return typedValueToJsxLiteral(operand);
}
exports.getConditionalOperandExpression = getConditionalOperandExpression;
function stringValueToTypedLiteral(value, valueType) {
    try {
        const typedVal = JSON.parse(value);
        if (valueType === typeof typedVal) {
            return typedValueToJsxLiteral(typedVal);
        }
        throw Error(`Parsed value ${value} and type ${valueType} mismatch`);
    }
    catch (err) {
        if (err instanceof SyntaxError) {
            return typescript_1.factory.createStringLiteral(value);
        }
        throw err;
    }
}
function typedValueToJsxLiteral(value) {
    switch (typeof value) {
        case 'number':
            return typescript_1.factory.createNumericLiteral(value);
        case 'boolean':
            return value ? typescript_1.factory.createTrue() : typescript_1.factory.createFalse();
        default:
            return typescript_1.factory.createStringLiteral(value);
    }
}
function buildConditionalExpression(componentMetadata, prop) {
    const { property, field, operand, operandType, operator, then } = prop.condition;
    const elseBlock = prop.condition.else;
    const operatorToken = getSyntaxKindToken(operator);
    if (operatorToken === undefined) {
        return typescript_1.factory.createJsxExpression(undefined, undefined);
    }
    const propertyAccess = field !== undefined
        ? typescript_1.factory.createPropertyAccessChain(typescript_1.factory.createIdentifier(property), typescript_1.factory.createToken(typescript_1.SyntaxKind.QuestionDotToken), typescript_1.factory.createIdentifier(field))
        : typescript_1.factory.createIdentifier(property);
    return typescript_1.factory.createConditionalExpression(typescript_1.factory.createBinaryExpression(propertyAccess, operatorToken, getConditionalOperandExpression(operand, operandType)), typescript_1.factory.createToken(typescript_1.SyntaxKind.QuestionToken), resolvePropToExpression(componentMetadata, then), typescript_1.factory.createToken(typescript_1.SyntaxKind.ColonToken), resolvePropToExpression(componentMetadata, elseBlock));
}
exports.buildConditionalExpression = buildConditionalExpression;
function buildConditionalAttr(componentMetadata, prop, propName) {
    const expr = buildConditionalExpression(componentMetadata, prop);
    return typescript_1.factory.createJsxAttribute(typescript_1.factory.createIdentifier(propName), typescript_1.factory.createJsxExpression(undefined, expr));
}
exports.buildConditionalAttr = buildConditionalAttr;
function buildChildElement(componentMetadata, prop) {
    if (!prop) {
        return undefined;
    }
    let expression;
    if (isFixedPropertyWithValue(prop)) {
        expression = buildFixedJsxExpression(prop);
    }
    if (isBoundProperty(prop)) {
        expression =
            prop.defaultValue === undefined
                ? buildBindingExpression(prop)
                : buildBindingWithDefaultExpression(prop, prop.defaultValue);
    }
    if (isCollectionItemBoundProperty(prop)) {
        expression =
            prop.defaultValue === undefined
                ? buildCollectionBindingExpression(prop)
                : buildCollectionBindingWithDefaultExpression(prop, prop.defaultValue);
    }
    if (isConcatenatedProperty(prop)) {
        expression = buildConcatExpression(prop);
    }
    if (isConditionalProperty(prop)) {
        expression = buildConditionalExpression(componentMetadata, prop);
    }
    return expression && typescript_1.factory.createJsxExpression(undefined, expression);
}
exports.buildChildElement = buildChildElement;
function buildOpeningElementProperties(componentMetadata, prop, name) {
    if (isFixedPropertyWithValue(prop)) {
        return buildFixedAttr(prop, name);
    }
    if (isBoundProperty(prop)) {
        return prop.defaultValue === undefined
            ? buildBindingAttr(prop, name)
            : buildBindingAttrWithDefault(prop, name, prop.defaultValue);
    }
    if ((0, codegen_ui_1.isAuthProperty)(prop)) {
        return buildUserAuthAttr(prop, name);
    }
    if (isCollectionItemBoundProperty(prop)) {
        return prop.defaultValue === undefined
            ? buildCollectionBindingAttr(prop, name)
            : buildCollectionBindingAttrWithDefault(prop, name, prop.defaultValue);
    }
    if (isConcatenatedProperty(prop)) {
        return buildConcatAttr(prop, name);
    }
    if (isConditionalProperty(prop)) {
        return buildConditionalAttr(componentMetadata, prop, name);
    }
    if (isStateProperty(prop)) {
        return buildStateAttr(componentMetadata, prop, name);
    }
    return typescript_1.factory.createJsxAttribute(typescript_1.factory.createIdentifier(name), undefined);
}
exports.buildOpeningElementProperties = buildOpeningElementProperties;
function buildFixedOrTokenRefAttribute(styleConfig, propName) {
    if (styleConfig.value) {
        return buildFixedAttr({ value: styleConfig.value }, propName);
    }
    if (styleConfig.tokenReference) {
        const tokenReference = ['tokens', ...styleConfig.tokenReference.split('.')];
        return typescript_1.factory.createJsxAttribute(typescript_1.factory.createIdentifier(propName), typescript_1.factory.createJsxExpression(undefined, typescript_1.factory.createPropertyAccessExpression((0, form_state_1.buildAccessChain)(tokenReference, false), 'value')));
    }
    return undefined;
}
function buildFormLayoutProperties(formMetadata) {
    var _a;
    const propMap = {
        horizontalGap: 'rowGap',
        verticalGap: 'columnGap',
        outerPadding: 'padding',
    };
    return Object.entries((_a = formMetadata === null || formMetadata === void 0 ? void 0 : formMetadata.layoutConfigs) !== null && _a !== void 0 ? _a : {}).reduce((acc, value) => {
        const mappedProp = propMap[value[0]];
        if (!mappedProp) {
            return acc;
        }
        const mappedAttribute = buildFixedOrTokenRefAttribute(value[1], mappedProp);
        if (mappedAttribute) {
            acc.push(mappedAttribute);
        }
        return acc;
    }, []);
}
exports.buildFormLayoutProperties = buildFormLayoutProperties;
function buildCtaLayoutProperties(formMetadata) {
    return buildFixedOrTokenRefAttribute(formMetadata.layoutConfigs.verticalGap, 'gap');
}
exports.buildCtaLayoutProperties = buildCtaLayoutProperties;
function addBindingPropertiesImports(component, importCollection) {
    if (typeof component === 'object' && 'bindingProperties' in component) {
        Object.entries(component.bindingProperties).forEach(([, binding]) => {
            if (typeof binding === 'object' && 'bindingProperties' in binding && 'model' in binding.bindingProperties) {
                importCollection.addModelImport(binding.bindingProperties.model);
            }
        });
    }
}
exports.addBindingPropertiesImports = addBindingPropertiesImports;
// Scrub all non-alphanum characters, and any leading numbers so we can generate a legal
// variable name.
function sanitizeName(componentName) {
    return name_replacements_1.default
        .reduce((name, [character, replacement]) => name.replace(character, replacement), componentName)
        .replace(/[^a-zA-Z]/g, ''); // remove any stray non alpha characters
}
exports.sanitizeName = sanitizeName;
function getStateName(stateReference) {
    const { componentName, property } = stateReference;
    const rawStateName = [
        componentName.charAt(0).toLowerCase() + componentName.slice(1),
        property.charAt(0).toUpperCase() + property.slice(1),
    ].join('');
    return sanitizeName(rawStateName);
}
exports.getStateName = getStateName;
function getSetStateName(stateReference) {
    const stateName = getStateName(stateReference);
    return ['set', stateName.charAt(0).toUpperCase() + stateName.slice(1)].join('');
}
exports.getSetStateName = getSetStateName;
function hasChildrenProp(componentProperties) {
    return !!(typeof componentProperties === 'object' &&
        'children' in componentProperties &&
        componentProperties.children);
}
exports.hasChildrenProp = hasChildrenProp;
//# sourceMappingURL=react-component-render-helper.js.map