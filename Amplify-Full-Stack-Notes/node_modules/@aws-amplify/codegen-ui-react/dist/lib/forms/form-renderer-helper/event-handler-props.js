"use strict";
/*
  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.

  Licensed under the Apache License, Version 2.0 (the "License").
  You may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildStorageManagerOnChangeStatement = exports.buildOnSelect = exports.buildOnChangeStatement = exports.buildOverrideOnChangeStatement = exports.buildOnClearStatement = exports.buildOnBlurStatement = exports.buildMutationBindings = void 0;
const codegen_ui_1 = require("@aws-amplify/codegen-ui");
const typescript_1 = require("typescript");
const helpers_1 = require("../../helpers");
const event_targets_1 = require("./event-targets");
const form_state_1 = require("./form-state");
const validation_1 = require("./validation");
const model_fields_1 = require("./model-fields");
const render_checkers_1 = require("./render-checkers");
const model_values_1 = require("./model-values");
const constants_1 = require("../../utils/constants");
const graphql_1 = require("../../utils/graphql");
const buildMutationBindings = (form, primaryKeys = []) => {
    const { dataType: { dataSourceType, dataTypeName }, formActionType, } = form;
    const elements = [];
    if (dataSourceType === 'DataStore' && primaryKeys.length) {
        if (formActionType === 'update') {
            elements.push(
            // id: idProp
            typescript_1.factory.createBindingElement(undefined, 
            // if greater than 1, it's a composite key. using 'id' for a composite key prop name.
            typescript_1.factory.createIdentifier(primaryKeys.length > 1 ? constants_1.COMPOSITE_PRIMARY_KEY_PROP_NAME : primaryKeys[0]), typescript_1.factory.createIdentifier(primaryKeys.length > 1 ? (0, form_state_1.getPropName)(constants_1.COMPOSITE_PRIMARY_KEY_PROP_NAME) : (0, form_state_1.getPropName)(primaryKeys[0])), undefined), 
            // modelName: modelNameModelProp
            typescript_1.factory.createBindingElement(undefined, typescript_1.factory.createIdentifier((0, helpers_1.lowerCaseFirst)(dataTypeName)), typescript_1.factory.createIdentifier((0, helpers_1.getModelNameProp)(dataTypeName)), undefined));
        }
        if (formActionType === 'create') {
            elements.push(typescript_1.factory.createBindingElement(undefined, undefined, typescript_1.factory.createIdentifier('clearOnSuccess'), typescript_1.factory.createTrue()));
        }
        elements.push(typescript_1.factory.createBindingElement(undefined, undefined, typescript_1.factory.createIdentifier('onSuccess'), undefined), typescript_1.factory.createBindingElement(undefined, undefined, typescript_1.factory.createIdentifier('onError'), undefined));
    }
    if (dataSourceType === 'Custom' && formActionType === 'update') {
        elements.push(typescript_1.factory.createBindingElement(undefined, undefined, typescript_1.factory.createIdentifier('initialData'), undefined));
    }
    elements.push(typescript_1.factory.createBindingElement(undefined, undefined, typescript_1.factory.createIdentifier('onSubmit'), undefined));
    if ((0, codegen_ui_1.shouldIncludeCancel)(form)) {
        // onCancel prop
        elements.push(typescript_1.factory.createBindingElement(undefined, undefined, typescript_1.factory.createIdentifier('onCancel'), undefined));
    }
    return elements;
};
exports.buildMutationBindings = buildMutationBindings;
function buildOnBlurStatement(fieldName, fieldConfig) {
    const renderedFieldName = fieldConfig.sanitizedFieldName || fieldName;
    let fieldNameIdentifier = typescript_1.factory.createIdentifier(renderedFieldName);
    if (fieldName.includes('.')) {
        const [parent, child] = fieldName.split('.');
        fieldNameIdentifier = typescript_1.factory.createElementAccessExpression(typescript_1.factory.createIdentifier(parent), typescript_1.factory.createStringLiteral(child));
    }
    let valueToValidate = fieldNameIdentifier;
    if ((0, render_checkers_1.shouldWrapInArrayField)(fieldConfig)) {
        valueToValidate = (0, form_state_1.getCurrentValueIdentifier)(renderedFieldName);
    }
    if ((0, render_checkers_1.isModelDataType)(fieldConfig)) {
        valueToValidate = typescript_1.factory.createIdentifier((0, form_state_1.getCurrentDisplayValueName)(renderedFieldName));
    }
    return typescript_1.factory.createJsxAttribute(typescript_1.factory.createIdentifier('onBlur'), typescript_1.factory.createJsxExpression(undefined, typescript_1.factory.createArrowFunction(undefined, undefined, [], undefined, typescript_1.factory.createToken(typescript_1.SyntaxKind.EqualsGreaterThanToken), typescript_1.factory.createCallExpression(typescript_1.factory.createIdentifier('runValidationTasks'), undefined, [
        typescript_1.factory.createStringLiteral(fieldName),
        valueToValidate,
    ]))));
}
exports.buildOnBlurStatement = buildOnBlurStatement;
/**
 * e.g.
 * onClear={() => {
 *  setCurrentTeamDisplayValue('');
 * }}
 */
function buildOnClearStatement(fieldName, fieldConfig) {
    const { componentType, dataType } = fieldConfig;
    const renderedFieldName = fieldConfig.sanitizedFieldName || fieldName;
    const isNotArrayAndNotRelationshipField = !fieldConfig.relationship && !fieldConfig.isArray;
    return typescript_1.factory.createJsxAttribute(typescript_1.factory.createIdentifier('onClear'), typescript_1.factory.createJsxExpression(undefined, typescript_1.factory.createArrowFunction(undefined, undefined, [], undefined, typescript_1.factory.createToken(typescript_1.SyntaxKind.EqualsGreaterThanToken), typescript_1.factory.createBlock([
        typescript_1.factory.createExpressionStatement(typescript_1.factory.createCallExpression((0, helpers_1.getSetNameIdentifier)(isNotArrayAndNotRelationshipField ? renderedFieldName : (0, form_state_1.getCurrentDisplayValueName)(renderedFieldName)), undefined, [(0, form_state_1.getDefaultValueExpression)(fieldName, componentType, dataType, false, true)])),
    ], true))));
}
exports.buildOnClearStatement = buildOnClearStatement;
/**
 * if the onChange variable is defined it will send the current state of the fields into the function
 * the function expects all fields in return
 * the value for that fields onChange will be used from the return object for validation and updating the new state
 *
 * if a valueName override is provided it will use the provided name
 * this the name of the variable to update if onChange override function is provided
 *
 *
 * ex. if the field is email
 * const returnObject = onChange({ email, ...otherFieldsForForm });
 * const value = returnObject.email;
 *
 * this value is now used in email validation and setting the state
 */
const buildOverrideOnChangeStatement = (fieldName, fieldConfigs, valueNameOverride) => {
    const keyPath = fieldName.split('.');
    const keyName = keyPath[0];
    const valueName = valueNameOverride !== null && valueNameOverride !== void 0 ? valueNameOverride : typescript_1.factory.createIdentifier('value');
    let keyValueExpression = typescript_1.factory.createPropertyAssignment((0, codegen_ui_1.isValidVariableName)(keyName) ? typescript_1.factory.createIdentifier(keyName) : typescript_1.factory.createStringLiteral(keyName), valueName);
    if (keyPath.length > 1) {
        keyValueExpression = typescript_1.factory.createPropertyAssignment(typescript_1.factory.createIdentifier(keyName), (0, form_state_1.buildNestedStateSet)(keyPath, [keyName], valueName));
    }
    return typescript_1.factory.createIfStatement(typescript_1.factory.createIdentifier('onChange'), typescript_1.factory.createBlock([
        (0, model_fields_1.buildModelFieldObject)(true, fieldConfigs, {
            [keyName]: keyValueExpression,
        }),
        typescript_1.factory.createVariableStatement(undefined, typescript_1.factory.createVariableDeclarationList([
            typescript_1.factory.createVariableDeclaration(typescript_1.factory.createIdentifier('result'), undefined, undefined, typescript_1.factory.createCallExpression(typescript_1.factory.createIdentifier('onChange'), undefined, [
                typescript_1.factory.createIdentifier('modelFields'),
            ])),
        ], typescript_1.NodeFlags.Const)),
        typescript_1.factory.createExpressionStatement(typescript_1.factory.createBinaryExpression(valueName, typescript_1.factory.createToken(typescript_1.SyntaxKind.EqualsToken), typescript_1.factory.createBinaryExpression((0, form_state_1.buildAccessChain)(['result', ...fieldName.split('.')]), typescript_1.factory.createToken(typescript_1.SyntaxKind.QuestionQuestionToken), valueName))),
    ], true), undefined);
};
exports.buildOverrideOnChangeStatement = buildOverrideOnChangeStatement;
function getOnValueChangeProp(fieldType) {
    var _a;
    const map = {
        StepperField: 'onStepChange',
        StorageField: 'onUploadSuccess',
    };
    return (_a = map[fieldType]) !== null && _a !== void 0 ? _a : 'onChange';
}
function getCallbackVarName(fieldType) {
    var _a;
    const map = {
        StorageField: 'files',
    };
    return (_a = map[fieldType]) !== null && _a !== void 0 ? _a : 'e';
}
const buildOnChangeStatement = (component, fieldConfigs, dataApi) => {
    const { name: fieldName, componentType: fieldType } = component;
    const fieldConfig = fieldConfigs[fieldName];
    const { dataType, sanitizedFieldName, studioFormComponentType, isArray } = fieldConfig;
    const renderedFieldName = sanitizedFieldName || fieldName;
    // build statements that handle new value
    const handleChangeStatements = [
        ...(0, event_targets_1.buildTargetVariable)(studioFormComponentType || fieldType, renderedFieldName, dataType, isArray),
    ];
    if (dataApi === 'GraphQL' && fieldConfig.relationship) {
        handleChangeStatements.push(typescript_1.factory.createExpressionStatement(typescript_1.factory.createCallExpression(typescript_1.factory.createIdentifier((0, graphql_1.getFetchRelatedRecords)(component.name)), undefined, [
            typescript_1.factory.createIdentifier('value'),
        ])));
    }
    if (!(0, render_checkers_1.shouldWrapInArrayField)(fieldConfig)) {
        handleChangeStatements.push((0, exports.buildOverrideOnChangeStatement)(fieldName, fieldConfigs));
    }
    handleChangeStatements.push((0, validation_1.getOnChangeValidationBlock)(fieldName));
    const valueToSetOnChange = typescript_1.factory.createIdentifier('value');
    if ((0, render_checkers_1.shouldWrapInArrayField)(fieldConfig)) {
        if (fieldConfig.relationship) {
            handleChangeStatements.push((0, form_state_1.setStateExpression)((0, form_state_1.getCurrentDisplayValueName)(renderedFieldName), valueToSetOnChange), (0, form_state_1.setStateExpression)((0, form_state_1.getCurrentValueName)(renderedFieldName), typescript_1.factory.createIdentifier('undefined')));
        }
        else {
            handleChangeStatements.push((0, form_state_1.setStateExpression)((0, form_state_1.getCurrentValueName)(renderedFieldName), valueToSetOnChange));
        }
    }
    else {
        handleChangeStatements.push(typescript_1.factory.createExpressionStatement((0, form_state_1.setFieldState)(renderedFieldName, valueToSetOnChange)));
    }
    return typescript_1.factory.createJsxAttribute(typescript_1.factory.createIdentifier(getOnValueChangeProp(fieldType)), typescript_1.factory.createJsxExpression(undefined, typescript_1.factory.createArrowFunction(undefined, undefined, [
        typescript_1.factory.createParameterDeclaration(undefined, undefined, undefined, typescript_1.factory.createIdentifier(getCallbackVarName(fieldType)), undefined, undefined, undefined),
    ], undefined, typescript_1.factory.createToken(typescript_1.SyntaxKind.EqualsGreaterThanToken), typescript_1.factory.createBlock(handleChangeStatements, true))));
};
exports.buildOnChangeStatement = buildOnChangeStatement;
/**
examples:

  scalar:
  onSelect={({ id, label }) => {
    setCurrentPrimaryAuthorValue(id);
    setCurrentPrimaryAuthorDisplayValue(label);
  }}

  model:
  onSelect={({ id, label }) => {
    setCurrentPrimaryAuthorValue(
      primaryAuthorRecords.find((r) => Object.entries(JSON.parse(id)).every(([key, value]) =>
      r[key] === value)));
    );
    setCurrentPrimaryAuthorDisplayValue(label);
  }}
  // For autocomplete field only
 */
function buildOnSelect({ sanitizedFieldName, fieldName, fieldConfig, dataApi, }) {
    const labelString = 'label';
    const idString = 'id';
    const isNotArrayAndNotRelationshipField = !fieldConfig.relationship && !fieldConfig.isArray;
    const props = [
        typescript_1.factory.createBindingElement(undefined, undefined, typescript_1.factory.createIdentifier(idString), undefined),
        typescript_1.factory.createBindingElement(undefined, undefined, typescript_1.factory.createIdentifier(labelString), undefined),
    ];
    let nextCurrentValue = typescript_1.factory.createIdentifier(idString);
    let nextCurrentDisplayValue = typescript_1.factory.createIdentifier(labelString);
    if ((0, render_checkers_1.isModelDataType)(fieldConfig)) {
        const { model, keys } = (0, model_values_1.extractModelAndKeys)(fieldConfig.valueMappings);
        if (!model || !keys || !keys.length) {
            throw new codegen_ui_1.InvalidInputError(`Invalid value mappings`);
        }
        nextCurrentDisplayValue = typescript_1.factory.createIdentifier(labelString);
        nextCurrentValue = (0, model_values_1.getMatchEveryModelFieldCallExpression)({
            // Autocomplete is special and needs a ref to the model for DataStore because the
            // fieldName will not be the same as when the reference was created.
            recordsArrayName: (0, form_state_1.getRecordsName)(dataApi === 'GraphQL' ? fieldName : model),
            JSONName: idString,
        });
    }
    const setStateExpressions = [
        (0, form_state_1.setStateExpression)(isNotArrayAndNotRelationshipField ? sanitizedFieldName : (0, form_state_1.getCurrentValueName)(sanitizedFieldName), nextCurrentValue),
    ];
    if (fieldConfig.relationship) {
        setStateExpressions.push((0, form_state_1.setStateExpression)(isNotArrayAndNotRelationshipField ? sanitizedFieldName : (0, form_state_1.getCurrentDisplayValueName)(sanitizedFieldName), nextCurrentDisplayValue));
    }
    setStateExpressions.push(typescript_1.factory.createExpressionStatement(typescript_1.factory.createCallExpression(typescript_1.factory.createIdentifier('runValidationTasks'), undefined, [
        typescript_1.factory.createStringLiteral(fieldName),
        typescript_1.factory.createIdentifier(fieldConfig.relationship ? labelString : idString),
    ])));
    return typescript_1.factory.createJsxAttribute(typescript_1.factory.createIdentifier('onSelect'), typescript_1.factory.createJsxExpression(undefined, typescript_1.factory.createArrowFunction(undefined, undefined, [
        typescript_1.factory.createParameterDeclaration(undefined, undefined, undefined, typescript_1.factory.createObjectBindingPattern(props), undefined, undefined, undefined),
    ], undefined, typescript_1.factory.createToken(typescript_1.SyntaxKind.EqualsGreaterThanToken), typescript_1.factory.createBlock(setStateExpressions, true))));
}
exports.buildOnSelect = buildOnSelect;
const storageManagerOnChangeHandlerMap = {
    onUploadSuccess: {
        value: {
            scalar: () => typescript_1.factory.createIdentifier('key'),
            array: () => typescript_1.factory.createArrayLiteralExpression([typescript_1.factory.createSpreadElement(typescript_1.factory.createIdentifier('prev')), typescript_1.factory.createIdentifier(constants_1.STORAGE_FILE_KEY)], false),
        },
    },
    onFileRemove: {
        value: {
            scalar: (fieldName) => fieldName ? (0, form_state_1.buildAccessChain)(['initialValues', fieldName]) : typescript_1.factory.createIdentifier('undefined'),
            array: () => typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier('prev'), typescript_1.factory.createIdentifier('filter')), undefined, [
                typescript_1.factory.createArrowFunction(undefined, undefined, [
                    typescript_1.factory.createParameterDeclaration(undefined, undefined, undefined, typescript_1.factory.createIdentifier('f'), undefined, undefined, undefined),
                ], undefined, typescript_1.factory.createToken(typescript_1.SyntaxKind.EqualsGreaterThanToken), typescript_1.factory.createBinaryExpression(typescript_1.factory.createIdentifier('f'), typescript_1.factory.createToken(typescript_1.SyntaxKind.ExclamationEqualsEqualsToken), typescript_1.factory.createIdentifier(constants_1.STORAGE_FILE_KEY))),
            ]),
        },
    },
};
const buildStorageManagerOnChangeStatement = (component, fieldConfigs, handlerName) => {
    const { name: fieldName } = component;
    const fieldConfig = fieldConfigs[fieldName];
    const { sanitizedFieldName, isArray } = fieldConfig;
    const renderedFieldName = sanitizedFieldName || fieldName;
    return typescript_1.factory.createJsxAttribute(typescript_1.factory.createIdentifier(handlerName), typescript_1.factory.createJsxExpression(undefined, typescript_1.factory.createArrowFunction(undefined, undefined, [
        typescript_1.factory.createParameterDeclaration(undefined, undefined, undefined, typescript_1.factory.createObjectBindingPattern([
            typescript_1.factory.createBindingElement(undefined, undefined, typescript_1.factory.createIdentifier(constants_1.STORAGE_FILE_KEY), undefined),
        ]), undefined, undefined, undefined),
    ], undefined, typescript_1.factory.createToken(typescript_1.SyntaxKind.EqualsGreaterThanToken), typescript_1.factory.createBlock([
        typescript_1.factory.createExpressionStatement(typescript_1.factory.createCallExpression((0, helpers_1.getSetNameIdentifier)(renderedFieldName), undefined, [
            typescript_1.factory.createArrowFunction(undefined, undefined, [
                typescript_1.factory.createParameterDeclaration(undefined, undefined, undefined, typescript_1.factory.createIdentifier('prev'), undefined, undefined, undefined),
            ], undefined, typescript_1.factory.createToken(typescript_1.SyntaxKind.EqualsGreaterThanToken), typescript_1.factory.createBlock([
                typescript_1.factory.createVariableStatement(undefined, typescript_1.factory.createVariableDeclarationList([
                    typescript_1.factory.createVariableDeclaration(typescript_1.factory.createIdentifier('value'), undefined, undefined, storageManagerOnChangeHandlerMap[handlerName].value[isArray ? 'array' : 'scalar'](renderedFieldName)),
                ], typescript_1.NodeFlags.Let)),
                (0, exports.buildOverrideOnChangeStatement)(fieldName, fieldConfigs),
                typescript_1.factory.createReturnStatement(typescript_1.factory.createIdentifier('value')),
            ], true)),
        ])),
    ], true))));
};
exports.buildStorageManagerOnChangeStatement = buildStorageManagerOnChangeStatement;
//# sourceMappingURL=event-handler-props.js.map