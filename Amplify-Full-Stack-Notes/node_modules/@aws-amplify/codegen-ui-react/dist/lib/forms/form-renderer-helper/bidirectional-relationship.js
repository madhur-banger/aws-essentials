"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBiDirectionalRelationshipStatements = void 0;
const typescript_1 = require("typescript");
const helpers_1 = require("../../helpers");
const render_checkers_1 = require("./render-checkers");
const form_state_1 = require("./form-state");
const graphql_1 = require("../../utils/graphql");
function getFieldBiDirectionalWith({ modelName, dataSchema, fieldConfig, }) {
    var _a, _b, _c, _d;
    const [, fieldConfigMetaData] = fieldConfig;
    if ((0, render_checkers_1.isModelDataType)(fieldConfigMetaData) &&
        fieldConfigMetaData.relationship &&
        (fieldConfigMetaData.relationship.type === 'HAS_ONE' || fieldConfigMetaData.relationship.type === 'BELONGS_TO')) {
        const { relatedModelName } = fieldConfigMetaData.relationship;
        const fieldBiDirectionalWith = Object.entries((_b = (_a = dataSchema.models[relatedModelName]) === null || _a === void 0 ? void 0 : _a.fields) !== null && _b !== void 0 ? _b : {}).find(([, fieldInfo]) => {
            if (typeof fieldInfo.dataType === 'object' &&
                'model' in fieldInfo.dataType &&
                fieldInfo.dataType.model === modelName &&
                fieldConfigMetaData.relationship &&
                (fieldConfigMetaData.relationship.type === 'HAS_ONE' ||
                    fieldConfigMetaData.relationship.type === 'BELONGS_TO')) {
                return true;
            }
            return false;
        });
        if (!fieldBiDirectionalWith) {
            return undefined;
        }
        const [name, field] = fieldBiDirectionalWith;
        if (((_c = field.relationship) === null || _c === void 0 ? void 0 : _c.type) === 'HAS_ONE' || ((_d = field.relationship) === null || _d === void 0 ? void 0 : _d.type) === 'BELONGS_TO') {
            return {
                relatedModelName,
                fieldBiDirectionalWithName: name,
                fieldBiDirectionalWith: field,
                fieldBiDirectionalWithPrimaryKeys: dataSchema.models[relatedModelName].primaryKeys,
                associatedFieldsBiDirectionalWith: field.relationship.associatedFields
                    ? field.relationship.associatedFields
                    : [],
            };
        }
    }
    return undefined;
}
function unlinkModelRecordExpression({ modelName, primaryKeys, recordNameToUnlink, fieldName, associatedFields, importCollection, dataApi, renderConfigDependencies, }) {
    if (dataApi === 'GraphQL') {
        const inputs = [
            ...primaryKeys.map((primaryKey) => typescript_1.factory.createPropertyAssignment(typescript_1.factory.createIdentifier(primaryKey), typescript_1.factory.createPropertyAccessChain(typescript_1.factory.createIdentifier(recordNameToUnlink), undefined, primaryKey))),
            ...associatedFields.map((field) => typescript_1.factory.createPropertyAssignment(typescript_1.factory.createIdentifier(field), typescript_1.factory.createNull())),
        ];
        return typescript_1.factory.createExpressionStatement(typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier('promises'), typescript_1.factory.createIdentifier('push')), undefined, [
            (0, graphql_1.getGraphqlCallExpression)(graphql_1.ActionType.UPDATE, modelName, importCollection, { inputs }, undefined, renderConfigDependencies),
        ]));
    }
    return typescript_1.factory.createExpressionStatement(typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier('promises'), typescript_1.factory.createIdentifier('push')), undefined, [
        typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier('DataStore'), typescript_1.factory.createIdentifier('save')), undefined, [
            typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier(modelName), typescript_1.factory.createIdentifier('copyOf')), undefined, [
                typescript_1.factory.createIdentifier(recordNameToUnlink),
                typescript_1.factory.createArrowFunction(undefined, undefined, [
                    typescript_1.factory.createParameterDeclaration(undefined, undefined, undefined, typescript_1.factory.createIdentifier('updated'), undefined, undefined, undefined),
                ], undefined, typescript_1.factory.createToken(typescript_1.SyntaxKind.EqualsGreaterThanToken), typescript_1.factory.createBlock([
                    typescript_1.factory.createExpressionStatement(typescript_1.factory.createBinaryExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier('updated'), typescript_1.factory.createIdentifier(fieldName)), typescript_1.factory.createToken(typescript_1.SyntaxKind.EqualsToken), typescript_1.factory.createIdentifier('undefined'))),
                    ...associatedFields.map((field) => typescript_1.factory.createExpressionStatement(typescript_1.factory.createBinaryExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier('updated'), typescript_1.factory.createIdentifier(field)), typescript_1.factory.createToken(typescript_1.SyntaxKind.EqualsToken), typescript_1.factory.createIdentifier('undefined')))),
                ], true)),
            ]),
        ]),
    ]));
}
function unlinkModelThrowErrorExpression(relatedModelName, relatedRecordToLink, modelName, primaryKey, isFieldRequired) {
    // Dog dkflj423dfl cannot be unlinked because Dog requires an Owner.
    // "Image 398038 cannot be linked to FakeModel because it is already linked to another FakeModel"
    return typescript_1.factory.createThrowStatement(typescript_1.factory.createCallExpression(typescript_1.factory.createIdentifier('Error'), undefined, [
        typescript_1.factory.createTemplateExpression(typescript_1.factory.createTemplateHead(`${relatedModelName} `), [
            typescript_1.factory.createTemplateSpan(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier(relatedRecordToLink), typescript_1.factory.createIdentifier(primaryKey)), typescript_1.factory.createTemplateTail(isFieldRequired
                ? ` cannot be unlinked because ${relatedModelName} requires ${modelName}.`
                : ` cannot be linked to ${modelName} because it is already linked to another ${modelName}.`)),
        ]),
    ]));
}
/*
 if (JSON.stringify(imageToUnlink) !== JSON.stringify(imageRecord)) {
        //throwExpression
    }
 */
function wrapThrowInIfStatement({ thisModelRecordToUnlink, currentRecord, throwExpression, }) {
    return typescript_1.factory.createIfStatement(typescript_1.factory.createBinaryExpression(typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier('JSON'), typescript_1.factory.createIdentifier('stringify')), undefined, [typescript_1.factory.createIdentifier(thisModelRecordToUnlink)]), typescript_1.factory.createToken(typescript_1.SyntaxKind.ExclamationEqualsEqualsToken), typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier('JSON'), typescript_1.factory.createIdentifier('stringify')), undefined, [typescript_1.factory.createIdentifier(currentRecord)])), typescript_1.factory.createBlock([throwExpression], true), undefined);
}
function linkModelRecordExpression({ importedRelatedModelName, relatedRecordToLink, fieldBiDirectionalWithName, fieldName, currentRecord, importCollection, primaryKeys, associatedPrimaryKeys, associatedFieldsBiDirectionalWith, dataApi, renderConfigDependencies, }) {
    if (dataApi === 'GraphQL') {
        const inputs = [
            ...associatedPrimaryKeys.map((associatedPrimaryKey) => typescript_1.factory.createPropertyAssignment(typescript_1.factory.createIdentifier(associatedPrimaryKey), typescript_1.factory.createPropertyAccessChain(typescript_1.factory.createIdentifier(fieldName), undefined, associatedPrimaryKey))),
            ...associatedFieldsBiDirectionalWith.map((associatedField, index) => typescript_1.factory.createPropertyAssignment(typescript_1.factory.createIdentifier(associatedField), typescript_1.factory.createPropertyAccessChain(typescript_1.factory.createIdentifier(currentRecord), undefined, primaryKeys[index]))),
        ];
        return typescript_1.factory.createExpressionStatement(typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier('promises'), typescript_1.factory.createIdentifier('push')), undefined, [
            (0, graphql_1.getGraphqlCallExpression)(graphql_1.ActionType.UPDATE, importedRelatedModelName, importCollection, { inputs }, undefined, renderConfigDependencies),
        ]));
    }
    return typescript_1.factory.createExpressionStatement(typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier('promises'), typescript_1.factory.createIdentifier('push')), undefined, [
        typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier('DataStore'), typescript_1.factory.createIdentifier('save')), undefined, [
            typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier(importedRelatedModelName), typescript_1.factory.createIdentifier('copyOf')), undefined, [
                typescript_1.factory.createIdentifier(relatedRecordToLink),
                typescript_1.factory.createArrowFunction(undefined, undefined, [
                    typescript_1.factory.createParameterDeclaration(undefined, undefined, undefined, typescript_1.factory.createIdentifier('updated'), undefined, undefined, undefined),
                ], undefined, typescript_1.factory.createToken(typescript_1.SyntaxKind.EqualsGreaterThanToken), typescript_1.factory.createBlock([
                    typescript_1.factory.createExpressionStatement(typescript_1.factory.createBinaryExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier('updated'), typescript_1.factory.createIdentifier(fieldBiDirectionalWithName)), typescript_1.factory.createToken(typescript_1.SyntaxKind.EqualsToken), typescript_1.factory.createIdentifier(currentRecord))),
                ], true)),
            ]),
        ]),
    ]));
}
function getBiDirectionalRelationshipStatements({ formActionType, dataSchema, importCollection, fieldConfig, modelName, savedRecordName, thisModelPrimaryKeys, dataApi, renderConfigDependencies, }) {
    const getFieldBiDirectionalWithReturnValue = getFieldBiDirectionalWith({
        modelName,
        dataSchema,
        fieldConfig,
    });
    if (!getFieldBiDirectionalWithReturnValue) {
        return [];
    }
    const currentRecord = formActionType === 'update' ? (0, form_state_1.getRecordName)(modelName) : savedRecordName;
    const { relatedModelName, fieldBiDirectionalWithName, associatedFieldsBiDirectionalWith, fieldBiDirectionalWith, fieldBiDirectionalWithPrimaryKeys, } = getFieldBiDirectionalWithReturnValue;
    const [fieldName, { relationship }] = fieldConfig;
    const importedRelatedModelName = importCollection.getMappedModelAlias(relatedModelName);
    const importedThisModelName = importCollection.getMappedModelAlias(modelName);
    // TODO: setting associated fields to `undefined` is a workaround.
    // remove after DataStore addresses issue: https://github.com/aws-amplify/amplify-js/issues/10750
    const associatedFields = ((relationship === null || relationship === void 0 ? void 0 : relationship.type) === 'HAS_ONE' || (relationship === null || relationship === void 0 ? void 0 : relationship.type) === 'BELONGS_TO') && relationship.associatedFields
        ? relationship.associatedFields
        : [];
    const isFieldRequired = dataSchema.models[modelName].fields[fieldName].required;
    const isFieldBiDirectionalWithRequired = fieldBiDirectionalWith.required;
    const statements = [];
    if (formActionType === 'update') {
        const relatedRecordToUnlink = `${(0, helpers_1.lowerCaseFirst)(relatedModelName)}ToUnlink`;
        /**
              const compositeOwnerToUnlink = await compositeDogRecord.CompositeOwner;
              if(compositeOwnerToUnlink) {
               promises.push( DataStore.save(CompositeOwner0.copyOf(compositeOwnerToUnlink, (updated) => {
                  updated.compositeOwnerCompositeDogName = undefined;
                  updated.compositeOwnerCompositeDogDescription = undefined;
                  updated.CompositeDog = undefined;
                })))
              }
             */
        statements.push(...[
            typescript_1.factory.createVariableStatement(undefined, typescript_1.factory.createVariableDeclarationList([
                typescript_1.factory.createVariableDeclaration(typescript_1.factory.createIdentifier(relatedRecordToUnlink), undefined, undefined, typescript_1.factory.createAwaitExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier(currentRecord), typescript_1.factory.createIdentifier(fieldName)))),
            ], typescript_1.NodeFlags.Const)),
            typescript_1.factory.createIfStatement(typescript_1.factory.createIdentifier(relatedRecordToUnlink), typescript_1.factory.createBlock([
                isFieldBiDirectionalWithRequired
                    ? wrapThrowInIfStatement({
                        currentRecord: `modelFields.${fieldName}`,
                        thisModelRecordToUnlink: relatedRecordToUnlink,
                        throwExpression: unlinkModelThrowErrorExpression(relatedModelName, relatedRecordToUnlink, modelName, fieldBiDirectionalWithPrimaryKeys[0], isFieldBiDirectionalWithRequired),
                    })
                    : unlinkModelRecordExpression({
                        modelName: importedRelatedModelName,
                        primaryKeys: thisModelPrimaryKeys,
                        recordNameToUnlink: relatedRecordToUnlink,
                        fieldName: fieldBiDirectionalWithName,
                        associatedFields: associatedFieldsBiDirectionalWith,
                        importCollection,
                        dataApi,
                        renderConfigDependencies,
                    }),
            ], true), undefined),
        ]);
    }
    /** GraphQL:
            const compositeOwnerToLink = modelFields.CompositeOwner;
            if (compositeOwnerToLink) {
              promises.push(API.graphql({
                query: updateCompositeOwner0,
                variables: { input: { ...ownerToLink, Dog: dog }},
              }))
    
              const compositeDogToUnlink = await compositeOwnerToLink.CompositeDog;
              if (compositeDogToUnlink) {
                promises.push(API.graphql({
                  query: updateCompositeDog,
                  variables: { input: {
                    ...compositeDogToUnlink,
                    compositeDogCompositeOwnerLastName: undefined,
                    compositeDogCompositeOwnerFirstName: undefined,
                    CompositeOwner: undefined,
                  }}
                }))
              }
            }
     */
    /** Datatstore:
            const compositeOwnerToLink = modelFields.CompositeOwner;
            if (compositeOwnerToLink) {
              promises.push(DataStore.save(CompositeOwner0.copyOf(compositeOwnerToLink, (updated) => {
                updated.CompositeDog = compositeDogRecord;
              })))
    
              const compositeDogToUnlink = await compositeOwnerToLink.CompositeDog;
              if (compositeDogToUnlink) {
                promises.push(DataStore.save(CompositeDog.copyOf(compositeDogToUnlink, (updated) => {
                  updated.compositeDogCompositeOwnerLastName = undefined;
                  updated.compositeDogCompositeOwnerFirstName = undefined;
                  updated.CompositeOwner = undefined;
                })))
              }
            }
       */
    const relatedRecordToLink = `${(0, helpers_1.lowerCaseFirst)(relatedModelName)}ToLink`;
    const thisModelRecordToUnlink = `${(0, helpers_1.lowerCaseFirst)(modelName)}ToUnlink`;
    statements.push(...[
        typescript_1.factory.createVariableStatement(undefined, typescript_1.factory.createVariableDeclarationList([
            typescript_1.factory.createVariableDeclaration(typescript_1.factory.createIdentifier(relatedRecordToLink), undefined, undefined, typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier('modelFields'), typescript_1.factory.createIdentifier(fieldName))),
        ], typescript_1.NodeFlags.Const)),
        typescript_1.factory.createIfStatement(typescript_1.factory.createIdentifier(relatedRecordToLink), typescript_1.factory.createBlock([
            linkModelRecordExpression({
                importedRelatedModelName,
                relatedRecordToLink,
                fieldBiDirectionalWithName,
                fieldName,
                currentRecord,
                importCollection,
                primaryKeys: thisModelPrimaryKeys,
                associatedPrimaryKeys: fieldBiDirectionalWithPrimaryKeys,
                associatedFieldsBiDirectionalWith,
                dataApi,
                renderConfigDependencies,
            }),
            typescript_1.factory.createVariableStatement(undefined, typescript_1.factory.createVariableDeclarationList([
                typescript_1.factory.createVariableDeclaration(typescript_1.factory.createIdentifier(thisModelRecordToUnlink), undefined, undefined, typescript_1.factory.createAwaitExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier(relatedRecordToLink), typescript_1.factory.createIdentifier(fieldBiDirectionalWithName)))),
            ], typescript_1.NodeFlags.Const)),
            typescript_1.factory.createIfStatement(typescript_1.factory.createIdentifier(thisModelRecordToUnlink), typescript_1.factory.createBlock([
                isFieldRequired
                    ? wrapThrowInIfStatement({
                        thisModelRecordToUnlink,
                        currentRecord,
                        throwExpression: unlinkModelThrowErrorExpression(relatedModelName, relatedRecordToLink, modelName, fieldBiDirectionalWithPrimaryKeys[0], isFieldBiDirectionalWithRequired),
                    })
                    : unlinkModelRecordExpression({
                        modelName: importedThisModelName,
                        primaryKeys: thisModelPrimaryKeys,
                        recordNameToUnlink: thisModelRecordToUnlink,
                        fieldName,
                        associatedFields,
                        importCollection,
                        dataApi,
                        renderConfigDependencies,
                    }),
            ], true), undefined),
        ], true), undefined),
    ]);
    return statements;
}
exports.getBiDirectionalRelationshipStatements = getBiDirectionalRelationshipStatements;
//# sourceMappingURL=bidirectional-relationship.js.map