import { FieldConfigMetadata, DataFieldDataType, StudioForm, StudioFormActionType } from '@aws-amplify/codegen-ui';
import { Statement, Expression, Identifier, ExpressionStatement, ObjectLiteralExpression, CallExpression, PropertyName } from 'typescript';
import { DataApiKind } from '../../react-render-config';
export declare const getArrayChildRefName: (fieldName: string) => string;
export declare const getCurrentValueName: (fieldName: string) => string;
export declare const getCurrentDisplayValueName: (fieldName: string) => string;
export declare const getRecordsName: (name: string, capitalized?: boolean) => string;
export declare const getRecordName: (modelName: string, capitalized?: boolean) => string;
export declare const getLinkedDataName: (modelName: string) => string;
export declare const getCanUnlinkModelName: (modelName: string) => string;
export declare const getCurrentValueIdentifier: (fieldName: string) => Identifier;
export declare const getPropName: (propName: string) => string;
export declare const resetValuesName: Identifier;
export declare const setStateExpression: (fieldName: string, value: Expression) => ExpressionStatement;
/**
 * setErrors((errors) => ({ ...errors, [key]: value }));
 *
 * shorthand function to set error key/value
 * @param key ts expression to use as key ex. string literal or ts identifier
 * @param value ts expression to resolve to the value could be a prop access chain or identifier
 * @returns expression statement
 */
export declare const setErrorState: (key: string | PropertyName, value: Expression) => ExpressionStatement;
/**
 * Note this is not for handling arrays.
 * If you need a default array value (e.g. []). Pass in an empty array at a higher level.
 */
export declare const getDefaultValueExpression: (name: string, componentType: string, dataType?: DataFieldDataType | undefined, isArray?: boolean | undefined, isDisplayValue?: boolean | undefined, defaultValue?: string | null | undefined) => Expression;
export declare const getInitialValues: (fieldConfigs: Record<string, FieldConfigMetadata>, component: StudioForm) => Statement;
/**
 * iterates field configs to create useState hooks for each field
 * @param fieldConfigs
 * @param dataApi
 * @returns
 */
export declare const getUseStateHooks: (fieldConfigs: Record<string, FieldConfigMetadata>, formActionType: StudioFormActionType, dataApi?: DataApiKind | undefined, hasAutoComplete?: boolean | undefined) => Statement[];
export declare const getAutocompleteOptions: (fieldConfigs: Record<string, FieldConfigMetadata>, hasAutoCompleteField: boolean, dataApi?: DataApiKind | undefined) => Statement[];
/**
 * function used by the Clear/ Reset button
 * it's a reset type but we also need to clear the state of the input fields as well
 *
 * ex.
 * const resetStateValues = () => {
 *  setName(initialValues.name)
 *  setLastName(initialValues.lastName)
 *   ....
 * };
 */
export declare const resetStateFunction: (fieldConfigs: Record<string, FieldConfigMetadata>, recordName?: string | undefined) => import("typescript").VariableStatement;
/**
 * turns ['myNestedObject', 'value', 'nestedValue', 'leaf']
 *
 * into myNestedObject?.value?.nestedValue?.leaf
 *
 * @param values
 * @returns
 */
export declare const buildAccessChain: (values: string[], isOptional?: boolean) => Expression;
export declare const buildNestedStateSet: (keyPath: string[], currentKeyPath: string[], value: Expression, index?: number) => ObjectLiteralExpression;
export declare const setFieldState: (name: string, value: Expression) => CallExpression;
export declare const buildSetStateFunction: (fieldConfigs: Record<string, FieldConfigMetadata>) => import("typescript").IfStatement;
export declare const buildResetValuesOnRecordUpdate: (recordName: string, linkedDataNames: string[]) => ExpressionStatement;
