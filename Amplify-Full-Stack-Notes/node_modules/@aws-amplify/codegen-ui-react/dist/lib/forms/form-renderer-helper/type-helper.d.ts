import { FieldConfigMetadata, DataFieldDataType, StudioForm, StudioComponent, FormDefinition } from '@aws-amplify/codegen-ui';
import { KeywordTypeSyntaxKind, PropertySignature } from 'typescript';
import { ImportCollection } from '../../imports';
import { ReactRenderConfig } from '../../react-render-config';
declare type Node<T> = {
    [n: string]: T | Node<T>;
};
declare type GetTypeNodeParam = {
    componentType: string;
    dataType?: DataFieldDataType;
    isArray: boolean;
    isValidation: boolean;
    importCollection?: ImportCollection;
    renderConfig?: ReactRenderConfig;
};
export declare const getInputValuesTypeName: (formName: string) => string;
export declare const getValidationTypeName: (formName: string) => string;
/**
 * given the nested json paths rejoin them into one object
 * where the leafs are the types ex. string | number | boolean
 * src: https://stackoverflow.com/questions/70218560/creating-a-nested-object-from-entries
 *
 * @param object
 * @param [key, value] entry/tuple object shape created from key and value is set at the leaf
 */
export declare const generateObjectFromPaths: (object: Node<KeywordTypeSyntaxKind>, [key, value]: [fieldName: string, getTypeNodeParam: GetTypeNodeParam]) => Node<KeywordTypeSyntaxKind>;
export declare const generateTypeNodeFromObject: (obj: Node<KeywordTypeSyntaxKind>) => PropertySignature[];
/**
 * this generates the input types for onSubmit, onSuccess, onChange, and onValidate
 * onValidate is the one case where it passes true to get the ValidationType
 * instead of the base type
 *
 * validation type is selected
 * export declare type NestedJsonValidationValues = {
    "first-Name"?: ValidationFunction<string>;
    lastName?: ValidationFunction<string>;
    Nicknames1?: ValidationFunction<string>;
    "nick-names2"?: ValidationFunction<string>;
    "first Name"?: ValidationFunction<string>;
    bio?: {
        "favorite Quote"?: ValidationFunction<string>;
        "favorite-Animal"?: ValidationFunction<string>;
    };
 * };
 * if its regular validation then it will be using the main types of the object array types are allowed in this case
 *
 * @param formName
 * @param {('input' | 'validation')}
 * @param fieldConfigs
 * @returns
 */
export declare const generateFieldTypes: (formName: string, type: 'input' | 'validation', fieldConfigs: Record<string, FieldConfigMetadata>, importCollection?: ImportCollection | undefined, renderConfig?: {
    script?: import("typescript").ScriptKind | undefined;
    target?: import("typescript").ScriptTarget | undefined;
    module?: import("typescript").ModuleKind | undefined;
    renderTypeDeclarations?: boolean | undefined;
    inlineSourceMap?: boolean | undefined;
    apiConfiguration?: import("../../react-render-config").GraphqlRenderConfig | import("../../react-render-config").DataStoreRenderConfig | import("../../react-render-config").NoApiRenderConfig | undefined;
    dependencies?: {
        [key: string]: string;
    } | undefined;
    includeUseClientDirective?: boolean | undefined;
} | undefined) => import("typescript").TypeAliasDeclaration;
/**
 * export declare type ValidationResponse = {
 *  hasError: boolean;
 *  errorMessage?: string;
 * };
 */
export declare const validationResponseType: import("typescript").TypeAliasDeclaration;
/**
 * export declare type ValidationFunction<T> =
 *  (value: T, validationResponse: ValidationResponse) => ValidationResponse | Promise<ValidationResponse>;
 */
export declare const validationFunctionType: import("typescript").TypeAliasDeclaration;
export declare const buildFormPropNode: (form: StudioForm, fieldConfigs: Record<string, FieldConfigMetadata>, modelName?: string | undefined, primaryKeys?: string[]) => import("typescript").TypeLiteralNode;
export declare const buildOverrideTypesBindings: (formComponent: StudioComponent, formDefinition: FormDefinition, importCollection: ImportCollection) => import("typescript").TypeAliasDeclaration;
export {};
