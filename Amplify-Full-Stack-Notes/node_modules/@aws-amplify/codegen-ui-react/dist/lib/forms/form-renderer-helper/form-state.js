"use strict";
/*
  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.

  Licensed under the Apache License, Version 2.0 (the "License").
  You may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildResetValuesOnRecordUpdate = exports.buildSetStateFunction = exports.setFieldState = exports.buildNestedStateSet = exports.buildAccessChain = exports.resetStateFunction = exports.getAutocompleteOptions = exports.getUseStateHooks = exports.getInitialValues = exports.getDefaultValueExpression = exports.setErrorState = exports.setStateExpression = exports.resetValuesName = exports.getPropName = exports.getCurrentValueIdentifier = exports.getCanUnlinkModelName = exports.getLinkedDataName = exports.getRecordName = exports.getRecordsName = exports.getCurrentDisplayValueName = exports.getCurrentValueName = exports.getArrayChildRefName = void 0;
const codegen_ui_1 = require("@aws-amplify/codegen-ui");
const typescript_1 = require("typescript");
const helpers_1 = require("../../helpers");
const invalid_variable_helpers_1 = require("./invalid-variable-helpers");
const render_checkers_1 = require("./render-checkers");
// used just to sanitize nested array field names
// when rendering currentValue state and ref
const getVariableName = (input) => input.length > 1 ? input.join('').replace(/[^a-zA-Z0-9_$]/g, '') : input.join('');
const getArrayChildRefName = (fieldName) => {
    const paths = fieldName.split('.').map((path, i) => (i === 0 ? path : (0, helpers_1.capitalizeFirstLetter)(path)));
    return `${getVariableName(paths)}Ref`;
};
exports.getArrayChildRefName = getArrayChildRefName;
// value of the child of an ArrayField
const getCurrentValueName = (fieldName) => {
    const paths = fieldName.split('.').map((path) => (0, helpers_1.capitalizeFirstLetter)(path));
    return `current${getVariableName(paths)}Value`;
};
exports.getCurrentValueName = getCurrentValueName;
const getCurrentDisplayValueName = (fieldName) => `current${(0, helpers_1.capitalizeFirstLetter)(fieldName)}DisplayValue`;
exports.getCurrentDisplayValueName = getCurrentDisplayValueName;
const getRecordsName = (name, capitalized = false) => `${(capitalized ? helpers_1.capitalizeFirstLetter : helpers_1.lowerCaseFirst)(name)}Records`;
exports.getRecordsName = getRecordsName;
const getRecordName = (modelName, capitalized = false) => `${(capitalized ? helpers_1.capitalizeFirstLetter : helpers_1.lowerCaseFirst)(modelName)}Record`;
exports.getRecordName = getRecordName;
const getLinkedDataName = (modelName) => `linked${(0, helpers_1.capitalizeFirstLetter)(modelName)}`;
exports.getLinkedDataName = getLinkedDataName;
const getCanUnlinkModelName = (modelName) => `canUnlink${(0, helpers_1.capitalizeFirstLetter)(modelName)}`;
exports.getCanUnlinkModelName = getCanUnlinkModelName;
const getCurrentValueIdentifier = (fieldName) => typescript_1.factory.createIdentifier((0, exports.getCurrentValueName)(fieldName));
exports.getCurrentValueIdentifier = getCurrentValueIdentifier;
// in update form, there will be conflict if field `id` is editable.
// so the prop `id` should be destructured as `idProp`
const getPropName = (propName) => `${propName}Prop`;
exports.getPropName = getPropName;
exports.resetValuesName = typescript_1.factory.createIdentifier('resetStateValues');
const setStateExpression = (fieldName, value) => {
    return typescript_1.factory.createExpressionStatement(typescript_1.factory.createCallExpression((0, helpers_1.getSetNameIdentifier)(fieldName), undefined, [value]));
};
exports.setStateExpression = setStateExpression;
/**
 * setErrors((errors) => ({ ...errors, [key]: value }));
 *
 * shorthand function to set error key/value
 * @param key ts expression to use as key ex. string literal or ts identifier
 * @param value ts expression to resolve to the value could be a prop access chain or identifier
 * @returns expression statement
 */
const setErrorState = (key, value) => {
    return typescript_1.factory.createExpressionStatement(typescript_1.factory.createCallExpression(typescript_1.factory.createIdentifier('setErrors'), undefined, [
        typescript_1.factory.createArrowFunction(undefined, undefined, [
            typescript_1.factory.createParameterDeclaration(undefined, undefined, undefined, typescript_1.factory.createIdentifier('errors'), undefined, undefined, undefined),
        ], undefined, typescript_1.factory.createToken(typescript_1.SyntaxKind.EqualsGreaterThanToken), typescript_1.factory.createParenthesizedExpression(typescript_1.factory.createObjectLiteralExpression([
            typescript_1.factory.createSpreadAssignment(typescript_1.factory.createIdentifier('errors')),
            typescript_1.factory.createPropertyAssignment(key, value),
        ], false))),
    ]));
};
exports.setErrorState = setErrorState;
/**
 * Note this is not for handling arrays.
 * If you need a default array value (e.g. []). Pass in an empty array at a higher level.
 */
const getDefaultValueExpression = (name, componentType, dataType, isArray, isDisplayValue, defaultValue) => {
    const componentTypeToDefaultValueMap = {
        Autocomplete: isDisplayValue ? typescript_1.factory.createStringLiteral('') : typescript_1.factory.createIdentifier('undefined'),
        ToggleButton: typescript_1.factory.createFalse(),
        SwitchField: typescript_1.factory.createFalse(),
        StepperField: typescript_1.factory.createNumericLiteral(0),
        SliderField: typescript_1.factory.createNumericLiteral(0),
        CheckboxField: typescript_1.factory.createFalse(),
        TextField: typescript_1.factory.createStringLiteral(''),
        TextAreaField: typescript_1.factory.createStringLiteral(''),
        SelectField: typescript_1.factory.createStringLiteral(''),
    };
    if (defaultValue) {
        return isArray
            ? typescript_1.factory.createArrayLiteralExpression([typescript_1.factory.createStringLiteral(defaultValue)], false)
            : typescript_1.factory.createStringLiteral(defaultValue);
    }
    if (isArray) {
        return typescript_1.factory.createArrayLiteralExpression([], false);
    }
    if (componentType in componentTypeToDefaultValueMap) {
        return componentTypeToDefaultValueMap[componentType];
    }
    return typescript_1.factory.createIdentifier('undefined');
};
exports.getDefaultValueExpression = getDefaultValueExpression;
/* ex. const initialValues = {
  name: undefined,
  isChecked: false
}
*/
const getInitialValues = (fieldConfigs, component) => {
    const stateNames = new Set();
    const propertyAssignments = Object.entries(fieldConfigs).reduce((acc, [name, { dataType, componentType, isArray }]) => {
        const isNested = name.includes('.');
        // we are only setting top-level keys
        const stateName = name.split('.')[0];
        const defaultValue = (0, helpers_1.getControlledComponentDefaultValue)(component.fields, componentType, name);
        let initialValue = (0, exports.getDefaultValueExpression)(name, componentType, dataType, isArray, false, defaultValue);
        if (isNested) {
            // if nested, just set up an empty object for the top-level key
            initialValue = typescript_1.factory.createObjectLiteralExpression();
        }
        if (!stateNames.has(stateName)) {
            acc.push(typescript_1.factory.createPropertyAssignment((0, codegen_ui_1.isValidVariableName)(stateName)
                ? typescript_1.factory.createIdentifier(stateName)
                : typescript_1.factory.createStringLiteral(stateName), initialValue));
            stateNames.add(stateName);
        }
        return acc;
    }, []);
    return typescript_1.factory.createVariableStatement(undefined, typescript_1.factory.createVariableDeclarationList([
        typescript_1.factory.createVariableDeclaration(typescript_1.factory.createIdentifier('initialValues'), undefined, undefined, typescript_1.factory.createObjectLiteralExpression(propertyAssignments, true)),
    ], typescript_1.NodeFlags.Const));
};
exports.getInitialValues = getInitialValues;
/**
 * iterates field configs to create useState hooks for each field
 * @param fieldConfigs
 * @param dataApi
 * @returns
 */
const getUseStateHooks = (fieldConfigs, formActionType, dataApi, hasAutoComplete) => {
    const stateNames = new Set();
    return Object.entries(fieldConfigs).reduce((acc, fieldConfig) => {
        const [name, { sanitizedFieldName, relationship }] = fieldConfig;
        const fieldName = name.split('.')[0];
        const renderedFieldName = sanitizedFieldName || fieldName;
        function determinePropertyName() {
            return (0, codegen_ui_1.isValidVariableName)(fieldName)
                ? typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier('initialValues'), typescript_1.factory.createIdentifier(fieldName))
                : typescript_1.factory.createElementAccessExpression(typescript_1.factory.createIdentifier('initialValues'), typescript_1.factory.createStringLiteral(fieldName));
        }
        function renderCorrectUseStateValue() {
            return determinePropertyName();
        }
        if (!stateNames.has(renderedFieldName)) {
            acc.push((0, helpers_1.buildUseStateExpression)(renderedFieldName, renderCorrectUseStateValue()));
            stateNames.add(renderedFieldName);
        }
        if (dataApi === 'GraphQL' && relationship) {
            acc.push((0, helpers_1.buildUseStateExpression)(`${renderedFieldName}Loading`, typescript_1.factory.createFalse()));
            acc.push((0, helpers_1.buildUseStateExpression)((0, exports.getRecordsName)(renderedFieldName), typescript_1.factory.createArrayLiteralExpression([], false)));
            if (hasAutoComplete && !(0, render_checkers_1.isModelDataType)(fieldConfig[1])) {
                acc.push((0, helpers_1.buildUseStateExpression)(`selected${(0, helpers_1.capitalizeFirstLetter)(renderedFieldName)}Records`, typescript_1.factory.createArrayLiteralExpression([], false)));
            }
        }
        return acc;
    }, []);
};
exports.getUseStateHooks = getUseStateHooks;
const getAutocompleteOptions = (fieldConfigs, hasAutoCompleteField, dataApi) => {
    if (dataApi === 'GraphQL' &&
        hasAutoCompleteField &&
        Object.values(fieldConfigs).some(({ relationship }) => !!relationship)) {
        return [(0, helpers_1.buildInitConstVariableExpression)('autocompleteLength', typescript_1.factory.createNumericLiteral('10'))];
    }
    return [];
};
exports.getAutocompleteOptions = getAutocompleteOptions;
/**
 * function used by the Clear/ Reset button
 * it's a reset type but we also need to clear the state of the input fields as well
 *
 * ex.
 * const resetStateValues = () => {
 *  setName(initialValues.name)
 *  setLastName(initialValues.lastName)
 *   ....
 * };
 */
const resetStateFunction = (fieldConfigs, recordName) => {
    const recordOrInitialValues = recordName ? 'cleanValues' : 'initialValues';
    const stateNames = new Set();
    const expressions = Object.entries(fieldConfigs).reduce((acc, [name, fieldConfig]) => {
        const { isArray, sanitizedFieldName, componentType, dataType } = fieldConfig;
        const stateName = name.split('.')[0];
        const renderedName = sanitizedFieldName || stateName;
        if (!stateNames.has(stateName)) {
            const accessExpression = (0, invalid_variable_helpers_1.getElementAccessExpression)(recordOrInitialValues, stateName);
            const isNonModelField = (0, codegen_ui_1.isNonModelDataType)(dataType);
            // Initial values should have the correct values and not need a modifier
            if ((dataType === 'AWSJSON' || isNonModelField) && !isArray && recordOrInitialValues !== 'initialValues') {
                const awsJSONAccessModifier = stringifyAWSJSONFieldValue(accessExpression);
                acc.push((0, exports.setStateExpression)(renderedName, awsJSONAccessModifier));
            }
            else {
                const stringifiedOrAccessExpression = isNonModelField
                    ? stringifyAWSJSONFieldArrayValues(accessExpression)
                    : accessExpression;
                acc.push((0, exports.setStateExpression)(renderedName, isArray && recordOrInitialValues === 'cleanValues'
                    ? typescript_1.factory.createBinaryExpression(stringifiedOrAccessExpression, typescript_1.factory.createToken(typescript_1.SyntaxKind.QuestionQuestionToken), typescript_1.factory.createArrayLiteralExpression([], false))
                    : accessExpression));
            }
            // We don't need to reset the current array value if it's nested
            // because we're already clearing out the entire nested value
            // adding this on a nested value will add a setState function
            // that was never created to begin with
            if ((0, render_checkers_1.shouldWrapInArrayField)(fieldConfig) && !name.includes('.')) {
                acc.push((0, exports.setStateExpression)((0, exports.getCurrentValueName)(renderedName), (0, exports.getDefaultValueExpression)(name, componentType, dataType)));
            }
            if (fieldConfig.relationship) {
                acc.push((0, exports.setStateExpression)((0, exports.getCurrentDisplayValueName)(renderedName), (0, exports.getDefaultValueExpression)(name, componentType, dataType, false, true)));
                stateNames.add(stateName);
            }
            stateNames.add(stateName);
        }
        return acc;
    }, []);
    const linkedDataPropertyAssignments = [];
    if (fieldConfigs) {
        Object.entries(fieldConfigs).forEach(([fieldName, fieldConfig]) => {
            var _a, _b, _c;
            if (((_a = fieldConfig.relationship) === null || _a === void 0 ? void 0 : _a.type) === 'HAS_MANY') {
                linkedDataPropertyAssignments.push(typescript_1.factory.createPropertyAssignment(typescript_1.factory.createIdentifier(fieldConfig.sanitizedFieldName || fieldName), typescript_1.factory.createIdentifier((0, exports.getLinkedDataName)(fieldName))));
            }
            else if (((_b = fieldConfig.relationship) === null || _b === void 0 ? void 0 : _b.type) === 'BELONGS_TO' || ((_c = fieldConfig.relationship) === null || _c === void 0 ? void 0 : _c.type) === 'HAS_ONE') {
                linkedDataPropertyAssignments.push(typescript_1.factory.createIdentifier(fieldConfig.sanitizedFieldName || fieldName));
            }
        });
    }
    // ex. const cleanValues = {...initialValues, ...bookRecord}
    if (recordName) {
        expressions.unshift(typescript_1.factory.createVariableStatement(undefined, typescript_1.factory.createVariableDeclarationList([
            typescript_1.factory.createVariableDeclaration(typescript_1.factory.createIdentifier('cleanValues'), undefined, undefined, typescript_1.factory.createConditionalExpression(typescript_1.factory.createIdentifier(recordName), typescript_1.factory.createToken(typescript_1.SyntaxKind.QuestionToken), typescript_1.factory.createObjectLiteralExpression([
                typescript_1.factory.createSpreadAssignment(typescript_1.factory.createIdentifier('initialValues')),
                typescript_1.factory.createSpreadAssignment(typescript_1.factory.createIdentifier(recordName)),
                ...linkedDataPropertyAssignments,
            ], false), typescript_1.factory.createToken(typescript_1.SyntaxKind.ColonToken), typescript_1.factory.createIdentifier('initialValues'))),
        ], typescript_1.NodeFlags.Const)));
    }
    // also reset the state of the errors
    expressions.push((0, exports.setStateExpression)('errors', typescript_1.factory.createObjectLiteralExpression()));
    return typescript_1.factory.createVariableStatement(undefined, typescript_1.factory.createVariableDeclarationList([
        typescript_1.factory.createVariableDeclaration(exports.resetValuesName, undefined, undefined, typescript_1.factory.createArrowFunction(undefined, undefined, [], undefined, typescript_1.factory.createToken(typescript_1.SyntaxKind.EqualsGreaterThanToken), typescript_1.factory.createBlock(expressions, true))),
    ], typescript_1.NodeFlags.Const));
};
exports.resetStateFunction = resetStateFunction;
/**
 * Datastore allows JSON strings and normal JSON so check for a string
 * before stringifying or else the string will return with escaped quotes.
 * Also do not stringify null.
 *
 * Example output:
 * typeof cleanValues.metadata === 'string' || cleanValues.metadata === null ?
 * cleanValues.metadata : JSON.stringify(cleanValues.metadata)
 */
const stringifyAWSJSONFieldValue = (value) => {
    return typescript_1.factory.createConditionalExpression(typescript_1.factory.createBinaryExpression(typescript_1.factory.createBinaryExpression(typescript_1.factory.createTypeOfExpression(value), typescript_1.factory.createToken(typescript_1.SyntaxKind.EqualsEqualsEqualsToken), typescript_1.factory.createStringLiteral('string')), typescript_1.factory.createToken(typescript_1.SyntaxKind.BarBarToken), typescript_1.factory.createBinaryExpression(value, typescript_1.factory.createToken(typescript_1.SyntaxKind.EqualsEqualsEqualsToken), typescript_1.factory.createNull())), typescript_1.factory.createToken(typescript_1.SyntaxKind.QuestionToken), value, typescript_1.factory.createToken(typescript_1.SyntaxKind.ColonToken), typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier('JSON'), typescript_1.factory.createIdentifier('stringify')), undefined, [value]));
};
/**
 * Datastore allows JSON strings and normal JSON so make sure items in array are string type
 *
 * Example output:
 * cleanValues.nonModelFieldArray?.map(item => typeof item === "string" ? item : JSON.stringify(item))
 */
const stringifyAWSJSONFieldArrayValues = (value) => {
    return typescript_1.factory.createCallChain(typescript_1.factory.createPropertyAccessChain(value, typescript_1.factory.createToken(typescript_1.SyntaxKind.QuestionDotToken), typescript_1.factory.createIdentifier('map')), undefined, undefined, [
        typescript_1.factory.createArrowFunction(undefined, undefined, [
            typescript_1.factory.createParameterDeclaration(undefined, undefined, undefined, typescript_1.factory.createIdentifier('item'), undefined, undefined, undefined),
        ], undefined, typescript_1.factory.createToken(typescript_1.SyntaxKind.EqualsGreaterThanToken), typescript_1.factory.createConditionalExpression(typescript_1.factory.createBinaryExpression(typescript_1.factory.createTypeOfExpression(typescript_1.factory.createIdentifier('item')), typescript_1.factory.createToken(typescript_1.SyntaxKind.EqualsEqualsEqualsToken), typescript_1.factory.createStringLiteral('string')), typescript_1.factory.createToken(typescript_1.SyntaxKind.QuestionToken), typescript_1.factory.createIdentifier('item'), typescript_1.factory.createToken(typescript_1.SyntaxKind.ColonToken), typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier('JSON'), typescript_1.factory.createIdentifier('stringify')), undefined, [typescript_1.factory.createIdentifier('item')]))),
    ]);
};
/**
 * turns ['myNestedObject', 'value', 'nestedValue', 'leaf']
 *
 * into myNestedObject?.value?.nestedValue?.leaf
 *
 * @param values
 * @returns
 */
const buildAccessChain = (values, isOptional = true) => {
    if (values.length <= 0) {
        throw new Error('Need at least one value in the values array');
    }
    const optional = isOptional ? typescript_1.factory.createToken(typescript_1.SyntaxKind.QuestionDotToken) : undefined;
    if (values.length > 1) {
        const [parent, child, ...rest] = values;
        let propChain = typescript_1.factory.createPropertyAccessChain(typescript_1.factory.createIdentifier(parent), optional, typescript_1.factory.createIdentifier(child));
        if (!(0, codegen_ui_1.isValidVariableName)(child)) {
            propChain = typescript_1.factory.createElementAccessChain(typescript_1.factory.createIdentifier(parent), optional, typescript_1.factory.createStringLiteral(child));
        }
        if (rest.length) {
            rest.forEach((value) => {
                if ((0, codegen_ui_1.isValidVariableName)(value)) {
                    propChain = typescript_1.factory.createPropertyAccessChain(propChain, optional, typescript_1.factory.createIdentifier(value));
                }
                else {
                    propChain = typescript_1.factory.createElementAccessChain(propChain, optional, typescript_1.factory.createStringLiteral(value));
                }
            });
        }
        return propChain;
    }
    return typescript_1.factory.createIdentifier(values[0]);
};
exports.buildAccessChain = buildAccessChain;
const buildNestedStateSet = (keyPath, currentKeyPath, value, index = 1) => {
    if (keyPath.length <= 1) {
        throw new Error('keyPath needs a length larger than 1 to build nested state object');
    }
    const currentKey = keyPath[index];
    // the value of the index is what decides if we have reached the leaf property of the nested object
    if (keyPath.length - 1 === index) {
        return typescript_1.factory.createObjectLiteralExpression([
            typescript_1.factory.createSpreadAssignment((0, exports.buildAccessChain)(currentKeyPath)),
            typescript_1.factory.createPropertyAssignment((0, codegen_ui_1.isValidVariableName)(currentKey)
                ? typescript_1.factory.createIdentifier(currentKey)
                : typescript_1.factory.createComputedPropertyName(typescript_1.factory.createStringLiteral(currentKey)), value),
        ]);
    }
    const currentSpreadAssignment = (0, exports.buildAccessChain)(currentKeyPath);
    currentKeyPath.push(currentKey);
    return typescript_1.factory.createObjectLiteralExpression([
        typescript_1.factory.createSpreadAssignment(currentSpreadAssignment),
        typescript_1.factory.createPropertyAssignment(typescript_1.factory.createIdentifier(currentKey), (0, exports.buildNestedStateSet)(keyPath, currentKeyPath, value, index + 1)),
    ]);
};
exports.buildNestedStateSet = buildNestedStateSet;
// updating state
const setFieldState = (name, value) => {
    if (name.split('.').length > 1) {
        const keyPath = name.split('.');
        return typescript_1.factory.createCallExpression((0, helpers_1.getSetNameIdentifier)(keyPath[0]), undefined, [
            (0, exports.buildNestedStateSet)(keyPath, [keyPath[0]], value),
        ]);
    }
    return typescript_1.factory.createCallExpression((0, helpers_1.getSetNameIdentifier)(name), undefined, [value]);
};
exports.setFieldState = setFieldState;
const buildSetStateFunction = (fieldConfigs) => {
    const fieldSet = new Set();
    const expression = Object.keys(fieldConfigs).reduce((acc, field) => {
        const fieldName = field.split('.')[0];
        const renderedFieldName = fieldConfigs[field].sanitizedFieldName || fieldName;
        if (!fieldSet.has(renderedFieldName)) {
            acc.push(typescript_1.factory.createExpressionStatement(typescript_1.factory.createCallExpression(typescript_1.factory.createIdentifier(`set${(0, helpers_1.capitalizeFirstLetter)(renderedFieldName)}`), undefined, [
                (0, codegen_ui_1.isValidVariableName)(fieldName)
                    ? typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier('initialData'), typescript_1.factory.createIdentifier(fieldName))
                    : typescript_1.factory.createElementAccessExpression(typescript_1.factory.createIdentifier('initialData'), typescript_1.factory.createStringLiteral(fieldName)),
            ])));
            fieldSet.add(renderedFieldName);
        }
        return acc;
    }, []);
    return typescript_1.factory.createIfStatement(typescript_1.factory.createIdentifier('initialData'), typescript_1.factory.createBlock(expression, true));
};
exports.buildSetStateFunction = buildSetStateFunction;
// ex. React.useEffect(resetStateValues, [bookRecord])
const buildResetValuesOnRecordUpdate = (recordName, linkedDataNames) => {
    const linkedDataIdentifiers = [];
    linkedDataNames.forEach((linkedDataName) => {
        linkedDataIdentifiers.push(typescript_1.factory.createIdentifier(linkedDataName));
    });
    return typescript_1.factory.createExpressionStatement(typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier('React'), typescript_1.factory.createIdentifier('useEffect')), undefined, [
        exports.resetValuesName,
        typescript_1.factory.createArrayLiteralExpression([typescript_1.factory.createIdentifier(recordName), ...linkedDataIdentifiers], false),
    ]));
};
exports.buildResetValuesOnRecordUpdate = buildResetValuesOnRecordUpdate;
//# sourceMappingURL=form-state.js.map