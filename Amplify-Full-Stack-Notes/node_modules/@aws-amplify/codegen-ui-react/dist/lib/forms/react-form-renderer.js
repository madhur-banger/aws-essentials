"use strict";
/*
  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.

  Licensed under the Apache License, Version 2.0 (the "License").
  You may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReactFormTemplateRenderer = void 0;
const codegen_ui_1 = require("@aws-amplify/codegen-ui");
const os_1 = require("os");
const typescript_1 = require("typescript");
const helpers_1 = require("../helpers");
const imports_1 = require("../imports");
const primitive_1 = require("../primitive");
const react_component_render_helper_1 = require("../react-component-render-helper");
const react_output_manager_1 = require("../react-output-manager");
const react_render_config_1 = require("../react-render-config");
const react_studio_template_renderer_helper_1 = require("../react-studio-template-renderer-helper");
const array_field_component_1 = require("../utils/forms/array-field-component");
const layout_helpers_1 = require("../utils/forms/layout-helpers");
const value_mappers_1 = require("../utils/forms/value-mappers");
const generate_react_hooks_1 = require("../utils/generate-react-hooks");
const form_renderer_helper_1 = require("./form-renderer-helper");
const form_state_1 = require("./form-renderer-helper/form-state");
const render_checkers_1 = require("./form-renderer-helper/render-checkers");
const type_helper_1 = require("./form-renderer-helper/type-helper");
const model_values_1 = require("./form-renderer-helper/model-values");
const constants_1 = require("../utils/constants");
const graphql_1 = require("../utils/graphql");
const amplify_js_versioning_1 = require("../helpers/amplify-js-versioning");
const utils_file_functions_1 = require("../utils-file-functions");
class ReactFormTemplateRenderer extends codegen_ui_1.StudioTemplateRenderer {
    constructor(component, dataSchema, renderConfig, featureFlags) {
        var _a;
        super(component, new react_output_manager_1.ReactOutputManager(), renderConfig);
        this.requiredDataModels = [];
        this.shouldRenderArrayField = false;
        this.renderConfig = {
            ...react_studio_template_renderer_helper_1.defaultRenderConfig,
            ...renderConfig,
        };
        // the super class creates a component aka form which is what we pass in this extended implmentation
        this.fileName = `${this.component.name}.${(0, react_render_config_1.scriptKindToFileExtension)(this.renderConfig.script)}`;
        this.formDefinition = (0, codegen_ui_1.generateFormDefinition)({ form: component, dataSchema, featureFlags });
        // create a studio component which will represent the structure of the form
        this.formComponent = (0, codegen_ui_1.mapFormDefinitionToComponent)(this.component.name, this.formDefinition);
        this.componentMetadata = (0, codegen_ui_1.computeComponentMetadata)(this.formComponent);
        this.componentMetadata.formMetadata = (0, codegen_ui_1.mapFormMetadata)(this.component, this.formDefinition);
        this.importCollection = new imports_1.ImportCollection({ rendererConfig: renderConfig });
        this.importCollection.ingestComponentMetadata(this.componentMetadata);
        if (dataSchema) {
            const dataSchemaMetadata = dataSchema;
            this.componentMetadata.dataSchemaMetadata = dataSchemaMetadata;
            const { dataSourceType, dataTypeName } = this.component.dataType;
            if (dataSourceType === 'DataStore') {
                this.primaryKeys = dataSchemaMetadata.models[dataTypeName].primaryKeys;
            }
        }
        // validate inputs for renderer
        if ((0, codegen_ui_1.formRequiresDataApi)(component) && ((_a = renderConfig.apiConfiguration) === null || _a === void 0 ? void 0 : _a.dataApi) === 'NoApi') {
            throw new codegen_ui_1.NoApiError('Form cannot be rendered without a data API');
        }
    }
    renderComponentOnly() {
        const variableStatements = this.buildVariableStatements();
        const jsx = this.renderJsx(this.formComponent);
        const { printer, file } = (0, react_studio_template_renderer_helper_1.buildPrinter)(this.fileName, this.renderConfig);
        const imports = this.importCollection.buildImportStatements();
        let importsText = '';
        imports.forEach((importStatement) => {
            const result = printer.printNode(typescript_1.EmitHint.Unspecified, importStatement, file);
            importsText += result + os_1.EOL;
        });
        const wrappedFunction = this.renderFunctionWrapper(this.component.name, variableStatements, jsx, false);
        let result = printer.printNode(typescript_1.EmitHint.Unspecified, wrappedFunction, file);
        if (this.shouldRenderArrayField) {
            const arrayFieldText = printer.printNode(typescript_1.EmitHint.Unspecified, (0, array_field_component_1.generateArrayFieldComponent)(), file);
            result = arrayFieldText + os_1.EOL + result;
        }
        // do not produce declaration becuase it is not used
        const { componentText: compText } = (0, react_studio_template_renderer_helper_1.transpile)(result, { ...this.renderConfig, renderTypeDeclarations: false });
        return {
            compText,
            importsText,
            requiredDataModels: this.requiredDataModels,
            importCollection: this.importCollection,
        };
    }
    renderComponentInternal() {
        const { printer, file } = (0, react_studio_template_renderer_helper_1.buildPrinter)(this.fileName, this.renderConfig);
        const propsDeclaration = this.renderBindingPropsType();
        // build form related variable statments
        const variableStatements = this.buildVariableStatements();
        const jsx = this.renderJsx(this.formComponent);
        const wrappedFunction = this.renderFunctionWrapper(this.component.name, variableStatements, jsx, true);
        const imports = this.importCollection.buildImportStatements();
        let componentText = `/* eslint-disable */${os_1.EOL}`;
        if (this.renderConfig.includeUseClientDirective) {
            componentText += `'use client';${os_1.EOL}`;
        }
        imports.forEach((importStatement) => {
            const result = printer.printNode(typescript_1.EmitHint.Unspecified, importStatement, file);
            componentText += result + os_1.EOL;
        });
        componentText += os_1.EOL;
        componentText += utils_file_functions_1.overrideTypesString + os_1.EOL;
        propsDeclaration.forEach((typeNode) => {
            const propsPrinted = printer.printNode(typescript_1.EmitHint.Unspecified, typeNode, file);
            componentText += propsPrinted;
        });
        // Amplify JS V6 api
        // const client = generateClient();
        if ((0, graphql_1.isGraphqlConfig)(this.renderConfig.apiConfiguration) &&
            this.importCollection.hasPackage(imports_1.ImportSource.AMPLIFY_API) &&
            (0, amplify_js_versioning_1.getAmplifyJSVersionToRender)(this.renderConfig.dependencies) === constants_1.AMPLIFY_JS_V6) {
            const result = printer.printNode(typescript_1.EmitHint.Unspecified, (0, react_studio_template_renderer_helper_1.getAmplifyJSClientGenerator)(), file);
            componentText += result + os_1.EOL;
        }
        if (this.shouldRenderArrayField) {
            const arrayFieldComponent = printer.printNode(typescript_1.EmitHint.Unspecified, (0, array_field_component_1.generateArrayFieldComponent)(), file);
            componentText += arrayFieldComponent;
        }
        const result = printer.printNode(typescript_1.EmitHint.Unspecified, wrappedFunction, file);
        componentText += result;
        const { componentText: transpiledComponentText, declaration } = (0, react_studio_template_renderer_helper_1.transpile)(componentText, this.renderConfig);
        return {
            componentText: transpiledComponentText,
            declaration,
            formMetadata: this.componentMetadata.formMetadata,
            renderComponentToFilesystem: async (outputPath) => {
                await this.renderComponentToFilesystem(transpiledComponentText)(this.fileName)(outputPath);
                if (declaration) {
                    await this.renderComponentToFilesystem(declaration)((0, react_studio_template_renderer_helper_1.getDeclarationFilename)(this.fileName))(outputPath);
                }
            },
        };
    }
    renderFunctionWrapper(componentName, variableStatements, jsx, renderExport) {
        var _a;
        const componentPropType = (0, react_component_render_helper_1.getComponentPropName)(componentName);
        const jsxStatement = typescript_1.factory.createReturnStatement(typescript_1.factory.createParenthesizedExpression(this.renderConfig.script !== typescript_1.ScriptKind.TSX
            ? jsx
            : /* add ts-ignore comment above jsx statement. Generated props are incompatible with amplify-ui props */
                (0, typescript_1.addSyntheticLeadingComment)(typescript_1.factory.createParenthesizedExpression(jsx), typescript_1.SyntaxKind.MultiLineCommentTrivia, ' @ts-ignore: TS2322 ', true)));
        const codeBlockContent = variableStatements.concat([jsxStatement]);
        const modifiers = renderExport
            ? [typescript_1.factory.createModifier(typescript_1.SyntaxKind.ExportKeyword), typescript_1.factory.createModifier(typescript_1.SyntaxKind.DefaultKeyword)]
            : [];
        const typeParameter = primitive_1.PrimitiveTypeParameter[primitive_1.Primitive[(_a = this.formComponent) === null || _a === void 0 ? void 0 : _a.componentType]];
        // only use type parameter reference if one was declared
        const typeParameterReference = typeParameter && typeParameter.declaration() ? typeParameter.reference() : undefined;
        return typescript_1.factory.createFunctionDeclaration(undefined, modifiers, undefined, typescript_1.factory.createIdentifier(componentName), typeParameter ? typeParameter.declaration() : undefined, [
            typescript_1.factory.createParameterDeclaration(undefined, undefined, undefined, 'props', undefined, typescript_1.factory.createTypeReferenceNode(componentPropType, typeParameterReference), undefined),
        ], typescript_1.factory.createTypeReferenceNode(typescript_1.factory.createQualifiedName(typescript_1.factory.createIdentifier('React'), typescript_1.factory.createIdentifier('ReactElement')), undefined), typescript_1.factory.createBlock(codeBlockContent, true));
    }
    renderBindingPropsType() {
        var _a, _b;
        const { name: formName, dataType: { dataSourceType, dataTypeName }, } = this.component;
        const fieldConfigs = (_b = (_a = this.componentMetadata.formMetadata) === null || _a === void 0 ? void 0 : _a.fieldConfigs) !== null && _b !== void 0 ? _b : {};
        const overrideTypeAliasDeclaration = (0, form_renderer_helper_1.buildOverrideTypesBindings)(this.formComponent, this.formDefinition, this.importCollection);
        const escapeHatchTypeNode = typescript_1.factory.createTypeLiteralNode([
            typescript_1.factory.createPropertySignature(undefined, typescript_1.factory.createIdentifier('overrides'), typescript_1.factory.createToken(typescript_1.SyntaxKind.QuestionToken), typescript_1.factory.createUnionTypeNode([
                typescript_1.factory.createTypeReferenceNode(`${formName}OverridesProps`, undefined),
                typescript_1.factory.createKeywordTypeNode(typescript_1.SyntaxKind.UndefinedKeyword),
                typescript_1.factory.createLiteralTypeNode(typescript_1.factory.createNull()),
            ])),
        ]);
        const formPropType = (0, react_component_render_helper_1.getComponentPropName)(formName);
        let modelName = dataTypeName;
        // add model import for datastore type
        if (dataSourceType === 'DataStore') {
            this.requiredDataModels.push(dataTypeName);
            modelName = this.importCollection.addModelImport(dataTypeName);
        }
        if ((0, graphql_1.isGraphqlConfig)(this.renderConfig.apiConfiguration) && !this.renderConfig.apiConfiguration.typesFilePath) {
            modelName = 'any';
        }
        return [
            type_helper_1.validationResponseType,
            type_helper_1.validationFunctionType,
            // pass in importCollection once to collect models to import
            (0, type_helper_1.generateFieldTypes)(formName, 'input', fieldConfigs, this.importCollection, this.renderConfig),
            (0, type_helper_1.generateFieldTypes)(formName, 'validation', fieldConfigs, this.importCollection, this.renderConfig),
            primitive_1.primitiveOverrideProp,
            overrideTypeAliasDeclaration,
            typescript_1.factory.createTypeAliasDeclaration(undefined, [typescript_1.factory.createModifier(typescript_1.SyntaxKind.ExportKeyword)], typescript_1.factory.createIdentifier(formPropType), undefined, typescript_1.factory.createTypeReferenceNode(typescript_1.factory.createIdentifier('React.PropsWithChildren'), [
                typescript_1.factory.createIntersectionTypeNode([
                    escapeHatchTypeNode,
                    (0, type_helper_1.buildFormPropNode)(this.component, fieldConfigs, modelName, this.primaryKeys),
                    typescript_1.factory.createTypeReferenceNode(typescript_1.factory.createQualifiedName(typescript_1.factory.createIdentifier('React'), typescript_1.factory.createIdentifier('CSSProperties')), undefined),
                ]),
            ])),
        ];
    }
    /**
     * Variable Statements need for forms
     * -  props passed into form component
     * -  useState
     *  - form fields
     *  - valid state for form
     *  - error object { hasError: boolean, errorMessage: string }
     *  - datastore operation (conditional if form is backed by datastore)
     *  - this is the datastore mutation function which will be used by the helpers
     */
    buildVariableStatements() {
        var _a, _b, _c;
        const statements = [];
        const { formMetadata } = this.componentMetadata;
        const { dataType: { dataTypeName, dataSourceType }, formActionType, } = this.component;
        const lowerCaseDataTypeName = (0, helpers_1.lowerCaseFirst)(dataTypeName);
        const lowerCaseDataTypeNameRecord = `${lowerCaseDataTypeName}Record`;
        const isDataStoreUpdateForm = dataSourceType === 'DataStore' && formActionType === 'update';
        const dataApi = 'apiConfiguration' in this.renderConfig ? (_a = this.renderConfig.apiConfiguration) === null || _a === void 0 ? void 0 : _a.dataApi : undefined;
        let modelName = dataTypeName;
        if (!formMetadata) {
            throw new Error(`Form Metadata is missing from form: ${this.component.name}`);
        }
        this.importCollection.addMappedImport(imports_1.ImportValue.VALIDATE_FIELD, imports_1.ImportValue.FETCH_BY_PATH);
        const hasAutoComplete = Object.values(formMetadata.fieldConfigs).some(({ componentType }) => componentType === primitive_1.Primitive.Autocomplete);
        // add model import for datastore type
        if (dataSourceType === 'DataStore') {
            this.requiredDataModels.push(dataTypeName);
            modelName = this.importCollection.addModelImport(dataTypeName);
        }
        const elements = [
            // add in hooks for before/complete with ds and basic onSubmit with props
            ...(0, form_renderer_helper_1.buildMutationBindings)(this.component, this.primaryKeys),
            // onValidate prop
            typescript_1.factory.createBindingElement(undefined, undefined, typescript_1.factory.createIdentifier('onValidate'), undefined),
            // onChange prop
            typescript_1.factory.createBindingElement(undefined, undefined, typescript_1.factory.createIdentifier('onChange'), undefined),
            // overrides
            typescript_1.factory.createBindingElement(undefined, undefined, typescript_1.factory.createIdentifier('overrides'), undefined),
            // get rest of props to pass to top level component
            typescript_1.factory.createBindingElement(typescript_1.factory.createToken(typescript_1.SyntaxKind.DotDotDotToken), undefined, typescript_1.factory.createIdentifier('rest'), undefined),
        ];
        // add binding elements to statements
        statements.push(typescript_1.factory.createVariableStatement(undefined, typescript_1.factory.createVariableDeclarationList([
            typescript_1.factory.createVariableDeclaration(typescript_1.factory.createObjectBindingPattern(elements), undefined, undefined, typescript_1.factory.createIdentifier('props')),
        ], typescript_1.NodeFlags.Const)));
        if ((0, layout_helpers_1.hasTokenReference)(this.componentMetadata)) {
            statements.push(typescript_1.factory.createVariableStatement(undefined, typescript_1.factory.createVariableDeclarationList([
                typescript_1.factory.createVariableDeclaration(typescript_1.factory.createObjectBindingPattern([
                    typescript_1.factory.createBindingElement(undefined, undefined, typescript_1.factory.createIdentifier('tokens'), undefined),
                ]), undefined, undefined, typescript_1.factory.createCallExpression(typescript_1.factory.createIdentifier('useTheme'), undefined, [])),
            ], typescript_1.NodeFlags.Const)));
        }
        statements.push((0, form_state_1.getInitialValues)(formMetadata.fieldConfigs, this.component));
        statements.push(...(0, form_state_1.getUseStateHooks)(formMetadata.fieldConfigs, formActionType, dataApi, hasAutoComplete));
        statements.push(...(0, form_state_1.getAutocompleteOptions)(formMetadata.fieldConfigs, hasAutoComplete, dataApi));
        statements.push((0, helpers_1.buildUseStateExpression)('errors', typescript_1.factory.createObjectLiteralExpression()));
        let defaultValueVariableName;
        if (formActionType === 'update') {
            if (isDataStoreUpdateForm) {
                defaultValueVariableName = lowerCaseDataTypeNameRecord;
            }
            else {
                defaultValueVariableName = 'initialData';
            }
        }
        statements.push((0, form_state_1.resetStateFunction)(formMetadata.fieldConfigs, defaultValueVariableName));
        const linkedDataNames = [];
        if (isDataStoreUpdateForm) {
            statements.push((0, helpers_1.buildUseStateExpression)(lowerCaseDataTypeNameRecord, typescript_1.factory.createIdentifier((0, helpers_1.getModelNameProp)(lowerCaseDataTypeName))));
            const relatedModelStatements = [];
            // Build effects to grab nested models off target record for relationships
            Object.entries(formMetadata.fieldConfigs).forEach(([key, value]) => {
                var _a;
                if (value.relationship) {
                    const fieldName = value.sanitizedFieldName || key;
                    if (value.relationship.type === 'HAS_MANY') {
                        const linkedDataName = (0, form_renderer_helper_1.getLinkedDataName)(fieldName);
                        linkedDataNames.push(linkedDataName);
                        statements.push((0, helpers_1.buildUseStateExpression)(linkedDataName, typescript_1.factory.createIdentifier('[]')));
                        statements.push((0, helpers_1.buildInitConstVariableExpression)((0, form_state_1.getCanUnlinkModelName)(fieldName), value.relationship.canUnlinkAssociatedModel ? typescript_1.factory.createTrue() : typescript_1.factory.createFalse()));
                    }
                    if (value.relationship.type === 'BELONGS_TO' || ((_a = value.relationship) === null || _a === void 0 ? void 0 : _a.type) === 'HAS_ONE') {
                        linkedDataNames.push(fieldName);
                    }
                    // Flatten statments into 1d array
                    relatedModelStatements.push(...(0, form_renderer_helper_1.buildGetRelationshipModels)(fieldName, value, this.componentMetadata.dataSchemaMetadata, this.primaryKeys, this.importCollection, dataApi, this.renderConfig.dependencies));
                }
            });
            // primaryKey should exist if DataStore update form. This condition is just for ts
            if (this.primaryKeys) {
                // if there are multiple primaryKeys, it's a composite key and we're using 'id' for a composite key prop
                const primaryKeyPropName = this.primaryKeys.length > 1 ? (0, form_renderer_helper_1.getPropName)(constants_1.COMPOSITE_PRIMARY_KEY_PROP_NAME) : (0, form_renderer_helper_1.getPropName)(this.primaryKeys[0]);
                statements.push((0, generate_react_hooks_1.addUseEffectWrapper)((0, form_renderer_helper_1.buildUpdateDatastoreQuery)(modelName, lowerCaseDataTypeName, relatedModelStatements, primaryKeyPropName, this.importCollection, this.primaryKeys, dataApi, this.renderConfig.dependencies), [primaryKeyPropName, (0, helpers_1.getModelNameProp)(lowerCaseDataTypeName)]));
            }
        }
        if (defaultValueVariableName) {
            statements.push((0, form_renderer_helper_1.buildResetValuesOnRecordUpdate)(defaultValueVariableName, linkedDataNames));
        }
        this.importCollection.addMappedImport(imports_1.ImportValue.VALIDATE_FIELD, imports_1.ImportValue.FETCH_BY_PATH);
        if (dataSourceType === 'Custom' && formActionType === 'update') {
            statements.push((0, generate_react_hooks_1.addUseEffectWrapper)([(0, form_renderer_helper_1.buildSetStateFunction)(formMetadata.fieldConfigs)], []));
        }
        // Add value state and ref array type fields in ArrayField wrapper
        const relatedModelNames = new Map();
        Object.entries(formMetadata.fieldConfigs).forEach(([field, fieldConfig]) => {
            const { sanitizedFieldName, componentType, dataType, relationship } = fieldConfig;
            const renderedName = sanitizedFieldName || field;
            if ((0, render_checkers_1.shouldWrapInArrayField)(fieldConfig)) {
                if (fieldConfig.relationship) {
                    statements.push((0, helpers_1.buildUseStateExpression)((0, form_state_1.getCurrentDisplayValueName)(renderedName), (0, form_state_1.getDefaultValueExpression)(formMetadata.name, componentType, dataType, false, true)));
                }
                statements.push((0, helpers_1.buildUseStateExpression)((0, form_state_1.getCurrentValueName)(renderedName), (0, form_state_1.getDefaultValueExpression)(formMetadata.name, componentType, dataType)), typescript_1.factory.createVariableStatement(undefined, typescript_1.factory.createVariableDeclarationList([
                    typescript_1.factory.createVariableDeclaration(typescript_1.factory.createIdentifier((0, form_state_1.getArrayChildRefName)(renderedName)), undefined, undefined, typescript_1.factory.createCallExpression(typescript_1.factory.createPropertyAccessExpression(typescript_1.factory.createIdentifier('React'), typescript_1.factory.createIdentifier('createRef')), undefined, [])),
                ], typescript_1.NodeFlags.Const)));
            }
            if (relationship && !relatedModelNames.has(relationship.relatedModelName)) {
                relatedModelNames.set(relationship.relatedModelName, {
                    relatedModelName: relationship.relatedModelName,
                    fieldName: renderedName,
                });
            }
        });
        const { validationsObject, dataTypesMap, displayValueObject, idValueObject, modelsToImport, usesArrayField } = (0, form_renderer_helper_1.mapFromFieldConfigs)(formMetadata.fieldConfigs);
        if (idValueObject) {
            statements.push(idValueObject);
        }
        statements.push(...(0, model_values_1.buildSelectedRecordsIdSet)(formMetadata.fieldConfigs));
        this.shouldRenderArrayField = usesArrayField;
        modelsToImport.forEach((model) => {
            this.requiredDataModels.push(model);
            this.importCollection.addModelImport(model);
        });
        // relationship query
        /** GraphQL:
         *    const authorRecords = await API.graphql(
         *      { query: listAuthors }
         *    ).data.listAuthors.items;
         */
        /** Datastore:
              const authorRecords = useDataStoreBinding({
                type: 'collection',
                model: Author,
              }).items;
        */
        if (relatedModelNames.size) {
            if (!(((_b = this.renderConfig.apiConfiguration) === null || _b === void 0 ? void 0 : _b.dataApi) === 'GraphQL')) {
                this.importCollection.addMappedImport(imports_1.ImportValue.USE_DATA_STORE_BINDING);
                statements.push(...[...relatedModelNames].map(([, { relatedModelName, fieldName }]) => (0, form_renderer_helper_1.buildRelationshipQuery)(relatedModelName, this.importCollection, fieldName, dataApi, this.renderConfig.dependencies)));
            }
        }
        if (displayValueObject) {
            statements.push(displayValueObject);
        }
        statements.push(validationsObject);
        statements.push(form_renderer_helper_1.runValidationTasksFunction);
        // timestamp type takes precedence over datetime as it includes formatter for datetime
        // we include both the timestamp conversion and local date formatter
        if (dataTypesMap.AWSTimestamp &&
            dataTypesMap.AWSTimestamp.some((fieldName) => {
                const field = formMetadata.fieldConfigs[fieldName];
                if (field && field.studioFormComponentType === 'DateTimeField') {
                    return true;
                }
                return false;
            })) {
            statements.push(value_mappers_1.convertTimeStampToDateAST, value_mappers_1.convertToLocalAST);
        }
        // if we only have date time then we only need the local conversion
        else if (dataTypesMap.AWSDateTime) {
            statements.push(value_mappers_1.convertToLocalAST);
        }
        if (hasAutoComplete && dataApi === 'GraphQL') {
            statements.push(...(0, graphql_1.getFetchRelatedRecordsCallbacks)(formMetadata.fieldConfigs, this.importCollection, (_c = this.renderConfig.apiConfiguration) === null || _c === void 0 ? void 0 : _c.dataApi, this.renderConfig.dependencies));
        }
        return statements;
    }
    validateSchema(component) {
        (0, codegen_ui_1.validateFormSchema)(component);
    }
}
__decorate([
    codegen_ui_1.handleCodegenErrors
], ReactFormTemplateRenderer.prototype, "renderComponentOnly", null);
exports.ReactFormTemplateRenderer = ReactFormTemplateRenderer;
//# sourceMappingURL=react-form-renderer.js.map