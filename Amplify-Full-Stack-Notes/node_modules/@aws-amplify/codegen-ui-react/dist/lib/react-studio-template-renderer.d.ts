import { StudioTemplateRenderer, StudioComponent, ComponentMetadata, GenericDataSchema } from '@aws-amplify/codegen-ui';
import { FunctionDeclaration, JsxElement, JsxFragment, TypeAliasDeclaration, VariableStatement, Statement, JsxSelfClosingElement } from 'typescript';
import { ImportCollection } from './imports';
import { ReactOutputManager } from './react-output-manager';
import { ReactRenderConfig } from './react-render-config';
import { defaultRenderConfig } from './react-studio-template-renderer-helper';
export declare abstract class ReactStudioTemplateRenderer extends StudioTemplateRenderer<string, StudioComponent, ReactOutputManager, {
    componentText: string;
    renderComponentToFilesystem: (outputPath: string) => Promise<void>;
}> {
    protected importCollection: ImportCollection;
    protected renderConfig: ReactRenderConfig & typeof defaultRenderConfig;
    protected componentMetadata: ComponentMetadata;
    fileName: string;
    constructor(component: StudioComponent, renderConfig: ReactRenderConfig, dataSchema?: GenericDataSchema);
    renderSampleCodeSnippet(): {
        compText: string;
        importsText: string;
    };
    renderComponentOnly(): {
        compText: string;
        importsText: string;
        requiredDataModels: string[];
        importCollection: ImportCollection;
    };
    renderComponentInternal(): {
        componentText: string;
        declaration: string | undefined;
        renderComponentToFilesystem: (outputPath: string) => Promise<void>;
    };
    renderFunctionWrapper(componentName: string, variableStatements: Statement[], jsx: JsxElement | JsxFragment | JsxSelfClosingElement, renderExport: boolean): FunctionDeclaration;
    renderAppWrapper(appName: string, jsx: JsxElement | JsxFragment | JsxSelfClosingElement): VariableStatement;
    renderSampleCodeSnippetJsx(component: StudioComponent): JsxElement | JsxFragment | JsxSelfClosingElement;
    renderBindingPropsType(component: StudioComponent): TypeAliasDeclaration[];
    private buildBasePropNode;
    /**
     * This builder is responsible primarily for identifying the variant options, partioning them into
     * required and optional parameters, then building the appropriate property signature based on that.
     * e.g.
       {
         variant?: "primary" | "secondary",
         size?: "large",
       }
     */
    private buildVariantPropNode;
    private buildComponentPropNode;
    protected buildVariableStatements(component: StudioComponent): Statement[];
    private buildUseAuthenticatedUserStatement;
    /**
     * const variants = [
       {
         variantValues: { variant: 'primary' },
         overrides: { Button: { fontSize: '12px' } },
       },
       {
         variantValues: { variant: 'secondary' },
         overrides: { Button: { fontSize: '40px' } }
       }
     ];
     */
    private buildVariantDeclaration;
    /**
     *     const breakpointHook = useBreakpointValue({
     *        base: 'base',
     *        large: 'large',
     *        medium: 'medium',
     *        small: 'small',
     *        xl: 'xl',
     *        xxl: 'xxl',
     *     });
     */
    private buildDefaultBreakpointMap;
    /**
     *   const rest = {style: {transition:"all 1s"}, ...restProp}
     */
    private buildRestWithStyle;
    /**
     * If component hasBreakpoint:
     *
     * const overrides = mergeVariantsAndOverrides(
     *  getOverridesFromVariants(variants, {
     *   breakpoint: breakpointHook,
     *   ...props,
     *  }),
     *  overridesProp || {}
     * );
     *
     * Else:
     *
     * const overrides = mergeVariantsAndOverrides(
     *  getOverridesFromVariants(variants, props),
     *  overridesProp || {}
     * );
     */
    private buildOverridesFromVariantsAndProp;
    private buildCollectionBindingStatements;
    /**
    React.useEffect(() => {
      if (itemsProp !== undefined) {
        setItems(itemsProp)
        return;
      }
  
      <setItemsFromDataStoreFunctionDeclaration>
      
      setItemsFromDataStore()
  
    }, [itemsProp, itemsDataStore])
     */
    private buildSetCollectionItemsUseEffectStatement;
    /**
    async function setItemsFromDataStore() {
      const loaded = await Promise.all(itemsDataStore.map(async (item) => ({
          ...item,
          CompositeOwner: await item.CompositeOwner,
          CompositeToys: await item.CompositeToys.toArray()
        })))
  
      setItems(loaded)
    }
     */
    private buildSetItemsFromDataStoreFunction;
    private buildCreateDataStorePredicateCall;
    private buildUseBindingStatements;
    private buildPropPrecedentStatement;
    /**
     * const buttonUserSort = {
     *   sort: (s: SortPredicate<User>) => s.firstName('DESCENDING').lastName('ASCENDING')
     * }
     */
    private buildPaginationStatement;
    private buildCollectionBindingCall;
    private buildUseDataStoreBindingCall;
    private predicateToObjectLiteralExpression;
    private buildUseActionStatements;
    private buildPredicateDeclaration;
    private buildGraphqlPaginationStatements;
    private buildLoadPageStatement;
    private hasCollectionPropertyNamedItems;
    private getPaginationName;
    private getFilterObjName;
    private getFilterName;
    private getDataStoreName;
    private getPropsTypeName;
    private getQueryRelationshipName;
    private dropMissingListElements;
    private getDefaultValue;
    private mapSyntheticPropsForVariants;
    private mapSyntheticProps;
    validateSchema(component: StudioComponent): void;
    abstract renderJsx(component: StudioComponent): JsxElement | JsxFragment | JsxSelfClosingElement;
}
