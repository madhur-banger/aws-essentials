"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const mergeVariantsAndOverrides_1 = require("../mergeVariantsAndOverrides");
describe('mergeVariantsAndOverrides', () => {
    const expected = {
        'Flex.Button[0]': {
            color: 'red',
            size: 'large',
        },
        'Flex.CheckBox[1]': {
            isEnabled: 'false',
            size: 'large',
        },
    };
    it('should return merged variants after applying overrides', () => {
        const variants = {
            'Flex.Button[0]': {
                color: 'red',
            },
            'Flex.CheckBox[1]': {
                isEnabled: 'false',
                size: 'small',
            },
        };
        const overrides = {
            'Flex.Button[0]': {
                size: 'large',
            },
            'Flex.CheckBox[1]': {
                size: 'large',
            },
        };
        expect((0, mergeVariantsAndOverrides_1.mergeVariantsAndOverrides)(variants, overrides)).toEqual(expected);
    });
    it('should return merged variants when override includes new control', () => {
        const variants = {
            'Flex.Button[0]': {
                color: 'red',
                size: 'large',
            },
        };
        const overrides = {
            'Flex.CheckBox[1]': {
                isEnabled: 'false',
                size: 'large',
            },
        };
        expect((0, mergeVariantsAndOverrides_1.mergeVariantsAndOverrides)(variants, overrides)).toEqual(expected);
    });
    it('should return merged variants when all variants overridden', () => {
        const variants = {
            'Flex.Button[0]': {
                color: 'green',
                size: 'small',
            },
            'Flex.CheckBox[1]': {
                isEnabled: 'true',
                size: 'small',
            },
        };
        const overrides = {
            ...expected,
        };
        expect((0, mergeVariantsAndOverrides_1.mergeVariantsAndOverrides)(variants, overrides)).toEqual(expected);
    });
    it('should return original variants when override is empty', () => {
        const variants = {
            ...expected,
        };
        const overrides = {};
        expect((0, mergeVariantsAndOverrides_1.mergeVariantsAndOverrides)(variants, overrides)).toEqual(expected);
    });
    it('should return original variants when override is null', () => {
        const variants = {
            ...expected,
        };
        // cast null as EscapeHatchProps for exhaustive test case
        expect((0, mergeVariantsAndOverrides_1.mergeVariantsAndOverrides)(variants, null)).toEqual(expected);
    });
    it('should return overrides when variant is null', () => {
        const overrides = {
            ...expected,
        };
        // cast null as EscapeHatchProps for exhaustive test case
        expect((0, mergeVariantsAndOverrides_1.mergeVariantsAndOverrides)(null, overrides)).toEqual(expected);
    });
    it('should return null when both variant & override are null', () => {
        expect(
        // cast null as EscapeHatchProps for exhaustive test case
        (0, mergeVariantsAndOverrides_1.mergeVariantsAndOverrides)(null, null)).toEqual(null);
    });
});
//# sourceMappingURL=mergeVariantsAndOverrides.test.js.map