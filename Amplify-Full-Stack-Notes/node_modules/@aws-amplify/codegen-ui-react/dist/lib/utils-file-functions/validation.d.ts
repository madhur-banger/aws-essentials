declare type ValidationResponse = {
    hasError: boolean;
    errorMessage?: string;
};
declare type FieldValidationConfiguration = {
    type: string;
    strValues?: string[];
    numValues?: number[];
    validationMessage?: string;
};
export declare const validateField: (value: any, validations: FieldValidationConfiguration[]) => ValidationResponse;
export declare const parseDateValidator: (dateValidator: string) => string | number;
export declare const validationString = "type ValidationResponse = { hasError: boolean; errorMessage?: string };\ntype FieldValidationConfiguration = {\n  type: string;\n  strValues?: string[];\n  numValues?: number[];\n  validationMessage?: string;\n};\n\nexport const validateField = (value: any, validations: FieldValidationConfiguration[]): ValidationResponse => {\n  for (const validation of validations) {\n    if (value === undefined || value === '' || value === null) {\n      if (validation.type === 'Required') {\n        return {\n          hasError: true,\n          errorMessage: validation.validationMessage || 'The value is required',\n        };\n      } else {\n        return {\n          hasError: false,\n        };\n      }\n    }\n\n    const validationResult = checkValidation(value, validation);\n\n    if (validationResult?.hasError) {\n      return validationResult;\n    }\n  }\n  return { hasError: false };\n};\n\nexport const parseDateValidator = (dateValidator: string) => {\n  const isTimestamp = `${parseInt(dateValidator)}`.length === dateValidator.length;\n  return isTimestamp ? parseInt(dateValidator) : dateValidator;\n};\n\nconst checkValidation = (value: any, validation: FieldValidationConfiguration) => {\n  if (validation.numValues?.length) {\n    switch (validation.type) {\n      case 'LessThanChar':\n        return {\n          hasError: !(value.length <= validation.numValues[0]),\n          errorMessage:\n            validation.validationMessage || `The value must be shorter than ${validation.numValues[0]} characters`,\n        };\n      case 'GreaterThanChar':\n        return {\n          hasError: !(value.length > validation.numValues[0]),\n          errorMessage:\n          validation.validationMessage || `The value must be longer than ${validation.numValues[0]} characters`,\n        };\n      case 'LessThanNum':\n        return {\n          hasError: !(value < validation.numValues[0]),\n          errorMessage: validation.validationMessage || `The value must be less than ${validation.numValues[0]}`,\n        };\n      case 'GreaterThanNum':\n        return {\n          hasError: !(value > validation.numValues[0]),\n          errorMessage: validation.validationMessage || `The value must be greater than ${validation.numValues[0]}`,\n        };\n      case 'EqualTo':\n        return {\n          hasError: !validation.numValues.some((el) => el === value),\n          errorMessage:\n            validation.validationMessage || `The value must be equal to ${validation.numValues.join(' or ')}`,\n        };\n      default:\n    }\n  } else if (validation.strValues?.length) {\n    switch (validation.type) {\n      case 'StartWith':\n        return {\n          hasError: !validation.strValues.some((el: any) => value.startsWith(el)),\n          errorMessage: validation.validationMessage || `The value must start with ${validation.strValues.join(', ')}`,\n        };\n      case 'EndWith':\n        return {\n          hasError: !validation.strValues.some((el: any) => value.endsWith(el)),\n          errorMessage: validation.validationMessage || `The value must end with ${validation.strValues.join(', ')}`,\n        };\n      case 'Contains':\n        return {\n          hasError: !validation.strValues.some((el: any) => value.includes(el)),\n          errorMessage: validation.validationMessage || `The value must contain ${validation.strValues.join(', ')}`,\n        };\n      case 'NotContains':\n        return {\n          hasError: !validation.strValues.every((el: any) => !value.includes(el)),\n          errorMessage: validation.validationMessage || `The value must not contain ${validation.strValues.join(', ')}`,\n        };\n      case 'BeAfter':\n        return {\n          hasError: !(new Date(value) > new Date(parseDateValidator(validation.strValues[0]))),\n          errorMessage: validation.validationMessage || `The value must be after ${validation.strValues[0]}`,\n        };\n      case 'BeBefore':\n        return {\n          hasError: !(new Date(value) < new Date(parseDateValidator(validation.strValues[0]))),\n          errorMessage: validation.validationMessage || `The value must be before ${validation.strValues[0]}`,\n        };\n    }\n  }\n  switch (validation.type) {\n    case 'Email':\n      const EMAIL_ADDRESS_REGEX =\n           /^[-!#$%&'*+/0-9=?A-Z^_a-z`{|}~](.?[-!#$%&'*+/0-9=?A-Z^_a-z`{|}~])*@[a-zA-Z0-9](-*.?[a-zA-Z0-9])*.[a-zA-Z](-?[a-zA-Z0-9])+$/;\n      return {\n        hasError: !EMAIL_ADDRESS_REGEX.test(value),\n        errorMessage: validation.validationMessage || 'The value must be a valid email address',\n      };\n    case 'JSON':\n      let isInvalidJSON = false;\n      try {\n        JSON.parse(value);\n      } catch (e) {\n        isInvalidJSON = true;\n      }\n      return {\n        hasError: isInvalidJSON,\n        errorMessage: validation.validationMessage || 'The value must be in a correct JSON format',\n      };\n    case 'IpAddress':\n      const IPV_4 = /^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$/;\n      const IPV_6 =\n        /^(?:(?:[a-fA-F\\d]{1,4}:){7}(?:[a-fA-F\\d]{1,4}|:)|(?:[a-fA-F\\d]{1,4}:){6}(?:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|:[a-fA-F\\d]{1,4}|:)|(?:[a-fA-F\\d]{1,4}:){5}(?::(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,2}|:)|(?:[a-fA-F\\d]{1,4}:){4}(?:(?::[a-fA-F\\d]{1,4}){0,1}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,3}|:)|(?:[a-fA-F\\d]{1,4}:){3}(?:(?::[a-fA-F\\d]{1,4}){0,2}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,4}|:)|(?:[a-fA-F\\d]{1,4}:){2}(?:(?::[a-fA-F\\d]{1,4}){0,3}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,5}|:)|(?:[a-fA-F\\d]{1,4}:){1}(?:(?::[a-fA-F\\d]{1,4}){0,4}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,6}|:)|(?::(?:(?::[a-fA-F\\d]{1,4}){0,5}:(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}|(?::[a-fA-F\\d]{1,4}){1,7}|:)))(?:%[0-9a-zA-Z]{1,})?$/;\n      return {\n        hasError: !(IPV_4.test(value) || IPV_6.test(value)),\n        errorMessage: validation.validationMessage || 'The value must be an IPv4 or IPv6 address',\n      };\n    case 'URL':\n      let isInvalidUrl = false;\n      try {\n        new URL(value);\n      } catch (e) {\n        isInvalidUrl = true;\n      }\n      return {\n        hasError: isInvalidUrl,\n        errorMessage:\n          validation.validationMessage ||\n          'The value must be a valid URL that begins with a schema (i.e. http:// or mailto:)',\n      };\n    case 'Phone':\n      const PHONE = /^\\+?\\d[\\d\\s-]+$/;\n      return {\n        hasError: !PHONE.test(value),\n        errorMessage: validation.validationMessage || 'The value must be a valid phone number',\n      };\n    default:\n  }\n};";
export {};
