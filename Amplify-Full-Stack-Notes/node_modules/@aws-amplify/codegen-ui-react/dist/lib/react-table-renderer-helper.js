"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.stringFormatToType = exports.objectToExpression = exports.buildDataStoreCollectionCall = exports.needsFormatter = exports.getDataStoreName = exports.getPaginationName = exports.getPredicateName = exports.getFilterName = void 0;
const typescript_1 = require("typescript");
const getFilterName = (model) => `${model.toLowerCase()}Filter`;
exports.getFilterName = getFilterName;
const getPredicateName = (model) => `${model.toLowerCase()}Predicate`;
exports.getPredicateName = getPredicateName;
const getPaginationName = (model) => `${model.toLowerCase()}Pagination`;
exports.getPaginationName = getPaginationName;
const getDataStoreName = (model) => `${model.toLowerCase()}DataStore`;
exports.getDataStoreName = getDataStoreName;
/*
checks table to see if there is a formatter for stringFormat
*/
const needsFormatter = (config) => {
    if (config.table.columns) {
        return Object.values(config.table.columns).some((column) => { var _a; return ((_a = column.valueFormatting) === null || _a === void 0 ? void 0 : _a.stringFormat) !== undefined; });
    }
    return false;
};
exports.needsFormatter = needsFormatter;
/*
  const dataStoreItems = useDataStoreBinding({
    type: 'collection',
    model: 'Post',
    criteria: predicateOverrides ?? predicateApiSettings,
    sort: sortApiSettings,
  })
 */
const buildDataStoreCollectionCall = (model, criteriaName, paginationName) => {
    const objectProperties = [
        typescript_1.factory.createPropertyAssignment(typescript_1.factory.createIdentifier('type'), typescript_1.factory.createStringLiteral('collection')),
        typescript_1.factory.createPropertyAssignment(typescript_1.factory.createIdentifier('model'), typescript_1.factory.createIdentifier(model)),
    ]
        .concat(criteriaName
        ? [
            // criteria: predicateOverride || {criteriaName}
            typescript_1.factory.createPropertyAssignment(typescript_1.factory.createIdentifier('criteria'), typescript_1.factory.createBinaryExpression(typescript_1.factory.createIdentifier('predicateOverride'), typescript_1.factory.createToken(typescript_1.SyntaxKind.BarBarToken), typescript_1.factory.createIdentifier(criteriaName))),
        ]
        : [
            // criteria: predicateOverride
            typescript_1.factory.createPropertyAssignment(typescript_1.factory.createIdentifier('criteria'), typescript_1.factory.createIdentifier('predicateOverride')),
        ])
        .concat(paginationName
        ? [
            typescript_1.factory.createPropertyAssignment(typescript_1.factory.createIdentifier('pagination'), typescript_1.factory.createIdentifier(paginationName)),
        ]
        : []);
    return typescript_1.factory.createCallExpression(typescript_1.factory.createIdentifier('useDataStoreBinding'), undefined, [
        typescript_1.factory.createObjectLiteralExpression(objectProperties, true),
    ]);
};
exports.buildDataStoreCollectionCall = buildDataStoreCollectionCall;
/*  Helper to codegen objects

    example output:
    {
        stringFormat: {
            dateTimeFormat: {
                dateFormat: "locale",
                timeFormat: "hours24",
            },
        }
    }
*/
const objectToExpression = (object) => {
    return typescript_1.factory.createObjectLiteralExpression(Object.entries(object).map(([key, value]) => typescript_1.factory.createPropertyAssignment(typescript_1.factory.createIdentifier(key), typeof value === 'string' ? typescript_1.factory.createStringLiteral(value) : (0, exports.objectToExpression)(value))));
};
exports.objectToExpression = objectToExpression;
const stringFormatToType = (viewFormat) => {
    if (!viewFormat) {
        return undefined;
    }
    if (viewFormat.stringFormat.type) {
        return viewFormat.stringFormat.type;
    }
    const { type, ...format } = viewFormat.stringFormat;
    switch (Object.keys(format)[0]) {
        case 'nonLocaleDateTimeFormat':
            return 'NonLocaleDateTimeFormat';
        case 'localeDateTimeFormat':
            return 'LocaleDateTimeFormat';
        case 'timeFormat':
            return 'TimeFormat';
        case 'dateFormat':
            return 'DateFormat';
        default:
            // Unsupported formatting
            return undefined;
    }
};
exports.stringFormatToType = stringFormatToType;
//# sourceMappingURL=react-table-renderer-helper.js.map