import { ListAppsCommand } from '@aws-sdk/client-amplify';
import { BackendIdentifierConversions } from '@aws-amplify/platform-core';
/**
 * Resolves stack names given an Amplify app name and branch
 */
export class AppNameAndBranchMainStackNameResolver {
    amplifyClient;
    appNameAndBranch;
    /**
     * Initialize with an Amplify client and app info
     */
    constructor(amplifyClient, appNameAndBranch) {
        this.amplifyClient = amplifyClient;
        this.appNameAndBranch = appNameAndBranch;
    }
    /**
     * Lists all apps and filters by the specified appName. If one and only one app matches, then the appId is used.
     * If zero or multiple apps are found, an error message is thrown
     */
    resolveMainStackName = async () => {
        const listAppsResult = await this.amplifyClient.send(
        // 100 is the max page size. It is also the hard limit for how many Amplify apps you can have so no pagination is necessary
        new ListAppsCommand({ maxResults: 100 }));
        const appMatches = (listAppsResult?.apps || []).filter((app) => app.name === this.appNameAndBranch.appName);
        const region = await this.amplifyClient.config.region();
        if (appMatches.length === 0) {
            throw new Error(`No apps found with name ${this.appNameAndBranch.appName} in region ${region}`);
        }
        else if (appMatches.length >= 2) {
            throw new Error(`Multiple apps found with name ${this.appNameAndBranch.appName} in region ${region}. Use AppId instead of AppName to specify which Amplify App to use.`);
        }
        // if we get here, appMatches has one and only one entry
        const appId = appMatches[0].appId;
        if (typeof appId !== 'string') {
            // if this happens something has gone seriously wrong. It's probably an Amplify service issue.
            throw new Error(`Could not determine appId from app name ${this.appNameAndBranch.appName}. Try using AppId instead.`);
        }
        return BackendIdentifierConversions.toStackName({
            namespace: appId,
            name: this.appNameAndBranch.branchName,
            type: 'branch',
        });
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXBwX25hbWVfYW5kX2JyYW5jaF9tYWluX3N0YWNrX25hbWVfcmVzb2x2ZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvc3RhY2stbmFtZS1yZXNvbHZlcnMvYXBwX25hbWVfYW5kX2JyYW5jaF9tYWluX3N0YWNrX25hbWVfcmVzb2x2ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsT0FBTyxFQUFpQixlQUFlLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUN6RSxPQUFPLEVBQUUsNEJBQTRCLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQVUxRTs7R0FFRztBQUNILE1BQU0sT0FBTyxxQ0FBcUM7SUFPN0I7SUFDQTtJQUxuQjs7T0FFRztJQUNILFlBQ21CLGFBQTRCLEVBQzVCLGdCQUFtRDtRQURuRCxrQkFBYSxHQUFiLGFBQWEsQ0FBZTtRQUM1QixxQkFBZ0IsR0FBaEIsZ0JBQWdCLENBQW1DO0lBQ25FLENBQUM7SUFFSjs7O09BR0c7SUFDSCxvQkFBb0IsR0FBRyxLQUFLLElBQXFCLEVBQUU7UUFDakQsTUFBTSxjQUFjLEdBQUcsTUFBTSxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUk7UUFDbEQsMkhBQTJIO1FBQzNILElBQUksZUFBZSxDQUFDLEVBQUUsVUFBVSxFQUFFLEdBQUcsRUFBRSxDQUFDLENBQ3pDLENBQUM7UUFDRixNQUFNLFVBQVUsR0FBRyxDQUFDLGNBQWMsRUFBRSxJQUFJLElBQUksRUFBRSxDQUFDLENBQUMsTUFBTSxDQUNwRCxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsR0FBRyxDQUFDLElBQUksS0FBSyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsT0FBTyxDQUNwRCxDQUFDO1FBQ0YsTUFBTSxNQUFNLEdBQUcsTUFBTSxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUN4RCxJQUFJLFVBQVUsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBQzNCLE1BQU0sSUFBSSxLQUFLLENBQ2IsMkJBQTJCLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxPQUFPLGNBQWMsTUFBTSxFQUFFLENBQy9FLENBQUM7U0FDSDthQUFNLElBQUksVUFBVSxDQUFDLE1BQU0sSUFBSSxDQUFDLEVBQUU7WUFDakMsTUFBTSxJQUFJLEtBQUssQ0FDYixpQ0FBaUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sY0FBYyxNQUFNLHFFQUFxRSxDQUN4SixDQUFDO1NBQ0g7UUFDRCx3REFBd0Q7UUFDeEQsTUFBTSxLQUFLLEdBQUcsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztRQUNsQyxJQUFJLE9BQU8sS0FBSyxLQUFLLFFBQVEsRUFBRTtZQUM3Qiw4RkFBOEY7WUFDOUYsTUFBTSxJQUFJLEtBQUssQ0FDYiwyQ0FBMkMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sNEJBQTRCLENBQ3JHLENBQUM7U0FDSDtRQUNELE9BQU8sNEJBQTRCLENBQUMsV0FBVyxDQUFDO1lBQzlDLFNBQVMsRUFBRSxLQUFLO1lBQ2hCLElBQUksRUFBRSxJQUFJLENBQUMsZ0JBQWdCLENBQUMsVUFBVTtZQUN0QyxJQUFJLEVBQUUsUUFBUTtTQUNmLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQztDQUNIIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTWFpblN0YWNrTmFtZVJlc29sdmVyIH0gZnJvbSAnQGF3cy1hbXBsaWZ5L3BsdWdpbi10eXBlcyc7XG5pbXBvcnQgeyBBbXBsaWZ5Q2xpZW50LCBMaXN0QXBwc0NvbW1hbmQgfSBmcm9tICdAYXdzLXNkay9jbGllbnQtYW1wbGlmeSc7XG5pbXBvcnQgeyBCYWNrZW5kSWRlbnRpZmllckNvbnZlcnNpb25zIH0gZnJvbSAnQGF3cy1hbXBsaWZ5L3BsYXRmb3JtLWNvcmUnO1xuXG4vKipcbiAqIFR1cGxlIG9mIEFtcGxpZnkgQXBwIG5hbWUgYW5kIGJyYW5jaFxuICovXG5leHBvcnQgdHlwZSBBcHBOYW1lQW5kQnJhbmNoQmFja2VuZElkZW50aWZpZXIgPSB7XG4gIGFwcE5hbWU6IHN0cmluZztcbiAgYnJhbmNoTmFtZTogc3RyaW5nO1xufTtcblxuLyoqXG4gKiBSZXNvbHZlcyBzdGFjayBuYW1lcyBnaXZlbiBhbiBBbXBsaWZ5IGFwcCBuYW1lIGFuZCBicmFuY2hcbiAqL1xuZXhwb3J0IGNsYXNzIEFwcE5hbWVBbmRCcmFuY2hNYWluU3RhY2tOYW1lUmVzb2x2ZXJcbiAgaW1wbGVtZW50cyBNYWluU3RhY2tOYW1lUmVzb2x2ZXJcbntcbiAgLyoqXG4gICAqIEluaXRpYWxpemUgd2l0aCBhbiBBbXBsaWZ5IGNsaWVudCBhbmQgYXBwIGluZm9cbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgYW1wbGlmeUNsaWVudDogQW1wbGlmeUNsaWVudCxcbiAgICBwcml2YXRlIHJlYWRvbmx5IGFwcE5hbWVBbmRCcmFuY2g6IEFwcE5hbWVBbmRCcmFuY2hCYWNrZW5kSWRlbnRpZmllclxuICApIHt9XG5cbiAgLyoqXG4gICAqIExpc3RzIGFsbCBhcHBzIGFuZCBmaWx0ZXJzIGJ5IHRoZSBzcGVjaWZpZWQgYXBwTmFtZS4gSWYgb25lIGFuZCBvbmx5IG9uZSBhcHAgbWF0Y2hlcywgdGhlbiB0aGUgYXBwSWQgaXMgdXNlZC5cbiAgICogSWYgemVybyBvciBtdWx0aXBsZSBhcHBzIGFyZSBmb3VuZCwgYW4gZXJyb3IgbWVzc2FnZSBpcyB0aHJvd25cbiAgICovXG4gIHJlc29sdmVNYWluU3RhY2tOYW1lID0gYXN5bmMgKCk6IFByb21pc2U8c3RyaW5nPiA9PiB7XG4gICAgY29uc3QgbGlzdEFwcHNSZXN1bHQgPSBhd2FpdCB0aGlzLmFtcGxpZnlDbGllbnQuc2VuZChcbiAgICAgIC8vIDEwMCBpcyB0aGUgbWF4IHBhZ2Ugc2l6ZS4gSXQgaXMgYWxzbyB0aGUgaGFyZCBsaW1pdCBmb3IgaG93IG1hbnkgQW1wbGlmeSBhcHBzIHlvdSBjYW4gaGF2ZSBzbyBubyBwYWdpbmF0aW9uIGlzIG5lY2Vzc2FyeVxuICAgICAgbmV3IExpc3RBcHBzQ29tbWFuZCh7IG1heFJlc3VsdHM6IDEwMCB9KVxuICAgICk7XG4gICAgY29uc3QgYXBwTWF0Y2hlcyA9IChsaXN0QXBwc1Jlc3VsdD8uYXBwcyB8fCBbXSkuZmlsdGVyKFxuICAgICAgKGFwcCkgPT4gYXBwLm5hbWUgPT09IHRoaXMuYXBwTmFtZUFuZEJyYW5jaC5hcHBOYW1lXG4gICAgKTtcbiAgICBjb25zdCByZWdpb24gPSBhd2FpdCB0aGlzLmFtcGxpZnlDbGllbnQuY29uZmlnLnJlZ2lvbigpO1xuICAgIGlmIChhcHBNYXRjaGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgTm8gYXBwcyBmb3VuZCB3aXRoIG5hbWUgJHt0aGlzLmFwcE5hbWVBbmRCcmFuY2guYXBwTmFtZX0gaW4gcmVnaW9uICR7cmVnaW9ufWBcbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChhcHBNYXRjaGVzLmxlbmd0aCA+PSAyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBNdWx0aXBsZSBhcHBzIGZvdW5kIHdpdGggbmFtZSAke3RoaXMuYXBwTmFtZUFuZEJyYW5jaC5hcHBOYW1lfSBpbiByZWdpb24gJHtyZWdpb259LiBVc2UgQXBwSWQgaW5zdGVhZCBvZiBBcHBOYW1lIHRvIHNwZWNpZnkgd2hpY2ggQW1wbGlmeSBBcHAgdG8gdXNlLmBcbiAgICAgICk7XG4gICAgfVxuICAgIC8vIGlmIHdlIGdldCBoZXJlLCBhcHBNYXRjaGVzIGhhcyBvbmUgYW5kIG9ubHkgb25lIGVudHJ5XG4gICAgY29uc3QgYXBwSWQgPSBhcHBNYXRjaGVzWzBdLmFwcElkO1xuICAgIGlmICh0eXBlb2YgYXBwSWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBpZiB0aGlzIGhhcHBlbnMgc29tZXRoaW5nIGhhcyBnb25lIHNlcmlvdXNseSB3cm9uZy4gSXQncyBwcm9iYWJseSBhbiBBbXBsaWZ5IHNlcnZpY2UgaXNzdWUuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBDb3VsZCBub3QgZGV0ZXJtaW5lIGFwcElkIGZyb20gYXBwIG5hbWUgJHt0aGlzLmFwcE5hbWVBbmRCcmFuY2guYXBwTmFtZX0uIFRyeSB1c2luZyBBcHBJZCBpbnN0ZWFkLmBcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBCYWNrZW5kSWRlbnRpZmllckNvbnZlcnNpb25zLnRvU3RhY2tOYW1lKHtcbiAgICAgIG5hbWVzcGFjZTogYXBwSWQsXG4gICAgICBuYW1lOiB0aGlzLmFwcE5hbWVBbmRCcmFuY2guYnJhbmNoTmFtZSxcbiAgICAgIHR5cGU6ICdicmFuY2gnLFxuICAgIH0pO1xuICB9O1xufVxuIl19