"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.InvalidSchemaError = exports.EmptySchemaError = exports.StringDataSourceAdapter = void 0;
const sync_1 = require("csv-parse/sync");
const pluralize_1 = require("pluralize");
const graphql_transformer_common_1 = require("graphql-transformer-common");
const schema_representation_1 = require("../schema-representation");
class StringDataSourceAdapter {
    constructor(schema) {
        const parsedSchema = this.parseSchema(schema.trim());
        this.validateSchema(parsedSchema);
        this.setSchema(parsedSchema);
    }
    parseSchema(schema) {
        return (0, sync_1.parse)(schema, {
            columns: true,
            relax_quotes: true,
            cast: (value, context) => {
                if (value === 'NULL' || value === 'null') {
                    return null;
                }
                return value;
            },
        });
    }
    getModels() {
        const tableNames = this.getTablesList();
        const models = [];
        for (const table of tableNames) {
            models.push(this.describeTable(table));
        }
        return models;
    }
    describeTable(tableName) {
        const fields = this.getFields(tableName);
        const primaryKey = this.getPrimaryKey(tableName);
        const indexes = this.getIndexes(tableName);
        const model = new schema_representation_1.Model(tableName);
        fields.forEach((field) => model.addField(field));
        primaryKey && model.setPrimaryKey(primaryKey.getFields());
        indexes.forEach((index) => model.addIndex(index.name, index.getFields()));
        return model;
    }
    getEnumName(name) {
        return (0, pluralize_1.singular)((0, graphql_transformer_common_1.toPascalCase)(name.split('_')));
    }
}
exports.StringDataSourceAdapter = StringDataSourceAdapter;
class EmptySchemaError extends Error {
    constructor() {
        super('Imported SQL schema is empty.');
    }
}
exports.EmptySchemaError = EmptySchemaError;
class InvalidSchemaError extends Error {
    constructor(schema, expectedColumns) {
        const columns = Object.keys(schema[0]);
        const missingColumns = expectedColumns.filter((column) => !columns.includes(column));
        const message = `Imported SQL schema is invalid. Imported schema is missing columns: ${missingColumns.join(', ')}`;
        super(message);
    }
}
exports.InvalidSchemaError = InvalidSchemaError;
//# sourceMappingURL=string-datasource-adapter.js.map