"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataSourceAdapter = void 0;
const os = __importStar(require("os"));
const schema_representation_1 = require("../schema-representation");
class DataSourceAdapter {
    constructor() {
        this.useVPC = false;
        this.vpcSchemaInspectorLambda = undefined;
        this.vpcLambdaRegion = undefined;
    }
    getModels() {
        const tableNames = this.getTablesList();
        const models = [];
        for (const table of tableNames) {
            models.push(this.describeTable(table));
        }
        return models;
    }
    describeTable(tableName) {
        const fields = this.getFields(tableName);
        const primaryKey = this.getPrimaryKey(tableName);
        const indexes = this.getIndexes(tableName);
        const model = new schema_representation_1.Model(tableName);
        fields.forEach((field) => model.addField(field));
        primaryKey && model.setPrimaryKey(primaryKey.getFields());
        indexes.forEach((index) => model.addIndex(index.name, index.getFields()));
        return model;
    }
    useVpc(vpcSchemaInspectorLambda, region) {
        this.useVPC = true;
        this.vpcSchemaInspectorLambda = vpcSchemaInspectorLambda;
        this.vpcLambdaRegion = region;
    }
    queryToCSV(queryResult) {
        if (queryResult.length === 0) {
            return '';
        }
        const headers = Object.keys(queryResult[0]);
        const headerIndices = Object.fromEntries(headers.map((key, index) => [index, key]));
        const rows = queryResult.map((row) => [...Array(headers.length).keys()]
            .map((index) => {
            const value = row[headerIndices[index]];
            if (typeof value === 'string' && value.includes(',')) {
                return `"${value}"`;
            }
            if (value === null) {
                return 'NULL';
            }
            return value;
        })
            .join(','));
        return headers.join(',') + os.EOL + rows.join(os.EOL);
    }
}
exports.DataSourceAdapter = DataSourceAdapter;
//# sourceMappingURL=datasource-adapter.js.map