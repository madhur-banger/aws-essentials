"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPostgresSchemaQuery = exports.PostgresDataSourceAdapter = void 0;
const knex_1 = require("knex");
const ora_1 = __importDefault(require("ora"));
const vpc_helper_1 = require("../utils/vpc-helper");
const utils_1 = require("../utils");
const datasource_adapter_1 = require("./datasource-adapter");
const pg_string_datasource_adapter_1 = require("./pg-string-datasource-adapter");
const spinner = (0, ora_1.default)();
class PostgresDataSourceAdapter extends datasource_adapter_1.DataSourceAdapter {
    constructor(config) {
        super();
        this.config = config;
    }
    async test() {
        const TEST_QUERY = 'SELECT 1';
        if (!this.dbBuilder) {
            this.establishDBConnection();
        }
        try {
            await this.dbBuilder.raw(TEST_QUERY);
        }
        catch (error) {
            return false;
        }
        return true;
    }
    async initialize() {
        spinner.start('Fetching the database schema...');
        try {
            await this.establishDBConnection();
            const schema = await this.querySchema();
            this.adapter = new pg_string_datasource_adapter_1.PostgresStringDataSourceAdapter(schema);
        }
        catch (error) {
            spinner.fail('Failed to fetch the database schema.');
            throw error;
        }
        spinner.succeed('Successfully fetched the database schema.');
    }
    establishDBConnection() {
        const databaseConfig = {
            host: this.config.host,
            database: this.config.database,
            port: this.config.port,
            user: this.config.username,
            password: this.config.password,
            ssl: (0, utils_1.getSSLConfig)(this.config.host, this.config.sslCertificate),
        };
        try {
            this.dbBuilder = (0, knex_1.knex)({
                client: 'pg',
                connection: databaseConfig,
                pool: {
                    min: 1,
                    max: 1,
                    createTimeoutMillis: 30000,
                    acquireTimeoutMillis: 30000,
                    idleTimeoutMillis: 30000,
                    reapIntervalMillis: 1000,
                    createRetryIntervalMillis: 100,
                },
                debug: false,
            });
        }
        catch (err) {
            console.info(err);
            throw err;
        }
    }
    getTablesList() {
        return this.adapter.getTablesList();
    }
    async querySchema() {
        const schemaQuery = getPostgresSchemaQuery(this.config.database);
        const result = this.useVPC && this.vpcSchemaInspectorLambda
            ? await (0, vpc_helper_1.invokeSchemaInspectorLambda)(this.vpcSchemaInspectorLambda, this.config, schemaQuery, this.vpcLambdaRegion)
            : (await this.dbBuilder.raw(schemaQuery)).rows;
        return this.queryToCSV(result);
    }
    getFields(tableName) {
        return this.adapter.getFields(tableName);
    }
    getPrimaryKey(tableName) {
        return this.adapter.getPrimaryKey(tableName);
    }
    getIndexes(tableName) {
        return this.adapter.getIndexes(tableName);
    }
    cleanup() {
        this.dbBuilder && this.dbBuilder.destroy();
    }
}
exports.PostgresDataSourceAdapter = PostgresDataSourceAdapter;
function getPostgresSchemaQuery(databaseName) {
    return `
SELECT DISTINCT
  INFORMATION_SCHEMA.COLUMNS.table_name,
  ${pg_string_datasource_adapter_1.expectedColumns.filter((column) => !(column === 'index_columns' || column === 'table_name')).join(',')},
  REPLACE(SUBSTRING(indexdef from '\\((.*)\\)'), '"', '') as index_columns
FROM INFORMATION_SCHEMA.COLUMNS
LEFT JOIN pg_indexes
ON
  INFORMATION_SCHEMA.COLUMNS.table_name = pg_indexes.tablename
  AND INFORMATION_SCHEMA.COLUMNS.column_name = ANY(STRING_TO_ARRAY(REPLACE(SUBSTRING(indexdef from '\\((.*)\\)'), '"', ''), ', '))
  LEFT JOIN (
    SELECT
      t.typname AS enum_name,
      ARRAY_AGG(e.enumlabel) as enum_values
    FROM    pg_type t JOIN
      pg_enum e ON t.oid = e.enumtypid JOIN
      pg_catalog.pg_namespace n ON n.oid = t.typnamespace
    WHERE   n.nspname = 'public'
    GROUP BY enum_name
  ) enums
  ON enums.enum_name = INFORMATION_SCHEMA.COLUMNS.udt_name
  LEFT JOIN information_schema.table_constraints
  ON INFORMATION_SCHEMA.table_constraints.constraint_name = indexname
  AND INFORMATION_SCHEMA.COLUMNS.table_name = INFORMATION_SCHEMA.table_constraints.table_name
WHERE INFORMATION_SCHEMA.COLUMNS.table_schema = 'public' AND INFORMATION_SCHEMA.COLUMNS.TABLE_CATALOG = '${databaseName}';
`;
}
exports.getPostgresSchemaQuery = getPostgresSchemaQuery;
//# sourceMappingURL=pg-datasource-adapter.js.map