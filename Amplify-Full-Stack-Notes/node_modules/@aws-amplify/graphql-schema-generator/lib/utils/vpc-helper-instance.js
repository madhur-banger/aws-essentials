"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkHostInDBInstances = void 0;
const client_rds_1 = require("@aws-sdk/client-rds");
const supported_db_engines_1 = require("./supported-db-engines");
const filter_subnet_availability_zones_1 = require("./filter-subnet-availability-zones");
const checkHostInDBInstances = async (hostname, region) => {
    const client = new client_rds_1.RDSClient({ region });
    const params = {
        Filters: [
            {
                Name: 'engine',
                Values: supported_db_engines_1.DB_ENGINES,
            },
        ],
    };
    const command = new client_rds_1.DescribeDBInstancesCommand(params);
    const response = await client.send(command);
    if (!response.DBInstances) {
        throw new Error('Error in fetching DB Instances');
    }
    const instance = response.DBInstances.find((dbInstance) => { var _a; return ((_a = dbInstance === null || dbInstance === void 0 ? void 0 : dbInstance.Endpoint) === null || _a === void 0 ? void 0 : _a.Address) === hostname; });
    if (!instance) {
        return undefined;
    }
    const subnetAvailabilityZones = instance === null || instance === void 0 ? void 0 : instance.DBSubnetGroup.Subnets.map((subnet) => {
        var _a;
        return {
            subnetId: subnet.SubnetIdentifier,
            availabilityZone: (_a = subnet.SubnetAvailabilityZone) === null || _a === void 0 ? void 0 : _a.Name,
        };
    });
    const subnetAvailabilityZoneConfig = (0, filter_subnet_availability_zones_1.filterSubnetAvailabilityZones)(subnetAvailabilityZones);
    const vpcId = instance.DBSubnetGroup.VpcId;
    const securityGroupIds = instance.VpcSecurityGroups.map((securityGroup) => securityGroup.VpcSecurityGroupId);
    return {
        vpcId,
        subnetAvailabilityZoneConfig,
        securityGroupIds,
    };
};
exports.checkHostInDBInstances = checkHostInDBInstances;
//# sourceMappingURL=vpc-helper-instance.js.map