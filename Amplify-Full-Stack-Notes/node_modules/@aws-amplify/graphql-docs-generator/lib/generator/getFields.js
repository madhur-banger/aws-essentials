"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const graphql_1 = require("graphql");
const getFragment_1 = require("./getFragment");
const getType_1 = require("./utils/getType");
const isS3Object_1 = require("./utils/isS3Object");
function getFields(field, schema, depth = 2, options) {
    const fieldType = (0, getType_1.default)(field.type);
    const renderS3FieldFragment = options.useExternalFragmentForS3Object && (0, isS3Object_1.default)(fieldType);
    const subFields = !renderS3FieldFragment && ((0, graphql_1.isObjectType)(fieldType) || (0, graphql_1.isInterfaceType)(fieldType)) ? fieldType.getFields() : [];
    const subFragments = (0, graphql_1.isInterfaceType)(fieldType) || (0, graphql_1.isUnionType)(fieldType) ? schema.getPossibleTypes(fieldType) : {};
    if (depth < 1 && !((0, graphql_1.isScalarType)(fieldType) || (0, graphql_1.isEnumType)(fieldType))) {
        return;
    }
    const fields = Object.keys(subFields)
        .map(fieldName => {
        const subField = subFields[fieldName];
        return getFields(subField, schema, adjustDepth(subField, depth), options);
    })
        .filter(f => f);
    // add __typename to selection set.
    // getFields() does not include __typename because __typename is implicitly included on all object types.
    // https://spec.graphql.org/June2018/#sec-Type-Name-Introspection
    // do not add to interface types or union types because they are not supported by the transformers
    if (options.typenameIntrospection && (0, graphql_1.isObjectType)(fieldType)) {
        fields.push({
            name: '__typename',
            fields: [],
            fragments: [],
            hasBody: false,
        });
    }
    const fragments = Object.keys(subFragments)
        .map(fragment => (0, getFragment_1.default)(subFragments[fragment], schema, depth, fields, null, false, options))
        .filter(f => f);
    // Special treatment for S3 input
    // Swift SDK needs S3 Object to have fragment
    if (renderS3FieldFragment) {
        fragments.push((0, getFragment_1.default)(fieldType, schema, depth, [], 'S3Object', true, options));
    }
    // if the current field is an object and none of the subfields are included, don't include the field itself
    if (!((0, graphql_1.isScalarType)(fieldType) || (0, graphql_1.isEnumType)(fieldType)) && fields.length === 0 && fragments.length === 0 && !renderS3FieldFragment) {
        return;
    }
    return {
        name: field.name,
        fields,
        fragments,
        hasBody: !!(fields.length || fragments.length),
    };
}
exports.default = getFields;
function adjustDepth(field, depth) {
    const maxDepth = 100;
    if (isGraphQLAggregateField(field) && depth < maxDepth) {
        return depth + 1;
    }
    else if (depth >= maxDepth) {
        throw new Error('Statement generation depth exceeded the maximum allowed limit');
    }
    return depth - 1;
}
function isGraphQLAggregateField(field) {
    if (field && field.name == 'aggregateItems' && getBaseType(field.type) == 'SearchableAggregateResult') {
        return true;
    }
    return false;
}
function getBaseType(type) {
    if (type && type.ofType) {
        return getBaseType(type.ofType);
    }
    return type === null || type === void 0 ? void 0 : type.name;
}
//# sourceMappingURL=getFields.js.map