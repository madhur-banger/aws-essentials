"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getResourceNamesForStrategyName = exports.getResourceNamesForStrategy = exports.getDefaultStrategyNameForDbType = exports.getResourceName = exports.setResourceName = void 0;
const resourceNameKey = 'graphqltransformer:resourceName';
const setResourceName = (scope, { name, setOnDefaultChild }) => {
    scope.node.addMetadata(resourceNameKey, name);
    if (setOnDefaultChild && scope.node.defaultChild && scope.node.defaultChild) {
        scope.node.defaultChild.node.addMetadata(resourceNameKey, name);
    }
};
exports.setResourceName = setResourceName;
const tryAndRetrieveResourceName = (metadata) => metadata.type === resourceNameKey && typeof metadata.data === 'string' ? metadata.data : undefined;
const isDefined = (x) => x !== undefined;
const getResourceName = (scope) => {
    const referencesWithName = scope.node.metadata.map(tryAndRetrieveResourceName).filter(isDefined);
    if (referencesWithName.length > 1)
        throw new Error('Multiple metadata entries specifying a resource name were found, expected 0 or 1.');
    return referencesWithName.length === 1 ? referencesWithName[0] : undefined;
};
exports.getResourceName = getResourceName;
const getDefaultStrategyNameForDbType = (dbType) => `${dbType}Strategy`;
exports.getDefaultStrategyNameForDbType = getDefaultStrategyNameForDbType;
const getResourceNamesForStrategy = (strategy) => (0, exports.getResourceNamesForStrategyName)(strategy.name);
exports.getResourceNamesForStrategy = getResourceNamesForStrategy;
const getResourceNamesForStrategyName = (strategyName) => {
    const sqlLambdaFunction = `SQLFunction${strategyName}`;
    const resourceNames = {
        sqlLambdaAliasLogicalId: `${sqlLambdaFunction}ProvConcurAlias`,
        sqlLambdaAliasName: 'PCAlias',
        sqlLambdaDataSource: `SQLLambdaDataSource${strategyName}`,
        sqlLambdaExecutionRole: `SQLLambdaRole${strategyName}`,
        sqlLambdaLayerVersion: `SQLLambdaLayerVersion${strategyName}`,
        sqlLambdaExecutionRolePolicy: `SQLLambdaRolePolicy${strategyName}`,
        sqlLambdaFunction,
        sqlLayerVersionMapping: `SQLLayerVersionMapping${strategyName}`,
        sqlSNSTopicArnMapping: `SQLSNSTopicArnMapping${strategyName}`,
        sqlLayerVersionResolverCustomResource: `SQLLayerVersionCustomResource${strategyName}`,
        sqlPatchingLambdaExecutionRole: `SQLPatchingLambdaRole${strategyName}`,
        sqlPatchingLambdaExecutionRolePolicy: `SQLPatchingLambdaRolePolicy${strategyName}`,
        sqlPatchingLambdaFunction: `SQLLambdaLayerPatchingFunction${strategyName}`,
        sqlPatchingSubscription: `SQLLambdaLayerPatchingSubscription${strategyName}`,
        sqlPatchingTopic: `SQLLambdaLayerPatchingTopic${strategyName}`,
        sqlSNSTopicARNResolverCustomResource: `SQLLambdaLayerPatchingTopicARNResolver${strategyName}`,
        sqlStack: `SQLApiStack${strategyName}`,
        sqlVpcEndpointPrefix: `SQLVpcEndpoint${strategyName}`,
    };
    return resourceNames;
};
exports.getResourceNamesForStrategyName = getResourceNamesForStrategyName;
//# sourceMappingURL=resource-name.js.map