"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.validateAuthModes = exports.validateModelSchema = exports.EXTRA_DIRECTIVES_DOCUMENT = exports.specifiedRules = void 0;
const language_1 = require("graphql/language");
const validation_1 = require("graphql/validation");
const buildASTSchema_1 = require("graphql/utilities/buildASTSchema");
const SingleFieldSubscriptionsRule_1 = require("graphql/validation/rules/SingleFieldSubscriptionsRule");
const KnownTypeNamesRule_1 = require("graphql/validation/rules/KnownTypeNamesRule");
const FragmentsOnCompositeTypesRule_1 = require("graphql/validation/rules/FragmentsOnCompositeTypesRule");
const VariablesAreInputTypesRule_1 = require("graphql/validation/rules/VariablesAreInputTypesRule");
const ScalarLeafsRule_1 = require("graphql/validation/rules/ScalarLeafsRule");
const FieldsOnCorrectTypeRule_1 = require("graphql/validation/rules/FieldsOnCorrectTypeRule");
const KnownDirectivesRule_1 = require("graphql/validation/rules/KnownDirectivesRule");
const KnownArgumentNamesRule_1 = require("graphql/validation/rules/KnownArgumentNamesRule");
const UniqueArgumentNamesRule_1 = require("graphql/validation/rules/UniqueArgumentNamesRule");
const ValuesOfCorrectTypeRule_1 = require("graphql/validation/rules/ValuesOfCorrectTypeRule");
const VariablesInAllowedPositionRule_1 = require("graphql/validation/rules/VariablesInAllowedPositionRule");
const OverlappingFieldsCanBeMergedRule_1 = require("graphql/validation/rules/OverlappingFieldsCanBeMergedRule");
const UniqueInputFieldNamesRule_1 = require("graphql/validation/rules/UniqueInputFieldNamesRule");
const ProvidedRequiredArgumentsRule_1 = require("graphql/validation/rules/ProvidedRequiredArgumentsRule");
const UniqueOperationNamesRule_1 = require("graphql/validation/rules/UniqueOperationNamesRule");
const LoneAnonymousOperationRule_1 = require("graphql/validation/rules/LoneAnonymousOperationRule");
const UniqueFragmentNamesRule_1 = require("graphql/validation/rules/UniqueFragmentNamesRule");
const KnownFragmentNamesRule_1 = require("graphql/validation/rules/KnownFragmentNamesRule");
const NoUnusedFragmentsRule_1 = require("graphql/validation/rules/NoUnusedFragmentsRule");
const PossibleFragmentSpreadsRule_1 = require("graphql/validation/rules/PossibleFragmentSpreadsRule");
const NoFragmentCyclesRule_1 = require("graphql/validation/rules/NoFragmentCyclesRule");
const UniqueVariableNamesRule_1 = require("graphql/validation/rules/UniqueVariableNamesRule");
const NoUndefinedVariablesRule_1 = require("graphql/validation/rules/NoUndefinedVariablesRule");
const NoUnusedVariablesRule_1 = require("graphql/validation/rules/NoUnusedVariablesRule");
const UniqueDirectivesPerLocationRule_1 = require("graphql/validation/rules/UniqueDirectivesPerLocationRule");
const validate_1 = require("graphql/validation/validate");
const graphql_directives_1 = require("@aws-amplify/graphql-directives");
exports.specifiedRules = [
    UniqueOperationNamesRule_1.UniqueOperationNamesRule,
    LoneAnonymousOperationRule_1.LoneAnonymousOperationRule,
    SingleFieldSubscriptionsRule_1.SingleFieldSubscriptionsRule,
    KnownTypeNamesRule_1.KnownTypeNamesRule,
    FragmentsOnCompositeTypesRule_1.FragmentsOnCompositeTypesRule,
    VariablesAreInputTypesRule_1.VariablesAreInputTypesRule,
    ScalarLeafsRule_1.ScalarLeafsRule,
    FieldsOnCorrectTypeRule_1.FieldsOnCorrectTypeRule,
    UniqueFragmentNamesRule_1.UniqueFragmentNamesRule,
    KnownFragmentNamesRule_1.KnownFragmentNamesRule,
    NoUnusedFragmentsRule_1.NoUnusedFragmentsRule,
    PossibleFragmentSpreadsRule_1.PossibleFragmentSpreadsRule,
    NoFragmentCyclesRule_1.NoFragmentCyclesRule,
    UniqueVariableNamesRule_1.UniqueVariableNamesRule,
    NoUndefinedVariablesRule_1.NoUndefinedVariablesRule,
    NoUnusedVariablesRule_1.NoUnusedVariablesRule,
    KnownDirectivesRule_1.KnownDirectivesRule,
    UniqueDirectivesPerLocationRule_1.UniqueDirectivesPerLocationRule,
    KnownArgumentNamesRule_1.KnownArgumentNamesRule,
    UniqueArgumentNamesRule_1.UniqueArgumentNamesRule,
    ValuesOfCorrectTypeRule_1.ValuesOfCorrectTypeRule,
    ProvidedRequiredArgumentsRule_1.ProvidedRequiredArgumentsRule,
    VariablesInAllowedPositionRule_1.VariablesInAllowedPositionRule,
    OverlappingFieldsCanBeMergedRule_1.OverlappingFieldsCanBeMergedRule,
    UniqueInputFieldNamesRule_1.UniqueInputFieldNamesRule,
];
const EXTRA_SCALARS_DOCUMENT = (0, language_1.parse)(`
scalar AWSDate
scalar AWSTime
scalar AWSDateTime
scalar AWSTimestamp
scalar AWSEmail
scalar AWSJSON
scalar AWSURL
scalar AWSPhone
scalar AWSIPAddress
scalar BigInt
scalar Double
`);
exports.EXTRA_DIRECTIVES_DOCUMENT = (0, language_1.parse)([
    graphql_directives_1.AwsSubscribeDirective.definition,
    graphql_directives_1.AwsAuthDirective.definition,
    graphql_directives_1.AwsApiKeyDirective.definition,
    graphql_directives_1.AwsIamDirective.definition,
    graphql_directives_1.AwsOidcDirective.definition,
    graphql_directives_1.AwsCognitoUserPoolsDirective.definition,
    graphql_directives_1.AwsLambdaDirective.definition,
    graphql_directives_1.DeprecatedDirective.definition,
].join('\n'));
const NOOP_QUERY = (0, language_1.parse)(`
type Query {
  noop: String
}
`);
const validateModelSchema = (doc) => {
    const fullDocument = {
        kind: language_1.Kind.DOCUMENT,
        definitions: [...exports.EXTRA_DIRECTIVES_DOCUMENT.definitions, ...doc.definitions, ...EXTRA_SCALARS_DOCUMENT.definitions],
    };
    const schemaDef = doc.definitions.find((d) => d.kind === language_1.Kind.SCHEMA_DEFINITION);
    const queryOperation = schemaDef ? schemaDef.operationTypes.find((o) => o.operation === 'query') : undefined;
    const queryName = queryOperation ? queryOperation.type.name.value : 'Query';
    const existingQueryType = doc.definitions.find((d) => d.kind !== language_1.Kind.DIRECTIVE_DEFINITION && d.kind !== language_1.Kind.SCHEMA_DEFINITION && d.name && d.name.value === queryName);
    if (!existingQueryType) {
        fullDocument.definitions.push(...NOOP_QUERY.definitions);
    }
    let schema;
    const errors = (0, validate_1.validateSDL)(fullDocument);
    if (errors.length > 0) {
        return errors;
    }
    schema = (0, buildASTSchema_1.buildASTSchema)(fullDocument, { assumeValid: true });
    return (0, validation_1.validate)(schema, fullDocument, exports.specifiedRules);
};
exports.validateModelSchema = validateModelSchema;
const validateAuthModes = (authConfig) => {
    let additionalAuthModes = [];
    if (authConfig.additionalAuthenticationProviders) {
        additionalAuthModes = authConfig.additionalAuthenticationProviders.map((p) => p.authenticationType).filter((t) => !!t);
    }
    const authModes = [...additionalAuthModes, authConfig.defaultAuthentication.authenticationType];
    for (let i = 0; i < authModes.length; i++) {
        const mode = authModes[i];
        if (mode !== 'API_KEY' &&
            mode !== 'AMAZON_COGNITO_USER_POOLS' &&
            mode !== 'AWS_IAM' &&
            mode !== 'OPENID_CONNECT' &&
            mode !== 'AWS_LAMBDA') {
            throw new Error(`Invalid auth mode ${mode}`);
        }
    }
};
exports.validateAuthModes = validateAuthModes;
//# sourceMappingURL=validation.js.map