"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.constructSqlDirectiveDataSourceStrategies = exports.constructDataSourceStrategies = exports.getModelTypeNames = exports.removeAmplifyInputDefinition = exports.sortTransformerPlugins = exports.matchEnumValueDirective = exports.matchArgumentDirective = exports.matchInputFieldDirective = exports.matchFieldDirective = exports.matchDirective = exports.makeSeenTransformationKey = void 0;
const graphql_1 = require("graphql");
const graphql_transformer_interfaces_1 = require("@aws-amplify/graphql-transformer-interfaces");
const lodash_1 = __importDefault(require("lodash"));
const utils_1 = require("../utils");
const makeSeenTransformationKey = (directive, type, field, arg, index) => {
    let key = '';
    if (directive && type && field && arg) {
        key = `${type.name.value}.${field.name.value}.${arg.name.value}@${directive.name.value}`;
    }
    if (directive && type && field) {
        key = `${type.name.value}.${field.name.value}@${directive.name.value}`;
    }
    else {
        key = `${type.name.value}@${directive.name.value}`;
    }
    if (index !== undefined) {
        key += `[${index}]`;
    }
    return key;
};
exports.makeSeenTransformationKey = makeSeenTransformationKey;
const matchDirective = (definition, directive, node) => {
    if (!directive) {
        return false;
    }
    if (definition.name.value !== directive.name.value) {
        return false;
    }
    let isValidLocation = false;
    for (const location of definition.locations) {
        switch (location.value) {
            case 'SCHEMA':
                isValidLocation = node.kind === graphql_1.Kind.SCHEMA_DEFINITION || isValidLocation;
                break;
            case 'SCALAR':
                isValidLocation = node.kind === graphql_1.Kind.SCALAR_TYPE_DEFINITION || isValidLocation;
                break;
            case 'OBJECT':
                isValidLocation = node.kind === graphql_1.Kind.OBJECT_TYPE_DEFINITION || isValidLocation;
                break;
            case 'FIELD_DEFINITION':
                isValidLocation = node.kind === graphql_1.Kind.FIELD_DEFINITION || isValidLocation;
                break;
            case 'ARGUMENT_DEFINITION':
                isValidLocation = node.kind === graphql_1.Kind.INPUT_VALUE_DEFINITION || isValidLocation;
                break;
            case 'INTERFACE':
                isValidLocation = node.kind === graphql_1.Kind.INTERFACE_TYPE_DEFINITION || isValidLocation;
                break;
            case 'UNION':
                isValidLocation = node.kind === graphql_1.Kind.UNION_TYPE_DEFINITION || isValidLocation;
                break;
            case 'ENUM':
                isValidLocation = node.kind === graphql_1.Kind.ENUM_TYPE_DEFINITION || isValidLocation;
                break;
            case 'ENUM_VALUE':
                isValidLocation = node.kind === graphql_1.Kind.ENUM_VALUE_DEFINITION || isValidLocation;
                break;
            case 'INPUT_OBJECT':
                isValidLocation = node.kind === graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION || isValidLocation;
                break;
            case 'INPUT_FIELD_DEFINITION':
                isValidLocation = node.kind === graphql_1.Kind.INPUT_VALUE_DEFINITION || isValidLocation;
                break;
            default:
                break;
        }
    }
    return isValidLocation;
};
exports.matchDirective = matchDirective;
const matchFieldDirective = (definition, directive, node) => {
    if (definition.name.value !== directive.name.value) {
        return false;
    }
    let isValidLocation = false;
    for (const location of definition.locations) {
        switch (location.value) {
            case 'FIELD_DEFINITION':
                isValidLocation = node.kind === graphql_1.Kind.FIELD_DEFINITION || isValidLocation;
                break;
            default:
                break;
        }
    }
    return isValidLocation;
};
exports.matchFieldDirective = matchFieldDirective;
const matchInputFieldDirective = (definition, directive, node) => {
    if (definition.name.value !== directive.name.value) {
        return false;
    }
    let isValidLocation = false;
    for (const location of definition.locations) {
        switch (location.value) {
            case 'INPUT_FIELD_DEFINITION':
                isValidLocation = node.kind === graphql_1.Kind.INPUT_VALUE_DEFINITION || isValidLocation;
                break;
            default:
                break;
        }
    }
    return isValidLocation;
};
exports.matchInputFieldDirective = matchInputFieldDirective;
const matchArgumentDirective = (definition, directive, node) => {
    if (definition.name.value !== directive.name.value) {
        return false;
    }
    let isValidLocation = false;
    for (const location of definition.locations) {
        switch (location.value) {
            case 'ARGUMENT_DEFINITION':
                isValidLocation = node.kind === graphql_1.Kind.INPUT_VALUE_DEFINITION || isValidLocation;
                break;
            default:
                break;
        }
    }
    return isValidLocation;
};
exports.matchArgumentDirective = matchArgumentDirective;
const matchEnumValueDirective = (definition, directive, node) => {
    if (definition.name.value !== directive.name.value) {
        return false;
    }
    let isValidLocation = false;
    for (const location of definition.locations) {
        switch (location.value) {
            case 'ENUM_VALUE':
                isValidLocation = node.kind === graphql_1.Kind.ENUM_VALUE_DEFINITION || isValidLocation;
                break;
            default:
                break;
        }
    }
    return isValidLocation;
};
exports.matchEnumValueDirective = matchEnumValueDirective;
const sortTransformerPlugins = (plugins) => {
    const SORT_ORDER = [
        graphql_transformer_interfaces_1.TransformerPluginType.DATA_SOURCE_PROVIDER,
        graphql_transformer_interfaces_1.TransformerPluginType.DATA_SOURCE_ENHANCER,
        graphql_transformer_interfaces_1.TransformerPluginType.GENERIC,
        graphql_transformer_interfaces_1.TransformerPluginType.AUTH,
    ];
    return plugins.sort((a, b) => {
        const aIdx = SORT_ORDER.indexOf(a.pluginType);
        const bIdx = SORT_ORDER.indexOf(b.pluginType);
        return aIdx - bIdx;
    });
};
exports.sortTransformerPlugins = sortTransformerPlugins;
const removeAmplifyInputDefinition = (schema) => {
    if (lodash_1.default.isEmpty(schema)) {
        return schema;
    }
    const { definitions, ...rest } = (0, graphql_1.parse)(schema);
    const isAmplifyInputNode = (definition) => definition.kind === 'InputObjectTypeDefinition' && definition.name.value === 'Amplify';
    return (0, graphql_1.print)({
        definitions: definitions.filter((definition) => !isAmplifyInputNode(definition)),
        ...rest,
    });
};
exports.removeAmplifyInputDefinition = removeAmplifyInputDefinition;
const MODEL_DIRECTIVE_NAME = 'model';
const MANY_TO_MANY_DIRECTIVE_NAME = 'manyToMany';
const getModelTypeNames = (schema) => {
    const parsedSchema = (0, graphql_1.parse)(schema);
    const nodesWithModelDirective = parsedSchema.definitions.filter((obj) => { var _a; return obj.kind === graphql_1.Kind.OBJECT_TYPE_DEFINITION && ((_a = obj.directives) === null || _a === void 0 ? void 0 : _a.some((dir) => dir.name.value === MODEL_DIRECTIVE_NAME)); });
    const modelKeys = nodesWithModelDirective.map((type) => type.name.value);
    nodesWithModelDirective.forEach((obj) => {
        const { fields } = obj;
        fields === null || fields === void 0 ? void 0 : fields.forEach((field) => {
            var _a;
            (_a = field.directives) === null || _a === void 0 ? void 0 : _a.forEach((dir) => {
                var _a;
                if (dir.name.value === MANY_TO_MANY_DIRECTIVE_NAME) {
                    const relationArg = (_a = dir.arguments) === null || _a === void 0 ? void 0 : _a.find((arg) => arg.name.value === 'relationName');
                    if (relationArg) {
                        modelKeys.push(relationArg.value.value);
                    }
                }
            });
        });
    });
    return modelKeys.filter((key, idx) => modelKeys.indexOf(key) === idx);
};
exports.getModelTypeNames = getModelTypeNames;
const constructDataSourceStrategies = (schema, dataSourceStrategy) => {
    const modelKeys = (0, exports.getModelTypeNames)(schema);
    return modelKeys.reduce((acc, cur) => ({ ...acc, [cur]: dataSourceStrategy }), {});
};
exports.constructDataSourceStrategies = constructDataSourceStrategies;
const constructSqlDirectiveDataSourceStrategies = (schema, dataSourceStrategy, customSqlStatements) => {
    if (!(0, utils_1.isSqlStrategy)(dataSourceStrategy)) {
        return [];
    }
    const parsedSchema = (0, graphql_1.parse)(schema);
    const queryNode = parsedSchema.definitions.find(utils_1.isQueryNode);
    const mutationNode = parsedSchema.definitions.find(utils_1.isMutationNode);
    if (!queryNode && !mutationNode) {
        return [];
    }
    const sqlDirectiveDataSourceStrategies = [];
    if (queryNode) {
        const fields = (0, utils_1.fieldsWithSqlDirective)(queryNode);
        for (const field of fields) {
            sqlDirectiveDataSourceStrategies.push({
                typeName: 'Query',
                fieldName: field.name.value,
                strategy: dataSourceStrategy,
                customSqlStatements,
            });
        }
    }
    if (mutationNode) {
        const fields = (0, utils_1.fieldsWithSqlDirective)(mutationNode);
        for (const field of fields) {
            sqlDirectiveDataSourceStrategies.push({
                typeName: 'Mutation',
                fieldName: field.name.value,
                strategy: dataSourceStrategy,
                customSqlStatements,
            });
        }
    }
    return sqlDirectiveDataSourceStrategies;
};
exports.constructSqlDirectiveDataSourceStrategies = constructSqlDirectiveDataSourceStrategies;
//# sourceMappingURL=utils.js.map