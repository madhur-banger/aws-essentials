"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateJSONSchemaFromTypeNode = void 0;
const graphql_1 = require("graphql");
const graphql_transformer_common_1 = require("graphql-transformer-common");
const graphql_transformer_core_1 = require("@aws-amplify/graphql-transformer-core");
function generateJSONSchemaFromTypeNode(typeNode, ctx, schema = { type: '' }) {
    switch (typeNode.kind) {
        case graphql_1.Kind.NAMED_TYPE:
            return handleNamedType(typeNode, ctx, schema);
        case graphql_1.Kind.NON_NULL_TYPE:
            return handleNonNullType(typeNode, ctx, schema);
        case graphql_1.Kind.LIST_TYPE:
            return handleListType(typeNode, ctx, schema);
    }
}
exports.generateJSONSchemaFromTypeNode = generateJSONSchemaFromTypeNode;
function handleNamedType(typeNode, ctx, schema) {
    const namedTypeSchema = (0, graphql_transformer_core_1.convertNamedTypeToJSONSchema)(typeNode);
    Object.assign(schema, namedTypeSchema);
    if ((0, graphql_transformer_common_1.isScalar)(typeNode)) {
        return schema;
    }
    const baseTypeName = (0, graphql_transformer_common_1.getBaseType)(typeNode);
    const typeDef = ctx.output.getType(baseTypeName);
    if (!typeDef) {
        throw new Error(`Type ${baseTypeName} not found`);
    }
    schema.properties = generateJSONSchemaForDefinitionNode(typeDef, schema, ctx);
    return schema;
}
const handleNonNullType = (typeNode, ctx, schema) => {
    const baseType = (0, graphql_transformer_common_1.getBaseType)(typeNode);
    if ((0, graphql_transformer_core_1.isDisallowedScalarType)(baseType)) {
        throw new Error(`
      Disallowed required field type ${baseType}.
      Use one of the supported scalar types for generation routes: [${graphql_transformer_core_1.supportedScalarTypes.join(', ')}]
    `);
    }
    return generateJSONSchemaFromTypeNode(typeNode.type, ctx, schema);
};
const handleListType = (typeNode, ctx, schema) => {
    return {
        type: 'array',
        items: generateJSONSchemaFromTypeNode(typeNode.type, ctx, schema),
    };
};
function generateJSONSchemaForDefinitionNode(def, schema, ctx) {
    switch (def.kind) {
        case 'InputObjectTypeDefinition':
            return handleInputObjectDefinition(def, schema, ctx);
        case 'EnumTypeDefinition':
            return handleEnumDefinition(def);
        default:
            throw new Error(`Unsupported type definition: ${def.kind}`);
    }
}
function handleInputObjectDefinition(def, schema, ctx) {
    var _a;
    const properties = (_a = def.fields) === null || _a === void 0 ? void 0 : _a.reduce((acc, field) => {
        acc[field.name.value] = generateJSONSchemaFromTypeNode(field.type, ctx, { type: '' });
        if (field.type.kind === graphql_1.Kind.NON_NULL_TYPE) {
            schema.required = [...(schema.required || []), field.name.value];
        }
        return acc;
    }, {});
    if (!properties) {
        throw new Error(`Object type ${def.name.value} has no fields`);
    }
    return properties;
}
function handleEnumDefinition(def) {
    var _a;
    return {
        [def.name.value]: {
            type: 'string',
            enum: (_a = def.values) === null || _a === void 0 ? void 0 : _a.map((value) => value.name.value),
        },
    };
}
//# sourceMappingURL=graphql-json-schema-type.js.map