"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SearchableModelTransformer = void 0;
const graphql_transformer_core_1 = require("@aws-amplify/graphql-transformer-core");
const graphql_directives_1 = require("@aws-amplify/graphql-directives");
const aws_cdk_lib_1 = require("aws-cdk-lib");
const graphql_mapping_template_1 = require("graphql-mapping-template");
const graphql_transformer_common_1 = require("graphql-transformer-common");
const create_cfnParameters_1 = require("./cdk/create-cfnParameters");
const generate_resolver_vtl_1 = require("./generate-resolver-vtl");
const definitions_1 = require("./definitions");
const create_layer_cfnMapping_1 = require("./cdk/create-layer-cfnMapping");
const create_searchable_domain_1 = require("./cdk/create-searchable-domain");
const create_searchable_datasource_1 = require("./cdk/create-searchable-datasource");
const create_streaming_lambda_1 = require("./cdk/create-streaming-lambda");
const create_cfnOutput_1 = require("./cdk/create-cfnOutput");
const nonKeywordTypes = ['Int', 'Float', 'Boolean', 'AWSTimestamp', 'AWSDate', 'AWSDateTime'];
const STACK_NAME = 'SearchableStack';
const API_KEY_DIRECTIVE = 'aws_api_key';
const AWS_IAM_DIRECTIVE = 'aws_iam';
const getTable = (context, definition) => {
    const ddbDataSource = context.dataSources.get(definition);
    const tableName = graphql_transformer_common_1.ModelResourceIDs.ModelTableResourceID(definition.name.value);
    const table = ddbDataSource.ds.stack.node.findChild(tableName);
    return table;
};
const getNonKeywordFields = (def) => {
    var _a;
    const nonKeywordTypeSet = new Set(nonKeywordTypes);
    return (((_a = def.fields) === null || _a === void 0 ? void 0 : _a.filter((field) => nonKeywordTypeSet.has((0, graphql_transformer_common_1.getBaseType)(field.type)) && !definitions_1.DATASTORE_SYNC_FIELDS.includes(field.name.value)).map((field) => (0, graphql_mapping_template_1.str)(field.name.value))) || []);
};
const getKeyFields = (primaryKey, table) => {
    const keyFields = [];
    keyFields.push(primaryKey);
    const { attributeName } = table.keySchema.find((att) => att.keyType === 'RANGE') || {};
    if (attributeName) {
        keyFields.push(...attributeName.split('#'));
    }
    return keyFields.map((key) => (0, graphql_mapping_template_1.str)(key));
};
const generateSearchableXConnectionType = (ctx, definition) => {
    const searchableXConnectionName = `Searchable${definition.name.value}Connection`;
    if (ctx.output.hasType(searchableXConnectionName)) {
        return;
    }
    const connectionType = (0, graphql_transformer_common_1.blankObject)(searchableXConnectionName);
    ctx.output.addObject(connectionType);
    let connectionTypeExtension = (0, graphql_transformer_common_1.blankObjectExtension)(searchableXConnectionName);
    connectionTypeExtension = (0, graphql_transformer_common_1.extensionWithFields)(connectionTypeExtension, [
        (0, graphql_transformer_common_1.makeField)('items', [], (0, graphql_transformer_common_1.makeNonNullType)((0, graphql_transformer_common_1.makeListType)((0, graphql_transformer_common_1.makeNamedType)(definition.name.value)))),
    ]);
    connectionTypeExtension = (0, graphql_transformer_common_1.extensionWithFields)(connectionTypeExtension, [
        (0, graphql_transformer_common_1.makeField)('nextToken', [], (0, graphql_transformer_common_1.makeNamedType)('String')),
        (0, graphql_transformer_common_1.makeField)('total', [], (0, graphql_transformer_common_1.makeNamedType)('Int')),
        (0, graphql_transformer_common_1.makeField)('aggregateItems', [], (0, graphql_transformer_common_1.makeNonNullType)((0, graphql_transformer_common_1.makeListType)((0, graphql_transformer_common_1.makeNamedType)('SearchableAggregateResult')))),
    ]);
    ctx.output.addObjectExtension(connectionTypeExtension);
};
const generateSearchableAggregateScalarResultType = (ctx) => {
    const searchableAggregateScalarResult = 'SearchableAggregateScalarResult';
    if (ctx.output.hasType(searchableAggregateScalarResult)) {
        return searchableAggregateScalarResult;
    }
    const aggregateScalarType = (0, graphql_transformer_common_1.blankObject)(searchableAggregateScalarResult);
    ctx.output.addObject(aggregateScalarType);
    let aggregateScalarTypeExtension = (0, graphql_transformer_common_1.blankObjectExtension)(searchableAggregateScalarResult);
    aggregateScalarTypeExtension = (0, graphql_transformer_common_1.extensionWithFields)(aggregateScalarTypeExtension, [
        (0, graphql_transformer_common_1.makeField)('value', [], (0, graphql_transformer_common_1.makeNonNullType)((0, graphql_transformer_common_1.makeNamedType)('Float'))),
    ]);
    ctx.output.addObjectExtension(aggregateScalarTypeExtension);
    return searchableAggregateScalarResult;
};
const generateSearchableAggregateBucketResultItemType = (ctx) => {
    const searchableAggregateBucketResultItem = 'SearchableAggregateBucketResultItem';
    if (ctx.output.hasType(searchableAggregateBucketResultItem)) {
        return searchableAggregateBucketResultItem;
    }
    const aggregateBucketResultItemType = (0, graphql_transformer_common_1.blankObject)(searchableAggregateBucketResultItem);
    ctx.output.addObject(aggregateBucketResultItemType);
    let aggregateBucketResultItemTypeExtension = (0, graphql_transformer_common_1.blankObjectExtension)(searchableAggregateBucketResultItem);
    aggregateBucketResultItemTypeExtension = (0, graphql_transformer_common_1.extensionWithFields)(aggregateBucketResultItemTypeExtension, [
        (0, graphql_transformer_common_1.makeField)('key', [], (0, graphql_transformer_common_1.makeNonNullType)((0, graphql_transformer_common_1.makeNamedType)('String'))),
        (0, graphql_transformer_common_1.makeField)('doc_count', [], (0, graphql_transformer_common_1.makeNonNullType)((0, graphql_transformer_common_1.makeNamedType)('Int'))),
    ]);
    ctx.output.addObjectExtension(aggregateBucketResultItemTypeExtension);
    return searchableAggregateBucketResultItem;
};
const generateSearchableAggregateBucketResultType = (ctx) => {
    const searchableAggregateBucketResult = 'SearchableAggregateBucketResult';
    if (ctx.output.hasType(searchableAggregateBucketResult)) {
        return searchableAggregateBucketResult;
    }
    const aggregateBucketResultType = (0, graphql_transformer_common_1.blankObject)(searchableAggregateBucketResult);
    ctx.output.addObject(aggregateBucketResultType);
    generateSearchableAggregateBucketResultItemType(ctx);
    let aggregateBucketResultTypeExtension = (0, graphql_transformer_common_1.blankObjectExtension)(searchableAggregateBucketResult);
    aggregateBucketResultTypeExtension = (0, graphql_transformer_common_1.extensionWithFields)(aggregateBucketResultTypeExtension, [
        (0, graphql_transformer_common_1.makeField)('buckets', [], (0, graphql_transformer_common_1.makeListType)((0, graphql_transformer_common_1.makeNamedType)('SearchableAggregateBucketResultItem'))),
    ]);
    ctx.output.addObjectExtension(aggregateBucketResultTypeExtension);
    return searchableAggregateBucketResult;
};
const generateSearchableGenericResultType = (ctx) => {
    const searchableAggregateGenericResult = 'SearchableAggregateGenericResult';
    if (ctx.output.hasType(searchableAggregateGenericResult)) {
        return;
    }
    const searchableAggregateGenericResultNode = (0, graphql_transformer_common_1.defineUnionType)(searchableAggregateGenericResult, [
        (0, graphql_transformer_common_1.makeNamedType)(generateSearchableAggregateScalarResultType(ctx)),
        (0, graphql_transformer_common_1.makeNamedType)(generateSearchableAggregateBucketResultType(ctx)),
    ]);
    ctx.output.addUnion(searchableAggregateGenericResultNode);
};
const generateSearchableAggregateResultType = (ctx) => {
    const searchableAggregateResult = 'SearchableAggregateResult';
    if (ctx.output.hasType(searchableAggregateResult)) {
        return searchableAggregateResult;
    }
    const aggregateResultType = (0, graphql_transformer_common_1.blankObject)(searchableAggregateResult);
    ctx.output.addObject(aggregateResultType);
    let aggregateResultTypeExtension = (0, graphql_transformer_common_1.blankObjectExtension)(searchableAggregateResult);
    aggregateResultTypeExtension = (0, graphql_transformer_common_1.extensionWithFields)(aggregateResultTypeExtension, [
        (0, graphql_transformer_common_1.makeField)('name', [], (0, graphql_transformer_common_1.makeNonNullType)((0, graphql_transformer_common_1.makeNamedType)('String'))),
        (0, graphql_transformer_common_1.makeField)('result', [], (0, graphql_transformer_common_1.makeNamedType)('SearchableAggregateGenericResult')),
    ]);
    ctx.output.addObjectExtension(aggregateResultTypeExtension);
    return searchableAggregateResult;
};
const generateSearchableAggregateTypes = (ctx) => {
    generateSearchableAggregateResultType(ctx);
    generateSearchableGenericResultType(ctx);
};
const generateSearchableInputs = (ctx, definition) => {
    const inputs = Object.keys(graphql_transformer_common_1.STANDARD_SCALARS);
    inputs
        .filter((input) => !ctx.output.hasType(`Searchable${input}FilterInput`))
        .map(definitions_1.makeSearchableScalarInputObject)
        .forEach((node) => ctx.output.addInput(node));
    const searchableXQueryFilterInput = (0, definitions_1.makeSearchableXFilterInputObject)(definition, ctx.inputDocument);
    if (!ctx.output.hasType(searchableXQueryFilterInput.name.value)) {
        ctx.output.addInput(searchableXQueryFilterInput);
    }
    if (!ctx.output.hasType('SearchableSortDirection')) {
        const searchableSortDirection = (0, definitions_1.makeSearchableSortDirectionEnumObject)();
        ctx.output.addEnum(searchableSortDirection);
    }
    if (!ctx.output.hasType(`Searchable${definition.name.value}SortableFields`)) {
        const searchableXSortableFieldsDirection = (0, definitions_1.makeSearchableXSortableFieldsEnumObject)(definition);
        ctx.output.addEnum(searchableXSortableFieldsDirection);
    }
    if (!ctx.output.hasType(`Searchable${definition.name.value}SortInput`)) {
        const searchableXSortableInputDirection = (0, definitions_1.makeSearchableXSortInputObject)(definition);
        ctx.output.addInput(searchableXSortableInputDirection);
    }
    if (!ctx.output.hasType('SearchableAggregateType')) {
        const searchableAggregateTypeEnum = (0, definitions_1.makeSearchableAggregateTypeEnumObject)();
        ctx.output.addEnum(searchableAggregateTypeEnum);
    }
    if (!ctx.output.hasType(`Searchable${definition.name.value}AggregateField`)) {
        const searchableXAggregationField = (0, definitions_1.makeSearchableXAggregateFieldEnumObject)(definition, ctx.inputDocument);
        ctx.output.addEnum(searchableXAggregationField);
    }
    if (!ctx.output.hasType(`Searchable${definition.name.value}AggregationInput`)) {
        const searchableXAggregationInput = (0, definitions_1.makeSearchableXAggregationInputObject)(definition);
        ctx.output.addInput(searchableXAggregationInput);
    }
};
class SearchableModelTransformer extends graphql_transformer_core_1.TransformerPluginBase {
    constructor() {
        super('amplify-searchable-transformer', graphql_directives_1.SearchableDirective.definition);
        this.generateResolvers = (context) => {
            var _a, _b;
            if (!this.isSearchableConfigured()) {
                return;
            }
            if (!context.transformParameters.allowGen1Patterns) {
                aws_cdk_lib_1.Annotations.of(context.api).addWarning(`@${graphql_directives_1.SearchableDirective.name} is deprecated. This functionality will be removed in the next major release.`);
            }
            const { HasEnvironmentParameter } = graphql_transformer_common_1.ResourceConstants.CONDITIONS;
            const stack = context.stackManager.createStack(STACK_NAME);
            (0, create_layer_cfnMapping_1.setMappings)(stack);
            new aws_cdk_lib_1.CfnCondition(stack, HasEnvironmentParameter, {
                expression: aws_cdk_lib_1.Fn.conditionNot(aws_cdk_lib_1.Fn.conditionEquals(context.synthParameters.amplifyEnvironmentName, graphql_transformer_common_1.ResourceConstants.NONE)),
            });
            const isProjectUsingDataStore = context.isProjectUsingDataStore();
            stack.templateOptions.description = 'An auto-generated nested stack for searchable.';
            stack.templateOptions.templateFormatVersion = '2010-09-09';
            const parameterMap = (0, create_cfnParameters_1.createParametersStack)(context.stackManager.scope);
            const domain = (0, create_searchable_domain_1.createSearchableDomain)(stack, parameterMap, context.api.apiId, context.transformParameters.enableSearchNodeToNodeEncryption);
            const openSearchRole = (0, create_searchable_domain_1.createSearchableDomainRole)(context, stack, parameterMap);
            domain.grantReadWrite(openSearchRole);
            const { region } = stack.splitArn(domain.domainArn, aws_cdk_lib_1.ArnFormat.SLASH_RESOURCE_NAME);
            if (!region) {
                throw new Error('Could not access region from search domain');
            }
            const datasource = (0, create_searchable_datasource_1.createSearchableDataSource)(stack, context.api, domain.domainEndpoint, openSearchRole, region);
            const lambdaRole = (0, create_streaming_lambda_1.createLambdaRole)(context, stack, parameterMap);
            domain.grantWrite(lambdaRole);
            const lambda = (0, create_streaming_lambda_1.createLambda)(stack, context.api, parameterMap, lambdaRole, domain.domainEndpoint, isProjectUsingDataStore, region);
            for (const def of this.searchableObjectTypeDefinitions) {
                const type = def.node.name.value;
                const openSearchIndexName = context.resourceHelper.getModelNameMapping(type);
                const fields = (_b = (_a = def.node.fields) === null || _a === void 0 ? void 0 : _a.map((f) => f.name.value)) !== null && _b !== void 0 ? _b : [];
                const typeName = context.output.getQueryTypeName();
                const table = getTable(context, def.node);
                const ddbTable = table;
                if (!ddbTable) {
                    throw new Error('Failed to find ddb table for searchable');
                }
                ddbTable.grantStreamRead(lambdaRole);
                if (!ddbTable.tableStreamArn) {
                    throw new Error('tableStreamArn is required on ddb table ot create event source mappings');
                }
                (0, create_streaming_lambda_1.createEventSourceMapping)(stack, openSearchIndexName, lambda, parameterMap, ddbTable.tableStreamArn);
                const { attributeName } = table.keySchema.find((att) => att.keyType === 'HASH');
                const keyFields = getKeyFields(attributeName, table);
                if (!typeName) {
                    throw new Error('Query type name not found');
                }
                const resolver = context.resolvers.generateQueryResolver(typeName, def.fieldName, graphql_transformer_common_1.ResolverResourceIDs.ElasticsearchSearchResolverResourceID(type), datasource, graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString((0, generate_resolver_vtl_1.requestTemplate)(attributeName, getNonKeywordFields(context.output.getObject(type)), context.isProjectUsingDataStore(), openSearchIndexName, keyFields), `${typeName}.${def.fieldName}.req.vtl`), graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString((0, generate_resolver_vtl_1.responseTemplate)(context.isProjectUsingDataStore()), `${typeName}.${def.fieldName}.res.vtl`));
                resolver.addVtlFunctionToSlot('postAuth', graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString((0, generate_resolver_vtl_1.postAuthMappingTemplate)(context.transformParameters.sandboxModeEnabled, context.synthParameters.enableIamAccess, fields), `${typeName}.${def.fieldName}.{slotName}.{slotIndex}.res.vtl`));
                resolver.setScope(stack);
                context.resolvers.addResolver(typeName, def.fieldName, resolver);
            }
            if (context.transformParameters.enableTransformerCfnOutputs) {
                (0, create_cfnOutput_1.createStackOutputs)(stack, domain.domainEndpoint, context.api.apiId, domain.domainArn);
            }
        };
        this.object = (definition, directive, ctx) => {
            var _a, _b, _c;
            const modelDirective = (_a = definition === null || definition === void 0 ? void 0 : definition.directives) === null || _a === void 0 ? void 0 : _a.find((dir) => dir.name.value === 'model');
            const hasAuth = (_c = (_b = definition.directives) === null || _b === void 0 ? void 0 : _b.some((dir) => dir.name.value === 'auth')) !== null && _c !== void 0 ? _c : false;
            if (!modelDirective) {
                throw new graphql_transformer_core_1.InvalidDirectiveError('Types annotated with @searchable must also be annotated with @model.');
            }
            const directiveWrapped = new graphql_transformer_core_1.DirectiveWrapper(directive);
            const directiveArguments = directiveWrapped.getArguments({}, (0, graphql_transformer_core_1.generateGetArgumentsInput)(ctx.transformParameters));
            let shouldMakeSearch = true;
            let searchFieldNameOverride;
            if (directiveArguments.queries) {
                if (!directiveArguments.queries.search) {
                    shouldMakeSearch = false;
                }
                else {
                    searchFieldNameOverride = directiveArguments.queries.search;
                }
            }
            const fieldName = searchFieldNameOverride !== null && searchFieldNameOverride !== void 0 ? searchFieldNameOverride : (0, graphql_transformer_common_1.graphqlName)(`search${(0, graphql_transformer_common_1.plurality)((0, graphql_transformer_common_1.toUpper)(definition.name.value), true)}`);
            this.searchableObjectTypeDefinitions.push({
                node: definition,
                fieldName,
            });
            if (shouldMakeSearch) {
                this.searchableObjectNames.push(definition.name.value);
                generateSearchableXConnectionType(ctx, definition);
                generateSearchableAggregateTypes(ctx);
                const directives = [];
                if (!hasAuth) {
                    if (ctx.transformParameters.sandboxModeEnabled && ctx.synthParameters.enableIamAccess) {
                        directives.push((0, graphql_transformer_common_1.makeDirective)(API_KEY_DIRECTIVE, []));
                        directives.push((0, graphql_transformer_common_1.makeDirective)(AWS_IAM_DIRECTIVE, []));
                    }
                    else if (ctx.transformParameters.sandboxModeEnabled && ctx.authConfig.defaultAuthentication.authenticationType !== 'API_KEY') {
                        directives.push((0, graphql_transformer_common_1.makeDirective)(API_KEY_DIRECTIVE, []));
                    }
                    else if (ctx.synthParameters.enableIamAccess && ctx.authConfig.defaultAuthentication.authenticationType !== 'AWS_IAM') {
                        directives.push((0, graphql_transformer_common_1.makeDirective)(AWS_IAM_DIRECTIVE, []));
                    }
                }
                const queryField = (0, graphql_transformer_common_1.makeField)(fieldName, [
                    (0, graphql_transformer_common_1.makeInputValueDefinition)('filter', (0, graphql_transformer_common_1.makeNamedType)(`Searchable${definition.name.value}FilterInput`)),
                    (0, graphql_transformer_common_1.makeInputValueDefinition)('sort', (0, graphql_transformer_common_1.makeListType)((0, graphql_transformer_common_1.makeNamedType)(`Searchable${definition.name.value}SortInput`))),
                    (0, graphql_transformer_common_1.makeInputValueDefinition)('limit', (0, graphql_transformer_common_1.makeNamedType)('Int')),
                    (0, graphql_transformer_common_1.makeInputValueDefinition)('nextToken', (0, graphql_transformer_common_1.makeNamedType)('String')),
                    (0, graphql_transformer_common_1.makeInputValueDefinition)('from', (0, graphql_transformer_common_1.makeNamedType)('Int')),
                    (0, graphql_transformer_common_1.makeInputValueDefinition)('aggregates', (0, graphql_transformer_common_1.makeListType)((0, graphql_transformer_common_1.makeNamedType)(`Searchable${definition.name.value}AggregationInput`))),
                ], (0, graphql_transformer_common_1.makeNamedType)(`Searchable${definition.name.value}Connection`), directives);
                ctx.output.addQueryFields([queryField]);
            }
        };
        this.prepare = (ctx) => {
            for (const def of this.searchableObjectTypeDefinitions) {
                const modelName = def.node.name.value;
                if ((0, graphql_transformer_core_1.isSqlModel)(ctx, modelName)) {
                    throw new graphql_transformer_core_1.InvalidDirectiveError(`@searchable is not supported on "${modelName}" model as it uses RDS datasource.`);
                }
                ctx.resourceHelper.getModelFieldMap(modelName).addResolverReference({ typeName: 'Query', fieldName: def.fieldName, isList: true });
            }
        };
        this.transformSchema = (ctx) => {
            var _a, _b;
            for (const name of this.searchableObjectNames) {
                const searchObject = ctx.output.getObject(name);
                generateSearchableInputs(ctx, searchObject);
            }
            if (this.isSearchableConfigured() &&
                ctx.transformParameters.sandboxModeEnabled &&
                ctx.authConfig.defaultAuthentication.authenticationType !== 'API_KEY') {
                for (const aggType of definitions_1.AGGREGATE_TYPES) {
                    const aggObject = ctx.output.getObject(aggType);
                    const hasApiKey = (_b = (_a = aggObject.directives) === null || _a === void 0 ? void 0 : _a.some((dir) => dir.name.value === 'aws_api_key')) !== null && _b !== void 0 ? _b : false;
                    if (!hasApiKey) {
                        (0, definitions_1.extendTypeWithDirectives)(ctx, aggType, [(0, graphql_transformer_common_1.makeDirective)('aws_api_key', [])]);
                    }
                }
            }
        };
        this.searchableObjectTypeDefinitions = [];
        this.searchableObjectNames = [];
    }
    isSearchableConfigured() {
        return this.searchableObjectNames.length !== 0;
    }
}
exports.SearchableModelTransformer = SearchableModelTransformer;
//# sourceMappingURL=graphql-searchable-transformer.js.map