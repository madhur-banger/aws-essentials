"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isAuthProviderEqual = exports.getConfiguredAuthProviders = exports.getScopeForField = exports.getAuthDirectiveRules = exports.splitRoles = void 0;
const graphql_transformer_core_1 = require("@aws-amplify/graphql-transformer-core");
const constants_1 = require("./constants");
__exportStar(require("./constants"), exports);
__exportStar(require("./definitions"), exports);
__exportStar(require("./validations"), exports);
__exportStar(require("./schema"), exports);
__exportStar(require("./iam"), exports);
__exportStar(require("./role-definition"), exports);
const splitRoles = (roles) => ({
    cognitoStaticRoles: roles.filter((r) => r.static && (0, exports.isAuthProviderEqual)(r.provider, 'userPools')),
    cognitoDynamicRoles: roles.filter((r) => !r.static && (0, exports.isAuthProviderEqual)(r.provider, 'userPools')),
    oidcStaticRoles: roles.filter((r) => r.static && (0, exports.isAuthProviderEqual)(r.provider, 'oidc')),
    oidcDynamicRoles: roles.filter((r) => !r.static && (0, exports.isAuthProviderEqual)(r.provider, 'oidc')),
    iamRoles: roles.filter((r) => (0, exports.isAuthProviderEqual)(r.provider, 'identityPool')),
    apiKeyRoles: roles.filter((r) => (0, exports.isAuthProviderEqual)(r.provider, 'apiKey')),
    lambdaRoles: roles.filter((r) => (0, exports.isAuthProviderEqual)(r.provider, 'function')),
});
exports.splitRoles = splitRoles;
const getAuthDirectiveRules = (authDir, options) => {
    const splitReadOperation = (rule) => {
        var _a;
        const operations = (_a = rule.operations) !== null && _a !== void 0 ? _a : [];
        const indexOfRead = operations.indexOf('read', 0);
        if (indexOfRead !== -1) {
            operations.splice(indexOfRead, 1);
            operations.push('get');
            operations.push('list');
            operations.push('listen');
            if (!(options === null || options === void 0 ? void 0 : options.isSqlDataSource)) {
                operations.push('search');
                operations.push('sync');
            }
            rule.operations = operations;
        }
    };
    const { rules } = authDir.getArguments({ rules: [] }, options);
    rules === null || rules === void 0 ? void 0 : rules.forEach((rule) => {
        var _a;
        const operations = (_a = rule.operations) !== null && _a !== void 0 ? _a : constants_1.MODEL_OPERATIONS;
        if (rule.groups && typeof rule.groups === 'string') {
            rule.groups = [rule.groups];
        }
        if ((options === null || options === void 0 ? void 0 : options.isField) &&
            rule.operations &&
            rule.operations.some((operation) => operation !== 'read' && constants_1.READ_MODEL_OPERATIONS.includes(operation))) {
            const offendingOperation = operations.filter((operation) => operation !== 'read' && constants_1.READ_MODEL_OPERATIONS.includes(operation));
            throw new graphql_transformer_core_1.InvalidDirectiveError(`'${offendingOperation}' operation is not allowed at the field level.`);
        }
        if (operations.includes('read') && operations.some((operation) => operation !== 'read' && constants_1.READ_MODEL_OPERATIONS.includes(operation))) {
            const offendingOperation = operations.filter((operation) => operation !== 'read' && constants_1.READ_MODEL_OPERATIONS.includes(operation));
            throw new graphql_transformer_core_1.InvalidDirectiveError(`'${offendingOperation}' operations are specified in addition to 'read'. Either remove 'read' to limit access only to '${offendingOperation}' or only keep 'read' to grant all ${constants_1.READ_MODEL_OPERATIONS} access.`);
        }
        if (!rule.provider) {
            switch (rule.allow) {
                case 'owner':
                case 'groups':
                    rule.provider = 'userPools';
                    break;
                case 'private':
                    rule.provider = 'userPools';
                    break;
                case 'public':
                    rule.provider = 'apiKey';
                    break;
                case 'custom':
                    rule.provider = 'function';
                    break;
                default:
                    throw new Error(`Need to specify an allow to assigned a provider: ${rule}`);
            }
        }
        if ((0, exports.isAuthProviderEqual)(rule.provider, 'identityPool')) {
            rule.generateIAMPolicy = true;
        }
        splitReadOperation(rule);
    });
    return rules;
};
exports.getAuthDirectiveRules = getAuthDirectiveRules;
const getScopeForField = (ctx, obj, fieldName, hasModelDirective) => {
    const fieldNode = obj.fields.find((f) => f.name.value === fieldName);
    const fieldDirectives = fieldNode.directives.map((d) => d.name.value);
    if (fieldDirectives.includes('function')) {
        return ctx.stackManager.getStack('FunctionDirectiveStack');
    }
    if (fieldDirectives.includes('predictions')) {
        return ctx.stackManager.getStack('PredictionsDirectiveStack');
    }
    if (fieldDirectives.includes('sql')) {
        return ctx.stackManager.getStack('CustomSQLStack');
    }
    if (hasModelDirective) {
        return ctx.stackManager.getStack(obj.name.value);
    }
    return ctx.stackManager.scope;
};
exports.getScopeForField = getScopeForField;
const getConfiguredAuthProviders = (context) => {
    const { authConfig, synthParameters } = context;
    const { adminRoles, identityPoolId } = synthParameters;
    const providers = [
        authConfig.defaultAuthentication.authenticationType,
        ...authConfig.additionalAuthenticationProviders.map((p) => p.authenticationType),
    ];
    const getAuthProvider = (authType) => {
        switch (authType) {
            case 'AMAZON_COGNITO_USER_POOLS':
                return 'userPools';
            case 'API_KEY':
                return 'apiKey';
            case 'AWS_IAM':
                return 'identityPool';
            case 'OPENID_CONNECT':
                return 'oidc';
            case 'AWS_LAMBDA':
                return 'function';
            default:
                return 'apiKey';
        }
    };
    const hasIAM = providers.some((p) => p === 'AWS_IAM');
    const hasAdminRolesEnabled = hasIAM && (adminRoles === null || adminRoles === void 0 ? void 0 : adminRoles.length) > 0;
    const shouldAddDefaultServiceDirective = (hasAdminRolesEnabled || context.synthParameters.enableIamAccess) && authConfig.defaultAuthentication.authenticationType !== 'AWS_IAM';
    const configuredProviders = {
        default: getAuthProvider(authConfig.defaultAuthentication.authenticationType),
        onlyDefaultAuthProviderConfigured: authConfig.additionalAuthenticationProviders.length === 0,
        hasAdminRolesEnabled,
        hasIdentityPoolId: identityPoolId !== null && identityPoolId !== undefined,
        hasApiKey: providers.some((p) => p === 'API_KEY'),
        hasUserPools: providers.some((p) => p === 'AMAZON_COGNITO_USER_POOLS'),
        hasOIDC: providers.some((p) => p === 'OPENID_CONNECT'),
        hasLambda: providers.some((p) => p === 'AWS_LAMBDA'),
        hasIAM,
        shouldAddDefaultServiceDirective,
        genericIamAccessEnabled: synthParameters.enableIamAccess,
    };
    return configuredProviders;
};
exports.getConfiguredAuthProviders = getConfiguredAuthProviders;
const isAuthProviderEqual = (provider, otherProvider) => {
    if (provider === otherProvider) {
        return true;
    }
    if ((provider === 'iam' || provider === 'identityPool') && (otherProvider === 'iam' || otherProvider === 'identityPool')) {
        return true;
    }
    return false;
};
exports.isAuthProviderEqual = isAuthProviderEqual;
//# sourceMappingURL=index.js.map