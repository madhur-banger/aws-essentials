"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.shouldBeAppliedToDDBModels = exports.MapsToTransformer = void 0;
const graphql_transformer_core_1 = require("@aws-amplify/graphql-transformer-core");
const graphql_transformer_interfaces_1 = require("@aws-amplify/graphql-transformer-interfaces");
const graphql_directives_1 = require("@aws-amplify/graphql-directives");
const field_mapping_lambda_1 = require("./field-mapping-lambda");
const field_mapping_resolvers_1 = require("./field-mapping-resolvers");
const graphql_name_mapping_1 = require("./graphql-name-mapping");
class MapsToTransformer extends graphql_transformer_core_1.TransformerPluginBase {
    constructor() {
        super('amplify-maps-to-transformer', graphql_directives_1.MapsToDirective.definition, graphql_transformer_interfaces_1.TransformerPluginType.GENERIC);
        this.object = (definition, directive, ctx) => {
            (0, graphql_name_mapping_1.shouldBeAppliedToModel)(definition, graphql_directives_1.MapsToDirective.name);
            (0, exports.shouldBeAppliedToDDBModels)(definition, ctx);
            const modelName = definition.name.value;
            const mappedName = (0, graphql_name_mapping_1.getMappedName)(definition, directive, graphql_directives_1.MapsToDirective.name, ctx.inputDocument);
            (0, graphql_name_mapping_1.updateTypeMapping)(modelName, mappedName, ctx.resourceHelper.setModelNameMapping);
        };
        this.preMutateSchema = (context) => {
            (0, graphql_name_mapping_1.setTypeMappingInSchema)(context, graphql_directives_1.MapsToDirective.name);
        };
        this.after = (context) => {
            context.resourceHelper.getModelFieldMapKeys().forEach((modelName) => {
                if ((0, graphql_transformer_core_1.isSqlModel)(context, modelName)) {
                    return;
                }
                const modelFieldMap = context.resourceHelper.getModelFieldMap(modelName);
                if (!modelFieldMap.getMappedFields().length) {
                    return;
                }
                const lambdaDataSource = (0, field_mapping_lambda_1.createMappingLambda)(context.api.host, context.stackManager);
                modelFieldMap.getResolverReferences().forEach(({ typeName, fieldName, isList }) => {
                    const resolver = context.resolvers.getResolver(typeName, fieldName);
                    if (!resolver) {
                        return;
                    }
                    if (typeName === 'Mutation') {
                        (0, field_mapping_resolvers_1.attachInputMappingSlot)({
                            resolver,
                            resolverTypeName: typeName,
                            resolverFieldName: fieldName,
                            fieldMap: modelFieldMap.getMappedFields(),
                        });
                        (0, field_mapping_resolvers_1.attachFilterAndConditionInputMappingSlot)({
                            slotName: 'preUpdate',
                            resolver,
                            resolverTypeName: typeName,
                            resolverFieldName: fieldName,
                            fieldMap: modelFieldMap.getMappedFields(),
                            dataSource: lambdaDataSource,
                        });
                        (0, field_mapping_resolvers_1.attachResponseMappingSlot)({
                            slotName: 'postUpdate',
                            resolver,
                            resolverTypeName: typeName,
                            resolverFieldName: fieldName,
                            fieldMap: modelFieldMap.getMappedFields(),
                            isList: false,
                        });
                    }
                    else {
                        (0, field_mapping_resolvers_1.attachFilterAndConditionInputMappingSlot)({
                            slotName: 'preDataLoad',
                            resolver,
                            resolverTypeName: typeName,
                            resolverFieldName: fieldName,
                            fieldMap: modelFieldMap.getMappedFields(),
                            dataSource: lambdaDataSource,
                        });
                        (0, field_mapping_resolvers_1.attachResponseMappingSlot)({
                            slotName: 'postDataLoad',
                            resolver,
                            resolverTypeName: typeName,
                            resolverFieldName: fieldName,
                            fieldMap: modelFieldMap.getMappedFields(),
                            isList,
                        });
                    }
                });
            });
        };
    }
}
exports.MapsToTransformer = MapsToTransformer;
const shouldBeAppliedToDDBModels = (definition, ctx) => {
    const modelName = definition.name.value;
    if (!(0, graphql_transformer_core_1.isDynamoDbModel)(ctx, modelName)) {
        throw new Error(`${graphql_directives_1.MapsToDirective.name} is only supported on DynamoDB models. ${modelName} is not a DDB model.`);
    }
};
exports.shouldBeAppliedToDDBModels = shouldBeAppliedToDDBModels;
//# sourceMappingURL=graphql-maps-to-transformer.js.map