"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateKeyAndQueryNameForConfig = exports.validateNotOwnerAuth = exports.validateNotSelfReferencing = exports.lookupResolverName = void 0;
const graphql_transformer_core_1 = require("@aws-amplify/graphql-transformer-core");
const graphql_transformer_common_1 = require("graphql-transformer-common");
const pluralize_1 = __importDefault(require("pluralize"));
function lookupResolverName(config, ctx, op) {
    const { object, modelDirective } = config;
    const argName = op === 'get' || op === 'list' || op === 'sync' ? 'queries' : 'mutations';
    let resolverName;
    for (const argument of modelDirective.arguments) {
        const arg = argument;
        if (arg.name.value !== argName || !Array.isArray(arg.value.fields)) {
            continue;
        }
        for (const field of arg.value.fields) {
            if (field.name.value === op) {
                resolverName = field.value.value;
                if (!resolverName) {
                    return null;
                }
            }
        }
    }
    if (!resolverName) {
        const capitalizedName = (0, graphql_transformer_common_1.toUpper)(object.name.value);
        if (op === 'list' || op === 'sync') {
            resolverName = `${op}${(0, graphql_transformer_common_1.plurality)(capitalizedName, true)}`;
        }
        else {
            resolverName = `${op}${capitalizedName}`;
        }
    }
    return resolverName;
}
exports.lookupResolverName = lookupResolverName;
function validateNotSelfReferencing(config) {
    const { directive, field, sortKeyFields } = config;
    const fieldName = field.name.value;
    for (const sortKeyField of sortKeyFields) {
        if (sortKeyField === fieldName) {
            throw new graphql_transformer_core_1.InvalidDirectiveError(`@${directive.name.value} field '${fieldName}' cannot reference itself.`);
        }
    }
}
exports.validateNotSelfReferencing = validateNotSelfReferencing;
const validateNotOwnerAuth = (sortKeyField, { object }, ctx) => {
    var _a, _b, _c;
    const authDir = (object.directives || []).find(collectAuthDirectives);
    const featureFlagEnabled = ctx.transformParameters.useSubUsernameForDefaultIdentityClaim;
    if (!authDir || !featureFlagEnabled)
        return true;
    const authDirRules = ((_c = (_b = (_a = authDir.arguments) === null || _a === void 0 ? void 0 : _a.find((arg) => arg.name.value === 'rules')) === null || _b === void 0 ? void 0 : _b.value) === null || _c === void 0 ? void 0 : _c.values) || [];
    return !authDirRules.map(ownerFieldsFromOwnerRule).includes(sortKeyField);
};
exports.validateNotOwnerAuth = validateNotOwnerAuth;
const collectAuthDirectives = (dir) => dir.name.value === 'auth';
const ownerFieldsFromOwnerRule = (rule) => {
    const ruleObject = {
        ownerField: 'owner',
        identityClaim: 'sub::username',
    };
    (rule.fields || []).forEach((field) => {
        var _a;
        const name = field.name.value;
        const value = ((_a = field === null || field === void 0 ? void 0 : field.value) === null || _a === void 0 ? void 0 : _a.value) || '';
        ruleObject[name] = value;
    });
    if (ruleObject.allow === 'owner' && ruleObject.identityClaim.split('::').length > 1) {
        return ruleObject.ownerField;
    }
    return '';
};
const generateKeyAndQueryNameForConfig = (config) => {
    const modelName = config.object.name.value;
    const fieldName = config.field.name.value;
    const { sortKeyFields } = config;
    return `${(0, graphql_transformer_common_1.toLower)((0, pluralize_1.default)(modelName))}By${[fieldName, ...sortKeyFields].map(graphql_transformer_common_1.toUpper).join('And')}`;
};
exports.generateKeyAndQueryNameForConfig = generateKeyAndQueryNameForConfig;
//# sourceMappingURL=utils.js.map