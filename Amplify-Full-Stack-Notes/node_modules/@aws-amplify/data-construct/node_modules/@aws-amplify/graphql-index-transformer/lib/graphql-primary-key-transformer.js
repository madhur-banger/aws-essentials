"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateListField = exports.PrimaryKeyTransformer = void 0;
const graphql_transformer_core_1 = require("@aws-amplify/graphql-transformer-core");
const graphql_directives_1 = require("@aws-amplify/graphql-directives");
const graphql_1 = require("graphql");
const graphql_transformer_common_1 = require("graphql-transformer-common");
const resolvers_1 = require("./resolvers/resolvers");
const schema_1 = require("./schema");
const utils_1 = require("./utils");
class PrimaryKeyTransformer extends graphql_transformer_core_1.TransformerPluginBase {
    constructor() {
        super('amplify-primary-key-transformer', graphql_directives_1.PrimaryKeyDirective.definition);
        this.directiveList = [];
        this.resolverMap = new Map();
        this.field = (parent, definition, directive, context) => {
            const directiveWrapped = new graphql_transformer_core_1.DirectiveWrapper(directive);
            const args = directiveWrapped.getArguments({
                object: parent,
                field: definition,
                directive,
            }, (0, graphql_transformer_core_1.generateGetArgumentsInput)(context.transformParameters));
            if (!args.sortKeyFields) {
                args.sortKeyFields = [];
            }
            else if (!Array.isArray(args.sortKeyFields)) {
                args.sortKeyFields = [args.sortKeyFields];
            }
            args.sortKey = [];
            validate(args, context);
            this.directiveList.push(args);
        };
        this.after = (ctx) => {
            if (!ctx.isProjectUsingDataStore())
                return;
            this.resolverMap.forEach((syncVTLContent, resource) => {
                if (syncVTLContent) {
                    (0, resolvers_1.constructSyncVTL)(syncVTLContent, resource);
                }
            });
        };
        this.transformSchema = (ctx) => {
            const context = ctx;
            for (const config of this.directiveList) {
                (0, schema_1.updateGetField)(config, context);
                (0, exports.updateListField)(config, context);
                (0, schema_1.updateInputObjects)(config, context);
                (0, schema_1.removeAutoCreatedPrimaryKey)(config, context);
                (0, schema_1.addKeyConditionInputs)(config, context);
                (0, schema_1.updateMutationConditionInput)(config, context);
            }
        };
        this.generateResolvers = (ctx) => {
            for (const config of this.directiveList) {
                const dbType = (0, graphql_transformer_core_1.getModelDataSourceStrategy)(ctx, config.object.name.value).dbType;
                const vtlGenerator = (0, resolvers_1.getVTLGenerator)(dbType);
                vtlGenerator.generatePrimaryKeyVTL(config, ctx, this.resolverMap);
            }
        };
    }
}
exports.PrimaryKeyTransformer = PrimaryKeyTransformer;
const validate = (config, ctx) => {
    const { object, field, sortKeyFields } = config;
    (0, utils_1.validateNotSelfReferencing)(config);
    const modelDirective = object.directives.find((directive) => {
        return directive.name.value === 'model';
    });
    if (!modelDirective) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`The @${graphql_directives_1.PrimaryKeyDirective.name} directive may only be added to object definitions annotated with @model.`);
    }
    config.modelDirective = modelDirective;
    const fieldMap = new Map();
    for (const objectField of object.fields) {
        fieldMap.set(objectField.name.value, objectField);
        if (field === objectField) {
            continue;
        }
        for (const directive of objectField.directives) {
            if (directive.name.value === graphql_directives_1.PrimaryKeyDirective.name) {
                throw new graphql_transformer_core_1.InvalidDirectiveError(`You may only supply one primary key on type '${object.name.value}'.`);
            }
        }
    }
    if (!(0, graphql_transformer_common_1.isNonNullType)(field.type)) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`The primary key on type '${object.name.value}' must reference non-null fields.`);
    }
    const enums = ctx.output.getTypeDefinitionsOfKind(graphql_1.Kind.ENUM_TYPE_DEFINITION);
    if (!(0, graphql_transformer_common_1.isScalarOrEnum)(field.type, enums) || (0, graphql_transformer_common_1.isListType)(field.type)) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`The primary key on type '${object.name.value}.${field.name.value}' cannot be a non-scalar.`);
    }
    for (const sortKeyFieldName of sortKeyFields) {
        const sortField = fieldMap.get(sortKeyFieldName);
        if (!sortField) {
            throw new graphql_transformer_core_1.InvalidDirectiveError(`Can't find field '${sortKeyFieldName}' in ${object.name.value}, but it was specified in the primary key.`);
        }
        if (!(0, graphql_transformer_common_1.isScalarOrEnum)(sortField.type, enums) || (0, graphql_transformer_common_1.isListType)(sortField.type)) {
            throw new graphql_transformer_core_1.InvalidDirectiveError(`The primary key's sort key on type '${object.name.value}.${sortField.name.value}' cannot be a non-scalar.`);
        }
        if (!(0, graphql_transformer_common_1.isNonNullType)(sortField.type)) {
            throw new graphql_transformer_core_1.InvalidDirectiveError(`The primary key on type '${object.name.value}' must reference non-null fields.`);
        }
        if (!(0, utils_1.validateNotOwnerAuth)(sortKeyFieldName, config, ctx)) {
            throw new graphql_transformer_core_1.InvalidDirectiveError(`The primary key's sort key type '${sortKeyFieldName}' cannot be used as an owner @auth field too. Please use another field for the sort key.`);
        }
        config.sortKey.push(sortField);
    }
};
const updateListField = (config, ctx) => {
    const resolverName = (0, utils_1.lookupResolverName)(config, ctx, 'list');
    let query = ctx.output.getQuery();
    if (!(resolverName && query)) {
        return;
    }
    let listField = query.fields.find((field) => field.name.value === resolverName);
    if (listField) {
        const args = [(0, schema_1.createHashField)(config)];
        const dbType = (0, graphql_transformer_core_1.getModelDataSourceStrategy)(ctx, config.object.name.value).dbType;
        if (!dbType || !(0, graphql_transformer_core_1.isSqlDbType)(dbType)) {
            const sortField = (0, schema_1.tryAndCreateSortField)(config, ctx);
            if (sortField) {
                args.push(sortField);
            }
        }
        if (Array.isArray(listField.arguments)) {
            args.push(...listField.arguments);
        }
        args.push((0, graphql_transformer_common_1.makeInputValueDefinition)('sortDirection', (0, graphql_transformer_common_1.makeNamedType)('ModelSortDirection')));
        (0, schema_1.ensureModelSortDirectionEnum)(ctx);
        listField = { ...listField, arguments: args };
        query = {
            ...query,
            fields: query.fields.map((field) => {
                return field.name.value === listField.name.value ? listField : field;
            }),
        };
        ctx.output.updateObject(query);
    }
};
exports.updateListField = updateListField;
//# sourceMappingURL=graphql-primary-key-transformer.js.map