"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ObjectAccumulator = exports.ObjectAccumulatorVersionMismatchError = exports.ObjectAccumulatorPropertyAlreadyExistsError = void 0;
const lodash_mergewith_1 = __importDefault(require("lodash.mergewith"));
const semver_1 = __importDefault(require("semver"));
/**
 * This error is thrown when there's a collision in the object keys
 */
class ObjectAccumulatorPropertyAlreadyExistsError extends Error {
    key;
    existingValue;
    incomingValue;
    /**
     * Creates property already exists error.
     */
    constructor(key, existingValue, incomingValue) {
        super(`Property ${key} already exists`);
        this.key = key;
        this.existingValue = existingValue;
        this.incomingValue = incomingValue;
    }
}
exports.ObjectAccumulatorPropertyAlreadyExistsError = ObjectAccumulatorPropertyAlreadyExistsError;
/**
 * This error is thrown when partial objects with different versions are being accumulated
 */
class ObjectAccumulatorVersionMismatchError extends Error {
    existingVersion;
    newVersion;
    /**
     * Creates property already exists error.
     */
    constructor(existingVersion, newVersion) {
        super(`Version mismatch: Cannot accumulate new objects with version ${newVersion} with existing accumulated object with version ${existingVersion}`);
        this.existingVersion = existingVersion;
        this.newVersion = newVersion;
    }
}
exports.ObjectAccumulatorVersionMismatchError = ObjectAccumulatorVersionMismatchError;
/**
 * A class that can accumulate (squash merge) objects into single instance.
 */
class ObjectAccumulator {
    accumulator;
    versionKey;
    /**
     * creates object accumulator.
     */
    constructor(accumulator, versionKey = 'version') {
        this.accumulator = accumulator;
        this.versionKey = versionKey;
    }
    /**
     * Accumulate a new object part with accumulator.
     * This method throws if there is any intersection between the object parts
     * except for the versionKey, which should be the same across all object parts (nested objects included)
     * @param part a new object part to accumulate
     * @returns the accumulator object for easy chaining
     */
    accumulate = (part) => {
        (0, lodash_mergewith_1.default)(this.accumulator, part, (existingValue, incomingValue, key) => {
            if (Array.isArray(existingValue)) {
                return existingValue.concat(incomingValue);
            }
            if (existingValue && typeof existingValue !== 'object') {
                if (key === this.versionKey) {
                    const incomingVersion = semver_1.default.coerce(incomingValue);
                    const existingVersion = semver_1.default.coerce(existingValue);
                    if (incomingVersion && existingVersion) {
                        // Only throw if the major version is not equal
                        if (incomingVersion.major !== existingVersion.major) {
                            throw new ObjectAccumulatorVersionMismatchError(existingValue, incomingValue);
                        }
                        else {
                            // We always get the max version to persist in the accumulated object
                            return semver_1.default.gte(incomingVersion, existingVersion)
                                ? incomingValue
                                : existingValue;
                        }
                    }
                }
                else if (key !== this.versionKey) {
                    throw new ObjectAccumulatorPropertyAlreadyExistsError(key, existingValue, incomingValue);
                }
            }
            // returning undefined falls back to default merge algorithm
            return undefined;
        });
        return this;
    };
    getAccumulatedObject = () => {
        return this.accumulator;
    };
}
exports.ObjectAccumulator = ObjectAccumulator;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib2JqZWN0X2FjY3VtdWxhdG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL29iamVjdF9hY2N1bXVsYXRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7QUFDQSx3RUFBeUM7QUFDekMsb0RBQTRCO0FBQzVCOztHQUVHO0FBQ0gsTUFBYSwyQ0FBNEMsU0FBUSxLQUFLO0lBS3pEO0lBQ0E7SUFDQTtJQU5YOztPQUVHO0lBQ0gsWUFDVyxHQUFXLEVBQ1gsYUFBc0IsRUFDdEIsYUFBc0I7UUFFL0IsS0FBSyxDQUFDLFlBQVksR0FBRyxpQkFBaUIsQ0FBQyxDQUFDO1FBSi9CLFFBQUcsR0FBSCxHQUFHLENBQVE7UUFDWCxrQkFBYSxHQUFiLGFBQWEsQ0FBUztRQUN0QixrQkFBYSxHQUFiLGFBQWEsQ0FBUztJQUdqQyxDQUFDO0NBQ0Y7QUFYRCxrR0FXQztBQUVEOztHQUVHO0FBQ0gsTUFBYSxxQ0FBc0MsU0FBUSxLQUFLO0lBSXpDO0lBQWtDO0lBSHZEOztPQUVHO0lBQ0gsWUFBcUIsZUFBdUIsRUFBVyxVQUFrQjtRQUN2RSxLQUFLLENBQ0gsZ0VBQWdFLFVBQVUsa0RBQWtELGVBQWUsRUFBRSxDQUM5SSxDQUFDO1FBSGlCLG9CQUFlLEdBQWYsZUFBZSxDQUFRO1FBQVcsZUFBVSxHQUFWLFVBQVUsQ0FBUTtJQUl6RSxDQUFDO0NBQ0Y7QUFURCxzRkFTQztBQUVEOztHQUVHO0FBQ0gsTUFBYSxpQkFBaUI7SUFLVDtJQUNBO0lBTG5COztPQUVHO0lBQ0gsWUFDbUIsV0FBa0QsRUFDbEQsYUFBYSxTQUFTO1FBRHRCLGdCQUFXLEdBQVgsV0FBVyxDQUF1QztRQUNsRCxlQUFVLEdBQVYsVUFBVSxDQUFZO0lBQ3RDLENBQUM7SUFFSjs7Ozs7O09BTUc7SUFDSCxVQUFVLEdBQUcsQ0FDWCxJQUEyQyxFQUNyQixFQUFFO1FBQ3hCLElBQUEsMEJBQVMsRUFBQyxJQUFJLENBQUMsV0FBVyxFQUFFLElBQUksRUFBRSxDQUFDLGFBQWEsRUFBRSxhQUFhLEVBQUUsR0FBRyxFQUFFLEVBQUU7WUFDdEUsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxFQUFFO2dCQUNoQyxPQUFPLGFBQWEsQ0FBQyxNQUFNLENBQUMsYUFBYSxDQUFDLENBQUM7YUFDNUM7WUFDRCxJQUFJLGFBQWEsSUFBSSxPQUFPLGFBQWEsS0FBSyxRQUFRLEVBQUU7Z0JBQ3RELElBQUksR0FBRyxLQUFLLElBQUksQ0FBQyxVQUFVLEVBQUU7b0JBQzNCLE1BQU0sZUFBZSxHQUFHLGdCQUFNLENBQUMsTUFBTSxDQUFDLGFBQWEsQ0FBQyxDQUFDO29CQUNyRCxNQUFNLGVBQWUsR0FBRyxnQkFBTSxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsQ0FBQztvQkFDckQsSUFBSSxlQUFlLElBQUksZUFBZSxFQUFFO3dCQUN0QywrQ0FBK0M7d0JBQy9DLElBQUksZUFBZSxDQUFDLEtBQUssS0FBSyxlQUFlLENBQUMsS0FBSyxFQUFFOzRCQUNuRCxNQUFNLElBQUkscUNBQXFDLENBQzdDLGFBQWEsRUFDYixhQUFhLENBQ2QsQ0FBQzt5QkFDSDs2QkFBTTs0QkFDTCxxRUFBcUU7NEJBQ3JFLE9BQU8sZ0JBQU0sQ0FBQyxHQUFHLENBQUMsZUFBZSxFQUFFLGVBQWUsQ0FBQztnQ0FDakQsQ0FBQyxDQUFDLGFBQWE7Z0NBQ2YsQ0FBQyxDQUFDLGFBQWEsQ0FBQzt5QkFDbkI7cUJBQ0Y7aUJBQ0Y7cUJBQU0sSUFBSSxHQUFHLEtBQUssSUFBSSxDQUFDLFVBQVUsRUFBRTtvQkFDbEMsTUFBTSxJQUFJLDJDQUEyQyxDQUNuRCxHQUFHLEVBQ0gsYUFBYSxFQUNiLGFBQWEsQ0FDZCxDQUFDO2lCQUNIO2FBQ0Y7WUFFRCw0REFBNEQ7WUFDNUQsT0FBTyxTQUFTLENBQUM7UUFDbkIsQ0FBQyxDQUFDLENBQUM7UUFDSCxPQUFPLElBQUksQ0FBQztJQUNkLENBQUMsQ0FBQztJQUVGLG9CQUFvQixHQUFHLEdBQUcsRUFBRTtRQUMxQixPQUFPLElBQUksQ0FBQyxXQUFXLENBQUM7SUFDMUIsQ0FBQyxDQUFDO0NBQ0g7QUEzREQsOENBMkRDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGVlcFBhcnRpYWxBbXBsaWZ5R2VuZXJhdGVkQ29uZmlncyB9IGZyb20gJ0Bhd3MtYW1wbGlmeS9wbHVnaW4tdHlwZXMnO1xuaW1wb3J0IG1lcmdlV2l0aCBmcm9tICdsb2Rhc2gubWVyZ2V3aXRoJztcbmltcG9ydCBzZW12ZXIgZnJvbSAnc2VtdmVyJztcbi8qKlxuICogVGhpcyBlcnJvciBpcyB0aHJvd24gd2hlbiB0aGVyZSdzIGEgY29sbGlzaW9uIGluIHRoZSBvYmplY3Qga2V5c1xuICovXG5leHBvcnQgY2xhc3MgT2JqZWN0QWNjdW11bGF0b3JQcm9wZXJ0eUFscmVhZHlFeGlzdHNFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgcHJvcGVydHkgYWxyZWFkeSBleGlzdHMgZXJyb3IuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICByZWFkb25seSBrZXk6IHN0cmluZyxcbiAgICByZWFkb25seSBleGlzdGluZ1ZhbHVlOiB1bmtub3duLFxuICAgIHJlYWRvbmx5IGluY29taW5nVmFsdWU6IHVua25vd25cbiAgKSB7XG4gICAgc3VwZXIoYFByb3BlcnR5ICR7a2V5fSBhbHJlYWR5IGV4aXN0c2ApO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBlcnJvciBpcyB0aHJvd24gd2hlbiBwYXJ0aWFsIG9iamVjdHMgd2l0aCBkaWZmZXJlbnQgdmVyc2lvbnMgYXJlIGJlaW5nIGFjY3VtdWxhdGVkXG4gKi9cbmV4cG9ydCBjbGFzcyBPYmplY3RBY2N1bXVsYXRvclZlcnNpb25NaXNtYXRjaEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAvKipcbiAgICogQ3JlYXRlcyBwcm9wZXJ0eSBhbHJlYWR5IGV4aXN0cyBlcnJvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHJlYWRvbmx5IGV4aXN0aW5nVmVyc2lvbjogc3RyaW5nLCByZWFkb25seSBuZXdWZXJzaW9uOiBzdHJpbmcpIHtcbiAgICBzdXBlcihcbiAgICAgIGBWZXJzaW9uIG1pc21hdGNoOiBDYW5ub3QgYWNjdW11bGF0ZSBuZXcgb2JqZWN0cyB3aXRoIHZlcnNpb24gJHtuZXdWZXJzaW9ufSB3aXRoIGV4aXN0aW5nIGFjY3VtdWxhdGVkIG9iamVjdCB3aXRoIHZlcnNpb24gJHtleGlzdGluZ1ZlcnNpb259YFxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBBIGNsYXNzIHRoYXQgY2FuIGFjY3VtdWxhdGUgKHNxdWFzaCBtZXJnZSkgb2JqZWN0cyBpbnRvIHNpbmdsZSBpbnN0YW5jZS5cbiAqL1xuZXhwb3J0IGNsYXNzIE9iamVjdEFjY3VtdWxhdG9yPFQ+IHtcbiAgLyoqXG4gICAqIGNyZWF0ZXMgb2JqZWN0IGFjY3VtdWxhdG9yLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBhY2N1bXVsYXRvcjogRGVlcFBhcnRpYWxBbXBsaWZ5R2VuZXJhdGVkQ29uZmlnczxUPixcbiAgICBwcml2YXRlIHJlYWRvbmx5IHZlcnNpb25LZXkgPSAndmVyc2lvbidcbiAgKSB7fVxuXG4gIC8qKlxuICAgKiBBY2N1bXVsYXRlIGEgbmV3IG9iamVjdCBwYXJ0IHdpdGggYWNjdW11bGF0b3IuXG4gICAqIFRoaXMgbWV0aG9kIHRocm93cyBpZiB0aGVyZSBpcyBhbnkgaW50ZXJzZWN0aW9uIGJldHdlZW4gdGhlIG9iamVjdCBwYXJ0c1xuICAgKiBleGNlcHQgZm9yIHRoZSB2ZXJzaW9uS2V5LCB3aGljaCBzaG91bGQgYmUgdGhlIHNhbWUgYWNyb3NzIGFsbCBvYmplY3QgcGFydHMgKG5lc3RlZCBvYmplY3RzIGluY2x1ZGVkKVxuICAgKiBAcGFyYW0gcGFydCBhIG5ldyBvYmplY3QgcGFydCB0byBhY2N1bXVsYXRlXG4gICAqIEByZXR1cm5zIHRoZSBhY2N1bXVsYXRvciBvYmplY3QgZm9yIGVhc3kgY2hhaW5pbmdcbiAgICovXG4gIGFjY3VtdWxhdGUgPSAoXG4gICAgcGFydDogRGVlcFBhcnRpYWxBbXBsaWZ5R2VuZXJhdGVkQ29uZmlnczxUPlxuICApOiBPYmplY3RBY2N1bXVsYXRvcjxUPiA9PiB7XG4gICAgbWVyZ2VXaXRoKHRoaXMuYWNjdW11bGF0b3IsIHBhcnQsIChleGlzdGluZ1ZhbHVlLCBpbmNvbWluZ1ZhbHVlLCBrZXkpID0+IHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGV4aXN0aW5nVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBleGlzdGluZ1ZhbHVlLmNvbmNhdChpbmNvbWluZ1ZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChleGlzdGluZ1ZhbHVlICYmIHR5cGVvZiBleGlzdGluZ1ZhbHVlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoa2V5ID09PSB0aGlzLnZlcnNpb25LZXkpIHtcbiAgICAgICAgICBjb25zdCBpbmNvbWluZ1ZlcnNpb24gPSBzZW12ZXIuY29lcmNlKGluY29taW5nVmFsdWUpO1xuICAgICAgICAgIGNvbnN0IGV4aXN0aW5nVmVyc2lvbiA9IHNlbXZlci5jb2VyY2UoZXhpc3RpbmdWYWx1ZSk7XG4gICAgICAgICAgaWYgKGluY29taW5nVmVyc2lvbiAmJiBleGlzdGluZ1ZlcnNpb24pIHtcbiAgICAgICAgICAgIC8vIE9ubHkgdGhyb3cgaWYgdGhlIG1ham9yIHZlcnNpb24gaXMgbm90IGVxdWFsXG4gICAgICAgICAgICBpZiAoaW5jb21pbmdWZXJzaW9uLm1ham9yICE9PSBleGlzdGluZ1ZlcnNpb24ubWFqb3IpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IE9iamVjdEFjY3VtdWxhdG9yVmVyc2lvbk1pc21hdGNoRXJyb3IoXG4gICAgICAgICAgICAgICAgZXhpc3RpbmdWYWx1ZSxcbiAgICAgICAgICAgICAgICBpbmNvbWluZ1ZhbHVlXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBXZSBhbHdheXMgZ2V0IHRoZSBtYXggdmVyc2lvbiB0byBwZXJzaXN0IGluIHRoZSBhY2N1bXVsYXRlZCBvYmplY3RcbiAgICAgICAgICAgICAgcmV0dXJuIHNlbXZlci5ndGUoaW5jb21pbmdWZXJzaW9uLCBleGlzdGluZ1ZlcnNpb24pXG4gICAgICAgICAgICAgICAgPyBpbmNvbWluZ1ZhbHVlXG4gICAgICAgICAgICAgICAgOiBleGlzdGluZ1ZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChrZXkgIT09IHRoaXMudmVyc2lvbktleSkge1xuICAgICAgICAgIHRocm93IG5ldyBPYmplY3RBY2N1bXVsYXRvclByb3BlcnR5QWxyZWFkeUV4aXN0c0Vycm9yKFxuICAgICAgICAgICAga2V5LFxuICAgICAgICAgICAgZXhpc3RpbmdWYWx1ZSxcbiAgICAgICAgICAgIGluY29taW5nVmFsdWVcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIHJldHVybmluZyB1bmRlZmluZWQgZmFsbHMgYmFjayB0byBkZWZhdWx0IG1lcmdlIGFsZ29yaXRobVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBnZXRBY2N1bXVsYXRlZE9iamVjdCA9ICgpID0+IHtcbiAgICByZXR1cm4gdGhpcy5hY2N1bXVsYXRvcjtcbiAgfTtcbn1cbiJdfQ==