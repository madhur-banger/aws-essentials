/**
 * Base class for all Amplify errors or faults
 */
export declare abstract class AmplifyError<T extends string = string> extends Error {
    readonly name: T;
    readonly classification: AmplifyErrorClassification;
    private readonly options;
    readonly cause?: Error | undefined;
    serializedError?: string;
    readonly message: string;
    readonly resolution?: string;
    readonly details?: string;
    readonly link?: string;
    readonly code?: string;
    /**
     * You should use AmplifyUserError or AmplifyLibraryFault to throw an error.
     * @param name - a user friendly name for the exception
     * @param classification - LibraryFault or UserError
     * @param options - error stack, resolution steps, details, or help links
     * @param cause If you are throwing this exception from within a catch block,
     * you must provide the exception that was caught.
     * @example
     * try {
     *  ...
     * } catch (error){
     *    throw new AmplifyError(...,...,error);
     * }
     */
    constructor(name: T, classification: AmplifyErrorClassification, options: AmplifyErrorOptions, cause?: Error | undefined);
    static fromStderr: (_stderr: string) => AmplifyError | undefined;
    static fromError: (error: unknown) => AmplifyError<'UnknownFault' | 'CredentialsError' | 'InvalidCommandInputError' | 'DomainNotFoundError' | 'SyntaxError'>;
}
/**
 * Amplify exception classifications
 */
export type AmplifyErrorClassification = 'FAULT' | 'ERROR';
/**
 * Amplify Error options object
 */
export type AmplifyErrorOptions = {
    message: string;
    details?: string;
    resolution?: string;
    link?: string;
    code?: string;
};
/**
 * Same as AmplifyErrorOptions except resolution is required
 */
export type AmplifyUserErrorOptions = Omit<AmplifyErrorOptions, 'resolution'> & {
    resolution: string;
};
//# sourceMappingURL=amplify_error.d.ts.map