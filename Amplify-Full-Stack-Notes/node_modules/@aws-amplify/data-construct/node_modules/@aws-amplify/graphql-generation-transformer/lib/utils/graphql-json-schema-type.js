"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateJSONSchemaFromTypeNode = void 0;
const graphql_1 = require("graphql");
const graphql_transformer_common_1 = require("graphql-transformer-common");
const graphql_transformer_core_1 = require("@aws-amplify/graphql-transformer-core");
const generateJSONSchemaFromTypeNode = (typeNode, ctx, schema = { type: '' }) => {
    switch (typeNode.kind) {
        case graphql_1.Kind.NAMED_TYPE:
            return handleNamedType(typeNode, ctx, schema);
        case graphql_1.Kind.NON_NULL_TYPE:
            return handleNonNullType(typeNode, ctx, schema);
        case graphql_1.Kind.LIST_TYPE:
            return handleListType(typeNode, ctx);
    }
};
exports.generateJSONSchemaFromTypeNode = generateJSONSchemaFromTypeNode;
const handleNamedType = (typeNode, ctx, schema) => {
    const namedTypeSchema = (0, graphql_transformer_core_1.convertNamedTypeToJSONSchema)(typeNode);
    Object.assign(schema, namedTypeSchema);
    if ((0, graphql_transformer_common_1.isScalar)(typeNode)) {
        return schema;
    }
    const baseTypeName = (0, graphql_transformer_common_1.getBaseType)(typeNode);
    const typeDef = ctx.output.getType(baseTypeName);
    if (!typeDef) {
        throw new Error(`Type ${baseTypeName} not found`);
    }
    schema.properties = generateJSONSchemaForDef(typeDef, ctx, schema);
    return schema;
};
const handleNonNullType = (typeNode, ctx, schema) => {
    const baseType = (0, graphql_transformer_common_1.getBaseType)(typeNode);
    if ((0, graphql_transformer_core_1.isDisallowedScalarType)(baseType)) {
        throw new Error(`
      Disallowed required field type ${baseType} without a default value.
      Use one of the supported scalar types for generation routes: [${graphql_transformer_core_1.supportedScalarTypes.join(', ')}]
    `);
    }
    return (0, exports.generateJSONSchemaFromTypeNode)(typeNode.type, ctx, schema);
};
const handleListType = (typeNode, ctx) => {
    return {
        type: 'array',
        items: (0, exports.generateJSONSchemaFromTypeNode)(typeNode.type, ctx),
    };
};
const generateJSONSchemaForDef = (def, ctx, schema) => {
    switch (def.kind) {
        case 'ObjectTypeDefinition':
            return handleObjectTypeDefinition(def, ctx, schema);
        case 'EnumTypeDefinition':
            return handleEnumTypeDefinition(def);
        default:
            throw new Error(`Unsupported type definition: ${def.kind}`);
    }
};
const handleObjectTypeDefinition = (def, ctx, schema) => {
    var _a;
    const properties = ((_a = def.fields) !== null && _a !== void 0 ? _a : []).reduce((acc, field) => {
        acc[field.name.value] = (0, exports.generateJSONSchemaFromTypeNode)(field.type, ctx, { type: '' });
        if (field.type.kind === graphql_1.Kind.NON_NULL_TYPE) {
            schema.required = [...(schema.required || []), field.name.value];
        }
        return acc;
    }, {});
    return properties;
};
const handleEnumTypeDefinition = (def) => {
    var _a;
    return {
        [def.name.value]: {
            type: 'string',
            enum: (_a = def.values) === null || _a === void 0 ? void 0 : _a.map((value) => value.name.value),
        },
    };
};
//# sourceMappingURL=graphql-json-schema-type.js.map