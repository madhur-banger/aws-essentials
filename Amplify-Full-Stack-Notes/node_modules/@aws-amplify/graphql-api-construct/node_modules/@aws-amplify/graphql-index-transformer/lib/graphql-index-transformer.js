"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IndexTransformer = void 0;
const graphql_transformer_core_1 = require("@aws-amplify/graphql-transformer-core");
const graphql_directives_1 = require("@aws-amplify/graphql-directives");
const graphql_1 = require("graphql");
const graphql_transformer_common_1 = require("graphql-transformer-common");
const resolvers_1 = require("./resolvers");
const schema_1 = require("./schema");
const utils_1 = require("./utils");
class IndexTransformer extends graphql_transformer_core_1.TransformerPluginBase {
    constructor() {
        super('amplify-index-transformer', graphql_directives_1.IndexDirective.definition);
        this.directiveList = [];
        this.resolverMap = new Map();
        this.field = (parent, definition, directive, context) => {
            const directiveWrapped = new graphql_transformer_core_1.DirectiveWrapper(directive);
            const args = directiveWrapped.getArguments({
                object: parent,
                field: definition,
                directive,
            }, (0, graphql_transformer_core_1.generateGetArgumentsInput)(context.transformParameters));
            args.sortKeyFields = getOrGenerateDefaultSortKeyFields(args);
            args.name = getOrGenerateDefaultName(args);
            args.queryField = getOrGenerateDefaultQueryField(context, args);
            args.sortKey = [];
            validate(args, context);
            this.directiveList.push(args);
        };
        this.after = (ctx) => {
            if (!ctx.isProjectUsingDataStore())
                return;
            this.resolverMap.forEach((syncVTLContent, resource) => {
                if (syncVTLContent) {
                    (0, resolvers_1.constructSyncVTL)(syncVTLContent, resource);
                }
            });
        };
        this.transformSchema = (ctx) => {
            const context = ctx;
            for (const config of this.directiveList) {
                (0, schema_1.ensureQueryField)(config, context);
                (0, schema_1.addKeyConditionInputs)(config, context);
                (0, schema_1.updateMutationConditionInput)(config, context);
            }
        };
        this.generateResolvers = (ctx) => {
            for (const config of this.directiveList) {
                (0, resolvers_1.appendSecondaryIndex)(config, ctx);
                (0, resolvers_1.updateResolversForIndex)(config, ctx, this.resolverMap);
            }
        };
    }
}
exports.IndexTransformer = IndexTransformer;
const getOrGenerateDefaultName = (config) => {
    const indexNameRegex = /^[A-Za-z0-9_\-\.]{3,255}$/;
    if (config.name) {
        if (!indexNameRegex.test(config.name)) {
            throw new Error(`The indexName is invalid. It should be between 3 and 255 characters. Only A–Z, a–z, 0–9, underscore characters, hyphens, and periods allowed.`);
        }
        return config.name;
    }
    if (config.name === null) {
        throw new Error('Explicit null value not allowed for name field on @index');
    }
    return (0, utils_1.generateKeyAndQueryNameForConfig)(config);
};
const getOrGenerateDefaultQueryField = (context, config) => {
    const autoIndexQueryNamesIsEnabled = context.transformParameters.enableAutoIndexQueryNames;
    if (config.queryField === null || (!autoIndexQueryNamesIsEnabled && !config.queryField)) {
        return null;
    }
    if (config.queryField) {
        return config.queryField;
    }
    return (0, utils_1.generateKeyAndQueryNameForConfig)(config);
};
const getOrGenerateDefaultSortKeyFields = (config) => {
    if (!config.sortKeyFields) {
        return [];
    }
    if (!Array.isArray(config.sortKeyFields)) {
        return [config.sortKeyFields];
    }
    return config.sortKeyFields;
};
const validate = (config, ctx) => {
    const { name, object, field, sortKeyFields } = config;
    (0, utils_1.validateNotSelfReferencing)(config);
    const modelDirective = object.directives.find((directive) => directive.name.value === 'model');
    if (!modelDirective) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`The @${graphql_directives_1.IndexDirective.name} directive may only be added to object definitions annotated with @model.`);
    }
    config.modelDirective = modelDirective;
    const fieldMap = new Map();
    for (const objectField of object.fields) {
        fieldMap.set(objectField.name.value, objectField);
        for (const peerDirective of objectField.directives) {
            if (peerDirective === config.directive) {
                continue;
            }
            if (peerDirective.name.value === 'primaryKey') {
                const hasSortFields = peerDirective.arguments.some((arg) => { var _a; return arg.name.value === 'sortKeyFields' && ((_a = arg.value.values) === null || _a === void 0 ? void 0 : _a.length) > 0; });
                config.primaryKeyField = objectField;
                if (!hasSortFields && objectField.name.value === field.name.value) {
                    throw new graphql_transformer_core_1.InvalidDirectiveError(`Invalid @index '${name}'. You may not create an index where the partition key ` +
                        'is the same as that of the primary key unless the primary key has a sort field. ' +
                        'You cannot have a local secondary index without a sort key in the primary key.');
                }
            }
            if (peerDirective.name.value === graphql_directives_1.IndexDirective.name &&
                peerDirective.arguments.some((arg) => arg.name.value === 'name' && arg.value.value === name)) {
                throw new graphql_transformer_core_1.InvalidDirectiveError(`You may only supply one @${graphql_directives_1.IndexDirective.name} with the name '${name}' on type '${object.name.value}'.`);
            }
        }
        for (const peerDirective of objectField.directives) {
            const hasSortFields = peerDirective.arguments.some((arg) => { var _a; return arg.name.value === 'sortKeyFields' && ((_a = arg.value.values) === null || _a === void 0 ? void 0 : _a.length) > 0; });
            if (!ctx.transformParameters.secondaryKeyAsGSI &&
                !hasSortFields &&
                objectField == config.primaryKeyField &&
                objectField.name.value === field.name.value) {
                throw new graphql_transformer_core_1.InvalidDirectiveError(`Invalid @index '${name}'. You may not create an index where the partition key ` +
                    'is the same as that of the primary key unless the index has a sort field. ' +
                    'You cannot have a local secondary index without a sort key in the index.');
            }
        }
    }
    const enums = ctx.output.getTypeDefinitionsOfKind(graphql_1.Kind.ENUM_TYPE_DEFINITION);
    if (!(0, graphql_transformer_common_1.isScalarOrEnum)(field.type, enums) || (0, graphql_transformer_common_1.isListType)(field.type)) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`Index '${name}' on type '${object.name.value}.${field.name.value}' cannot be a non-scalar.`);
    }
    for (const sortKeyFieldName of sortKeyFields) {
        const sortField = fieldMap.get(sortKeyFieldName);
        if (!sortField) {
            throw new graphql_transformer_core_1.InvalidDirectiveError(`Can't find field '${sortKeyFieldName}' in ${object.name.value}, but it was specified in index '${name}'.`);
        }
        if (!(0, graphql_transformer_common_1.isScalarOrEnum)(sortField.type, enums) || (0, graphql_transformer_common_1.isListType)(sortField.type)) {
            throw new graphql_transformer_core_1.InvalidDirectiveError(`The sort key of index '${name}' on type '${object.name.value}.${sortField.name.value}' cannot be a non-scalar.`);
        }
        config.sortKey.push(sortField);
    }
};
//# sourceMappingURL=graphql-index-transformer.js.map