"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getObjectPrimaryKey = exports.registerManyToManyForeignKeyMappings = exports.registerHasManyForeignKeyMappings = exports.registerHasOneForeignKeyMappings = exports.validateDisallowedDataStoreRelationships = exports.getBackendConnectionAttributeName = exports.getSortKeyConnectionAttributeName = exports.getManyToManyConnectionAttributeName = exports.getConnectionAttributeName = exports.validateRelatedModelDirective = exports.getBelongsToReferencesNodes = exports.getReferencesNodes = exports.getFieldsNodes = exports.getRelatedType = exports.validateModelDirective = exports.getModelDirective = exports.validateReferencesBidirectionality = exports.validateReferencesRelationalFieldNullability = exports.ensureReferencesArray = exports.ensureFieldsArray = exports.getRelatedTypeIndex = exports.validateChildReferencesFields = exports.validateParentReferencesFields = void 0;
const graphql_transformer_core_1 = require("@aws-amplify/graphql-transformer-core");
const graphql_1 = require("graphql");
const graphql_transformer_common_1 = require("graphql-transformer-common");
const graphql_directives_1 = require("@aws-amplify/graphql-directives");
const validateParentReferencesFields = (config, ctx) => {
    const { directiveName, object, references, relatedType } = config;
    const enums = ctx.output.getTypeDefinitionsOfKind(graphql_1.Kind.ENUM_TYPE_DEFINITION);
    const primaryKeys = (0, graphql_transformer_core_1.getPrimaryKeyFields)(object);
    if (primaryKeys.length !== references.length) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`The number of references provided to @${directiveName} must match the number of primary keys on ${object.name.value}.`);
    }
    for (const reference of references) {
        const fieldNode = relatedType.fields.find((field) => field.name.value === reference);
        if (!fieldNode) {
            throw new graphql_transformer_core_1.InvalidDirectiveError(`${reference} is not a field in ${relatedType.name.value}`);
        }
        if (!(0, graphql_transformer_common_1.isScalarOrEnum)(fieldNode.type, enums)) {
            throw new graphql_transformer_core_1.InvalidDirectiveError(`All reference fields provided to @${directiveName} must be scalar or enum fields.`);
        }
    }
};
exports.validateParentReferencesFields = validateParentReferencesFields;
const validateChildReferencesFields = (config, ctx) => {
    const { directiveName, object, references, relatedType } = config;
    const enums = ctx.output.getTypeDefinitionsOfKind(graphql_1.Kind.ENUM_TYPE_DEFINITION);
    const primaryKeys = (0, graphql_transformer_core_1.getPrimaryKeyFields)(relatedType);
    if (primaryKeys.length !== references.length) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`The number of references provided to @${directiveName} must match the number of primary keys on ${relatedType.name.value}.`);
    }
    for (const reference of references) {
        const fieldNode = object.fields.find((field) => field.name.value === reference);
        if (!fieldNode) {
            throw new graphql_transformer_core_1.InvalidDirectiveError(`${reference} is not a field in ${object.name.value}`);
        }
        if (!(0, graphql_transformer_common_1.isScalarOrEnum)(fieldNode.type, enums)) {
            throw new graphql_transformer_core_1.InvalidDirectiveError(`All reference fields provided to @${directiveName} must be scalar or enum fields.`);
        }
    }
};
exports.validateChildReferencesFields = validateChildReferencesFields;
const getRelatedTypeIndex = (config, ctx, indexName) => {
    const { directiveName, field, fieldNodes } = config;
    const relatedType = ctx.output.getType(config.relatedType.name.value);
    const fieldMap = new Map();
    let partitionFieldName;
    const sortFieldNames = [];
    const sortFields = [];
    for (const relatedTypeField of relatedType.fields) {
        fieldMap.set(relatedTypeField.name.value, relatedTypeField);
        for (const directive of relatedTypeField.directives) {
            const relatedDirectiveName = directive.name.value;
            const name = getIndexName(directive);
            if ((!indexName && relatedDirectiveName === 'primaryKey') || (indexName && indexName === name && relatedDirectiveName === 'index')) {
                partitionFieldName = relatedTypeField.name.value;
                for (const argument of directive.arguments) {
                    if (argument.name.value === 'sortKeyFields') {
                        if (argument.value.kind === graphql_1.Kind.STRING) {
                            sortFieldNames.push(argument.value.value);
                        }
                        else if (argument.value.kind === graphql_1.Kind.LIST) {
                            for (const keyField of argument.value.values) {
                                sortFieldNames.push(keyField.value);
                            }
                        }
                    }
                }
                break;
            }
        }
    }
    if (partitionFieldName === undefined) {
        if (indexName) {
            throw new graphql_transformer_core_1.InvalidDirectiveError(`Index ${indexName} does not exist for model ${relatedType.name.value}`);
        }
        partitionFieldName = 'id';
    }
    const partitionField = fieldMap.get(partitionFieldName);
    if (!partitionField) {
        throw new Error(`Expected partition field ${partitionFieldName} to be found in map.`);
    }
    for (const sortFieldName of sortFieldNames) {
        const sortField = fieldMap.get(sortFieldName);
        if (!sortField) {
            throw new Error(`Expected sort field ${sortFieldName} to be found in map.`);
        }
        sortFields.push(sortField);
    }
    if (fieldNodes.length > 0) {
        if ((0, graphql_transformer_common_1.getBaseType)(fieldNodes[0].type) !== (0, graphql_transformer_common_1.getBaseType)(partitionField.type)) {
            throw new graphql_transformer_core_1.InvalidDirectiveError(`${fieldNodes[0].name.value} field is not of type ${(0, graphql_transformer_common_1.getBaseType)(partitionField.type)}`);
        }
        if (fieldNodes.length > 1) {
            if (sortFields.length !== fieldNodes.length - 1) {
                throw new graphql_transformer_core_1.InvalidDirectiveError(`Invalid @${directiveName} directive on ${field.name.value}. Partial sort keys are not accepted.`);
            }
            for (let i = 0; i < sortFields.length; i++) {
                const sortField = sortFields[i];
                const fieldNode = fieldNodes[i + 1];
                if ((0, graphql_transformer_common_1.getBaseType)(fieldNode.type) !== (0, graphql_transformer_common_1.getBaseType)(sortField.type)) {
                    throw new graphql_transformer_core_1.InvalidDirectiveError(`${fieldNode.name.value} field is not of type ${(0, graphql_transformer_common_1.getBaseType)(sortField.type)}`);
                }
            }
        }
    }
    return [partitionField, ...sortFields];
};
exports.getRelatedTypeIndex = getRelatedTypeIndex;
const ensureFieldsArray = (config) => {
    if (config.references) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`'references' defined on ${config.object.name.value}.${config.field.name.value} @${config.directive}. Expecting 'fields' only.`);
    }
    if (!config.fields) {
        config.fields = [];
    }
    else if (!Array.isArray(config.fields)) {
        config.fields = [config.fields];
    }
    else if (config.fields.length === 0) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`No fields passed to @${config.directiveName} directive.`);
    }
};
exports.ensureFieldsArray = ensureFieldsArray;
const ensureReferencesArray = (config) => {
    if (config.fields) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`'fields' defined on ${config.object.name.value}.${config.field.name.value} @${config.directive}. Expecting 'references' only.`);
    }
    if (!config.references) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`Reference fields must be passed to @${config.directiveName} directive for SQL models.`);
    }
    else if (!Array.isArray(config.references)) {
        config.references = [config.references];
    }
    else if (config.references.length === 0) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`No reference fields passed to @${config.directiveName} directive.`);
    }
};
exports.ensureReferencesArray = ensureReferencesArray;
const getReferencesAssociatedField = (config) => {
    var _a;
    const { object } = config;
    const expectedBidirectionalErrorMessages = () => {
        const associatedDirectiveTypes = getAssociatedRelationalDirectiveTypes(config.directiveName);
        const primaryType = config.directiveName == graphql_directives_1.BelongsToDirective.name ? config.relatedType.name.value : config.object.name.value;
        const associatedDirectiveDescription = associatedDirectiveTypes.map((directiveName) => `@${directiveName}`).join(' or ');
        return (`Add a ${associatedDirectiveDescription} field in ${config.relatedType.name.value} to match the @${config.directiveName} ` +
            `field ${config.object.name.value}.${config.field.name.value}, and ensure the number and type of reference fields match the ` +
            `number and type of primary key fields in ${primaryType}.`);
    };
    const associatedConnection = (_a = config.relatedType.fields) === null || _a === void 0 ? void 0 : _a.flatMap((associatedField) => {
        var _a, _b, _c;
        if ((0, graphql_transformer_common_1.getBaseType)(associatedField.type) !== object.name.value) {
            return [];
        }
        const associatedRelationalDirective = (_a = associatedField.directives) === null || _a === void 0 ? void 0 : _a.find((directive) => {
            return getAssociatedRelationalDirectiveTypes(config.directiveName)
                .map((directiveType) => directiveType)
                .includes(directive.name.value);
        });
        if (!associatedRelationalDirective) {
            return [];
        }
        const associatedDirectiveReferencesArgNode = (_c = (_b = associatedRelationalDirective.arguments) === null || _b === void 0 ? void 0 : _b.find((arg) => arg.name.value === 'references')) === null || _c === void 0 ? void 0 : _c.value;
        const getReferencesFromArgNode = (argument) => {
            if (argument.kind === 'ListValue') {
                return argument.values.map((value) => value.value);
            }
            return [argument.value];
        };
        const associatedReferences = getReferencesFromArgNode(associatedDirectiveReferencesArgNode);
        const expectedReferenceFields = config.referenceNodes.map((node) => node.name.value).join(',');
        const actualAssociatedReferenceFields = associatedReferences.join(',');
        if (expectedReferenceFields !== actualAssociatedReferenceFields) {
            return [];
        }
        return [
            {
                associatedField,
                associatedReferences,
            },
        ];
    });
    if (!associatedConnection || associatedConnection.length === 0) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`Uni-directional relationships are not supported. ${expectedBidirectionalErrorMessages()}`);
    }
    return associatedConnection[0];
};
const referenceFieldTypeMatchesPrimaryKey = (a, b) => {
    const areEquivalentTypes = (c, d) => {
        const matching = ['ID', 'String'];
        return c === d || (matching.includes(c) && matching.includes(d));
    };
    const typeA = (0, graphql_transformer_common_1.unwrapNonNull)(a.type).name.value;
    const typeB = (0, graphql_transformer_common_1.unwrapNonNull)(b.type).name.value;
    return areEquivalentTypes(typeA, typeB);
};
const validateReferencesRelationalFieldNullability = (config) => {
    const { field, object, relatedType } = config;
    const fieldType = field.type;
    const relatedTypeName = relatedType.name.value;
    if (fieldType.kind === graphql_1.Kind.NON_NULL_TYPE) {
        const fieldDescription = `${object.name.value}.${field.name.value}: ` +
            `${config.directiveName === graphql_directives_1.HasManyDirective.name ? `[${relatedTypeName}]` : relatedTypeName}`;
        throw new graphql_transformer_core_1.InvalidDirectiveError(`@${config.directiveName} fields must not be required. Change '${fieldDescription}!' to '${fieldDescription}'`);
    }
    if (fieldType.kind === graphql_1.Kind.LIST_TYPE && fieldType.type.kind === graphql_1.Kind.NON_NULL_TYPE) {
        const fieldDescription = (typeDescription) => {
            return `${config.object.name.value}.${config.field.name.value}: ${typeDescription}`;
        };
        const relatedTypeIs = config.directiveName === graphql_directives_1.HasManyDirective.name ? `[${relatedTypeName}!]` : `${relatedTypeName}!`;
        const relatedTypeShould = config.directiveName === graphql_directives_1.HasManyDirective.name ? `[${relatedTypeName}]` : `${relatedTypeName}`;
        throw new graphql_transformer_core_1.InvalidDirectiveError(`@${config.directiveName} fields must not be required. Change '${fieldDescription(relatedTypeIs)}' to '${fieldDescription(relatedTypeShould)}'`);
    }
};
exports.validateReferencesRelationalFieldNullability = validateReferencesRelationalFieldNullability;
const validateReferencesBidirectionality = (config) => {
    const { directiveName, object, references, referenceNodes, relatedType } = config;
    const { associatedReferences } = getReferencesAssociatedField(config);
    const primaryModel = directiveName === 'belongsTo' ? relatedType : object;
    const relatedModel = directiveName === 'belongsTo' ? object : relatedType;
    const primaryKeys = (0, graphql_transformer_core_1.getPrimaryKeyFieldNodes)(primaryModel);
    const primaryModelName = primaryModel.name.value;
    const relatedModelName = relatedModel.name.value;
    if (!(references.length === associatedReferences.length) ||
        !references.every((reference, index) => reference === associatedReferences[index])) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`The number and type of the reference fields [${associatedReferences.join(',')}] defined for the ${directiveName} relationship ` +
            `between ${primaryModelName} and ${relatedModelName} must match the number and type of the primary key fields in ` +
            `${primaryModelName}.`);
    }
    primaryKeys
        .map((key, index) => [key, referenceNodes[index]])
        .forEach(([primaryKey, referenceField]) => {
        if (!referenceFieldTypeMatchesPrimaryKey(primaryKey, referenceField)) {
            throw new graphql_transformer_core_1.InvalidDirectiveError(`Type mismatch between primary key field(s) of ${primaryModelName}` +
                ` and reference fields of ${relatedModelName}.` +
                ` Type of ${primaryModelName}.${primaryKey.name.value} does not match type of ${relatedModelName}.${referenceField.name.value}`);
        }
    });
};
exports.validateReferencesBidirectionality = validateReferencesBidirectionality;
const getModelDirective = (objectType) => {
    return objectType.directives.find((directive) => directive.name.value === 'model');
};
exports.getModelDirective = getModelDirective;
const validateModelDirective = (config) => {
    if (!(0, exports.getModelDirective)(config.object)) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`@${config.directiveName} must be on an @model object type field.`);
    }
};
exports.validateModelDirective = validateModelDirective;
const getRelatedType = (config, ctx) => {
    const { field } = config;
    const relatedTypeName = (0, graphql_transformer_common_1.getBaseType)(field.type);
    const relatedType = ctx.inputDocument.definitions.find((d) => d.kind === graphql_1.Kind.OBJECT_TYPE_DEFINITION && d.name.value === relatedTypeName);
    if (!relatedType) {
        const outputRelatedType = ctx.output.getObject(relatedTypeName);
        if (outputRelatedType) {
            return outputRelatedType;
        }
        else {
            throw new Error(`Could not find related type with name ${relatedTypeName} while processing relationships.`);
        }
    }
    return relatedType;
};
exports.getRelatedType = getRelatedType;
const getFieldsNodes = (config, ctx) => {
    const { directiveName, fields, object } = config;
    const enums = ctx.output.getTypeDefinitionsOfKind(graphql_1.Kind.ENUM_TYPE_DEFINITION);
    return fields.map((fieldName) => {
        const fieldNode = object.fields.find((field) => field.name.value === fieldName);
        if (!fieldNode) {
            throw new graphql_transformer_core_1.InvalidDirectiveError(`${fieldName} is not a field in ${object.name.value}`);
        }
        if (!(0, graphql_transformer_common_1.isScalarOrEnum)(fieldNode.type, enums)) {
            throw new graphql_transformer_core_1.InvalidDirectiveError(`All fields provided to @${directiveName} must be scalar or enum fields.`);
        }
        return fieldNode;
    });
};
exports.getFieldsNodes = getFieldsNodes;
const getAssociatedRelationalDirectiveTypes = (sourceRelationalDirectiveType) => {
    switch (sourceRelationalDirectiveType) {
        case graphql_directives_1.HasOneDirective.name:
        case graphql_directives_1.HasManyDirective.name:
            return [graphql_directives_1.BelongsToDirective.name];
        case graphql_directives_1.BelongsToDirective.name:
            return [graphql_directives_1.HasOneDirective.name, graphql_directives_1.HasManyDirective.name];
        default:
            throw new Error(`Unexpected directive type ${sourceRelationalDirectiveType}`);
    }
};
const getReferencesNodes = (config, ctx) => {
    const { directiveName, references, relatedType } = config;
    const enums = ctx.output.getTypeDefinitionsOfKind(graphql_1.Kind.ENUM_TYPE_DEFINITION);
    const referenceNodes = references.map((fieldName) => {
        const fieldNode = relatedType.fields.find((field) => field.name.value === fieldName);
        if (!fieldNode) {
            throw new graphql_transformer_core_1.InvalidDirectiveError(`${fieldName} is not a field in ${relatedType.name.value}`);
        }
        if (!(0, graphql_transformer_common_1.isScalarOrEnum)(fieldNode.type, enums)) {
            throw new graphql_transformer_core_1.InvalidDirectiveError(`All references provided to @${directiveName} must be scalar or enum fields.`);
        }
        return fieldNode;
    });
    const firstReferenceNodeIsNonNull = referenceNodes[0].type.kind === graphql_1.Kind.NON_NULL_TYPE;
    referenceNodes.slice(1).forEach((referenceNode) => {
        const isNonNull = referenceNode.type.kind === graphql_1.Kind.NON_NULL_TYPE;
        if (isNonNull !== firstReferenceNodeIsNonNull) {
            const nonNullReferenceFields = referenceNodes
                .filter((node) => node.type.kind === graphql_1.Kind.NON_NULL_TYPE)
                .map((node) => `'${node.name.value}'`)
                .join(', ');
            const nullableReferenceFields = referenceNodes
                .filter((node) => node.type.kind !== graphql_1.Kind.NON_NULL_TYPE)
                .map((node) => `'${node.name.value}'`)
                .join(', ');
            const referencesDescription = '[' + references.map((reference) => `'${reference}'`).join(', ') + ']';
            const fieldDescription = `@${directiveName}(references: ${referencesDescription}) ${config.object.name.value}.${config.field.name.value}`;
            throw new graphql_transformer_core_1.InvalidDirectiveError(`Reference fields defined on related type: '${relatedType.name.value}' for ${fieldDescription} relationship have inconsistent nullability.` +
                `\nRequired fields: ${nonNullReferenceFields}` +
                `\nNullable fields: ${nullableReferenceFields}` +
                `\nUpdate reference fields on type '${relatedType.name.value}' to have consistent nullability -- either all required or all nullable.`);
        }
    });
    return referenceNodes;
};
exports.getReferencesNodes = getReferencesNodes;
const getBelongsToReferencesNodes = (config, ctx) => {
    const { directiveName, references, object } = config;
    const enums = ctx.output.getTypeDefinitionsOfKind(graphql_1.Kind.ENUM_TYPE_DEFINITION);
    return references.map((fieldName) => {
        const fieldNode = object.fields.find((field) => field.name.value === fieldName);
        if (!fieldNode) {
            throw new graphql_transformer_core_1.InvalidDirectiveError(`${fieldName} is not a field in ${object.name.value}`);
        }
        if (!(0, graphql_transformer_common_1.isScalarOrEnum)(fieldNode.type, enums)) {
            throw new graphql_transformer_core_1.InvalidDirectiveError(`All references provided to @${directiveName} must be scalar or enum fields.`);
        }
        return fieldNode;
    });
};
exports.getBelongsToReferencesNodes = getBelongsToReferencesNodes;
const validateRelatedModelDirective = (config) => {
    if (!(0, exports.getModelDirective)(config.relatedType)) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`Object type ${config.relatedType.name.value} must be annotated with @model.`);
    }
};
exports.validateRelatedModelDirective = validateRelatedModelDirective;
const getIndexName = (directive) => {
    for (const argument of directive.arguments) {
        if (argument.name.value === 'name') {
            return argument.value.value;
        }
    }
    return undefined;
};
const getConnectionAttributeName = (transformParameters, type, field, relatedTypeField) => {
    const nameSuffix = transformParameters.respectPrimaryKeyAttributesOnConnectionField ? relatedTypeField : 'id';
    return (0, graphql_transformer_common_1.toCamelCase)([type, field, nameSuffix]);
};
exports.getConnectionAttributeName = getConnectionAttributeName;
const getManyToManyConnectionAttributeName = (transformParameters, field, relatedTypeField) => {
    const nameSuffix = transformParameters.respectPrimaryKeyAttributesOnConnectionField ? (0, graphql_transformer_common_1.toPascalCase)([relatedTypeField]) : 'ID';
    return `${(0, graphql_transformer_common_1.toCamelCase)([field])}${nameSuffix}`;
};
exports.getManyToManyConnectionAttributeName = getManyToManyConnectionAttributeName;
const getSortKeyConnectionAttributeName = (type, field, relatedTypeField) => {
    return (0, graphql_transformer_common_1.toCamelCase)([type, field, relatedTypeField]);
};
exports.getSortKeyConnectionAttributeName = getSortKeyConnectionAttributeName;
const getBackendConnectionAttributeName = (transformParameters, resourceHelper, type, field, relatedTypeField) => {
    return (0, exports.getConnectionAttributeName)(transformParameters, resourceHelper.getModelNameMapping(type), field, relatedTypeField);
};
exports.getBackendConnectionAttributeName = getBackendConnectionAttributeName;
const validateDisallowedDataStoreRelationships = (config, ctx) => {
    if (!ctx.isProjectUsingDataStore()) {
        return;
    }
    const modelType = config.object.name.value;
    const relatedType = ctx.output.getType(config.relatedType.name.value);
    if (!relatedType) {
        throw new Error(`Expected related type ${config.relatedType.name.value} to be found in output, but did not.`);
    }
    if (modelType === relatedType.name.value) {
        return;
    }
    const hasUnsupportedConnectionFields = relatedType.fields.some((field) => (0, graphql_transformer_common_1.getBaseType)(field.type) === modelType &&
        field.directives.some((directive) => directive.name.value === 'hasOne' || directive.name.value === 'hasMany'));
    if (hasUnsupportedConnectionFields) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`${modelType} and ${relatedType.name.value} cannot refer to each other via @hasOne or @hasMany when DataStore is in use. Use @belongsTo instead. See https://docs.amplify.aws/cli/graphql/data-modeling/#belongs-to-relationship`);
    }
};
exports.validateDisallowedDataStoreRelationships = validateDisallowedDataStoreRelationships;
const registerHasOneForeignKeyMappings = ({ transformParameters, resourceHelper, thisTypeName, thisFieldName, relatedType, }) => {
    if (resourceHelper.isModelRenamed(thisTypeName)) {
        const currAttrName = (0, exports.getConnectionAttributeName)(transformParameters, thisTypeName, thisFieldName, (0, exports.getObjectPrimaryKey)(relatedType).name.value);
        const origAttrName = (0, exports.getBackendConnectionAttributeName)(transformParameters, resourceHelper, thisTypeName, thisFieldName, (0, exports.getObjectPrimaryKey)(relatedType).name.value);
        const modelFieldMap = resourceHelper.getModelFieldMap(thisTypeName);
        modelFieldMap.addMappedField({ currentFieldName: currAttrName, originalFieldName: origAttrName });
        ['create', 'update', 'delete', 'get', 'list', 'sync'].forEach((op) => {
            const opFieldName = (0, graphql_transformer_core_1.getFieldNameFor)(op, thisTypeName);
            const opTypeName = op === 'create' || op === 'update' || op === 'delete' ? 'Mutation' : 'Query';
            const opIsList = op === 'list' || op === 'sync';
            modelFieldMap.addResolverReference({ typeName: opTypeName, fieldName: opFieldName, isList: opIsList });
        });
    }
    resourceHelper
        .getModelFieldMap(relatedType.name.value)
        .addResolverReference({ typeName: thisTypeName, fieldName: thisFieldName, isList: false });
};
exports.registerHasOneForeignKeyMappings = registerHasOneForeignKeyMappings;
const registerHasManyForeignKeyMappings = ({ transformParameters, resourceHelper, thisTypeName, thisFieldName, relatedType, }) => {
    if (!resourceHelper.isModelRenamed(thisTypeName)) {
        return;
    }
    const currAttrName = (0, exports.getConnectionAttributeName)(transformParameters, thisTypeName, thisFieldName, (0, exports.getObjectPrimaryKey)(relatedType).name.value);
    const origAttrName = (0, exports.getBackendConnectionAttributeName)(transformParameters, resourceHelper, thisTypeName, thisFieldName, (0, exports.getObjectPrimaryKey)(relatedType).name.value);
    const modelFieldMap = resourceHelper.getModelFieldMap(relatedType.name.value);
    modelFieldMap
        .addMappedField({ currentFieldName: currAttrName, originalFieldName: origAttrName })
        .addResolverReference({ typeName: thisTypeName, fieldName: thisFieldName, isList: true });
    ['create', 'update', 'delete', 'get', 'list', 'sync'].forEach((op) => {
        const opFieldName = (0, graphql_transformer_core_1.getFieldNameFor)(op, relatedType.name.value);
        const opTypeName = op === 'create' || op === 'update' || op === 'delete' ? 'Mutation' : 'Query';
        const opIsList = op === 'list' || op === 'sync';
        modelFieldMap.addResolverReference({ typeName: opTypeName, fieldName: opFieldName, isList: opIsList });
    });
};
exports.registerHasManyForeignKeyMappings = registerHasManyForeignKeyMappings;
const registerManyToManyForeignKeyMappings = ({ resourceHelper, typeName, referencedBy, fieldMap, }) => {
    const modelFieldMap = resourceHelper.getModelFieldMap(typeName);
    fieldMap.forEach(modelFieldMap.addMappedField);
    referencedBy.forEach(modelFieldMap.addResolverReference);
    ['create', 'update', 'delete', 'get', 'list', 'sync'].forEach((op) => {
        const opFieldName = (0, graphql_transformer_core_1.getFieldNameFor)(op, typeName);
        const opTypeName = op === 'create' || op === 'update' || op === 'delete' ? 'Mutation' : 'Query';
        const opIsList = op === 'list' || op === 'sync';
        modelFieldMap.addResolverReference({ typeName: opTypeName, fieldName: opFieldName, isList: opIsList });
    });
};
exports.registerManyToManyForeignKeyMappings = registerManyToManyForeignKeyMappings;
const getObjectPrimaryKey = (object) => {
    let primaryKey = (0, graphql_transformer_common_1.makeField)('id', [], (0, graphql_transformer_common_1.makeNonNullType)((0, graphql_transformer_common_1.makeNamedType)('ID')));
    object.fields.forEach((objectField) => {
        objectField.directives.forEach((directive) => {
            if (directive.name.value === 'primaryKey') {
                primaryKey = objectField;
            }
        });
    });
    return primaryKey;
};
exports.getObjectPrimaryKey = getObjectPrimaryKey;
//# sourceMappingURL=utils.js.map