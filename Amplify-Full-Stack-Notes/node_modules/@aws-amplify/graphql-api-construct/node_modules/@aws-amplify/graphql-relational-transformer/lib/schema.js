"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.convertSortKeyFieldsToSortKeyConnectionFields = exports.addFieldsToDefinition = exports.getSortKeyFieldsNoContext = exports.getSortKeyFields = exports.getPartitionKeyFieldNoContext = exports.getPartitionKeyField = exports.ensureHasManyConnectionField = exports.ensureBelongsToConnectionField = exports.ensureHasOneConnectionField = exports.extendTypeWithConnection = void 0;
const graphql_model_transformer_1 = require("@aws-amplify/graphql-model-transformer");
const graphql_1 = require("graphql");
const graphql_transformer_common_1 = require("graphql-transformer-common");
const graphql_transformer_core_1 = require("@aws-amplify/graphql-transformer-core");
const utils_1 = require("./utils");
const extendTypeWithConnection = (config, ctx) => {
    const { field, object } = config;
    generateModelXConnectionType(config, ctx);
    const type = ctx.output.getType(object.name.value);
    if ((type === null || type === void 0 ? void 0 : type.kind) !== graphql_1.Kind.OBJECT_TYPE_DEFINITION && (type === null || type === void 0 ? void 0 : type.kind) !== graphql_1.Kind.INTERFACE_TYPE_DEFINITION) {
        throw new Error(`Expected referenced type to be either and object or interface definition, got ${type === null || type === void 0 ? void 0 : type.kind}`);
    }
    const newFields = type.fields.map((f) => {
        if (f.name.value === field.name.value) {
            return makeModelConnectionField(config);
        }
        return f;
    });
    const updatedType = {
        ...type,
        fields: newFields,
    };
    ctx.output.putType(updatedType);
    ensureModelSortDirectionEnum(ctx);
    generateFilterAndKeyConditionInputs(config, ctx);
};
exports.extendTypeWithConnection = extendTypeWithConnection;
const generateModelXConnectionType = (config, ctx) => {
    const { relatedType } = config;
    const tableXConnectionName = graphql_transformer_common_1.ModelResourceIDs.ModelConnectionTypeName(relatedType.name.value);
    if (ctx.output.hasType(tableXConnectionName)) {
        return;
    }
    const connectionType = (0, graphql_transformer_common_1.blankObject)(tableXConnectionName);
    let connectionTypeExtension = (0, graphql_transformer_common_1.blankObjectExtension)(tableXConnectionName);
    connectionTypeExtension = (0, graphql_transformer_common_1.extensionWithFields)(connectionTypeExtension, [
        (0, graphql_transformer_common_1.makeField)('items', [], (0, graphql_transformer_common_1.makeNonNullType)((0, graphql_transformer_common_1.makeListType)((0, graphql_transformer_common_1.makeNamedType)(relatedType.name.value)))),
    ]);
    connectionTypeExtension = (0, graphql_transformer_common_1.extensionWithFields)(connectionTypeExtension, [(0, graphql_transformer_common_1.makeField)('nextToken', [], (0, graphql_transformer_common_1.makeNamedType)('String'))]);
    ctx.output.addObject(connectionType);
    ctx.output.addObjectExtension(connectionTypeExtension);
};
const generateFilterAndKeyConditionInputs = (config, ctx) => {
    const { relatedTypeIndex } = config;
    const tableXQueryFilterInput = makeModelXFilterInputObject(config, ctx);
    if (!ctx.output.hasType(tableXQueryFilterInput.name.value)) {
        ctx.output.addInput(tableXQueryFilterInput);
    }
    if (relatedTypeIndex && relatedTypeIndex.length === 2) {
        const sortKeyType = relatedTypeIndex[1].type;
        const baseType = (0, graphql_transformer_common_1.getBaseType)(sortKeyType);
        const namedType = (0, graphql_transformer_common_1.makeNamedType)(baseType);
        const sortKeyConditionInput = (0, graphql_transformer_common_1.makeScalarKeyConditionForType)(namedType);
        if (!ctx.output.hasType(sortKeyConditionInput.name.value)) {
            ctx.output.addInput(sortKeyConditionInput);
        }
    }
};
const ensureModelSortDirectionEnum = (ctx) => {
    if (!ctx.output.hasType('ModelSortDirection')) {
        const modelSortDirection = (0, graphql_model_transformer_1.makeModelSortDirectionEnumObject)();
        ctx.output.addEnum(modelSortDirection);
    }
};
const ensureHasOneConnectionField = (config, ctx) => {
    const { field, fieldNodes, references, object, relatedType } = config;
    if ((fieldNodes === null || fieldNodes === void 0 ? void 0 : fieldNodes.length) > 0) {
        return;
    }
    if (references && references.length > 0) {
        return;
    }
    const primaryKeyField = (0, utils_1.getObjectPrimaryKey)(relatedType);
    const connectionAttributeName = (0, utils_1.getConnectionAttributeName)(ctx.transformParameters, object.name.value, field.name.value, primaryKeyField.name.value);
    const sortKeyFields = (0, exports.getSortKeyFields)(ctx, relatedType);
    const primaryKeyConnectionFieldType = getPrimaryKeyConnectionFieldType(ctx, primaryKeyField);
    const isConnectionFieldsNonNull = (0, graphql_transformer_common_1.isNonNullType)(field.type);
    const typeObject = ctx.output.getType(object.name.value);
    if (typeObject) {
        updateTypeWithConnectionFields(ctx, typeObject, object, connectionAttributeName, primaryKeyConnectionFieldType, field, sortKeyFields, isConnectionFieldsNonNull);
    }
    const createInputName = graphql_transformer_common_1.ModelResourceIDs.ModelCreateInputObjectName(object.name.value);
    const createInput = ctx.output.getType(createInputName);
    if (createInput) {
        updateInputWithConnectionFields(ctx, createInput, object, connectionAttributeName, primaryKeyConnectionFieldType, field, sortKeyFields, isConnectionFieldsNonNull);
    }
    const updateInputName = graphql_transformer_common_1.ModelResourceIDs.ModelUpdateInputObjectName(object.name.value);
    const updateInput = ctx.output.getType(updateInputName);
    if (updateInput) {
        updateInputWithConnectionFields(ctx, updateInput, object, connectionAttributeName, primaryKeyConnectionFieldType, field, sortKeyFields, false);
    }
    const filterInputName = (0, graphql_transformer_common_1.toPascalCase)(['Model', object.name.value, 'FilterInput']);
    const filterInput = ctx.output.getType(filterInputName);
    if (filterInput) {
        updateFilterConnectionInputWithConnectionFields(ctx, filterInput, object, connectionAttributeName, primaryKeyConnectionFieldType, field, sortKeyFields);
    }
    const conditionInputName = (0, graphql_transformer_common_1.toPascalCase)(['Model', object.name.value, 'ConditionInput']);
    const conditionInput = ctx.output.getType(conditionInputName);
    if (conditionInput) {
        updateFilterConnectionInputWithConnectionFields(ctx, conditionInput, object, connectionAttributeName, primaryKeyConnectionFieldType, field, sortKeyFields);
    }
    const subscriptionFilterInputName = (0, graphql_transformer_core_1.getSubscriptionFilterInputName)(object.name.value);
    const filterSubscriptionInput = ctx.output.getType(subscriptionFilterInputName);
    if (filterSubscriptionInput) {
        updateFilterConnectionInputWithConnectionFields(ctx, filterSubscriptionInput, object, connectionAttributeName, primaryKeyConnectionFieldType, field, sortKeyFields, true);
    }
    config.connectionFields.push(connectionAttributeName);
    config.connectionFields.push(...(0, graphql_transformer_core_1.getSortKeyFieldNames)(relatedType).map((it) => (0, utils_1.getSortKeyConnectionAttributeName)(object.name.value, field.name.value, it)));
};
exports.ensureHasOneConnectionField = ensureHasOneConnectionField;
const ensureBelongsToConnectionField = (config, ctx) => {
    const { relationType, relatedType, references, relatedField } = config;
    if (relationType === 'hasOne' || (references && references.length > 0)) {
        (0, exports.ensureHasOneConnectionField)(config, ctx);
    }
    else {
        const primaryKeyField = (0, utils_1.getObjectPrimaryKey)(relatedType);
        config.connectionFields.push((0, utils_1.getConnectionAttributeName)(ctx.transformParameters, relatedType.name.value, relatedField.name.value, primaryKeyField.name.value));
        config.connectionFields.push(...(0, graphql_transformer_core_1.getSortKeyFieldNames)(relatedType).map((it) => (0, utils_1.getSortKeyConnectionAttributeName)(relatedType.name.value, relatedField.name.value, it)));
    }
};
exports.ensureBelongsToConnectionField = ensureBelongsToConnectionField;
const ensureHasManyConnectionField = (config, ctx) => {
    const { field, fieldNodes, object, relatedType, references } = config;
    if ((fieldNodes === null || fieldNodes === void 0 ? void 0 : fieldNodes.length) > 0) {
        return;
    }
    if (references && references.length > 0) {
        return;
    }
    const sortKeyFields = (0, exports.getSortKeyFields)(ctx, object);
    const primaryKeyField = (0, utils_1.getObjectPrimaryKey)(object);
    const connectionFieldName = primaryKeyField.name.value;
    config.connectionFields.push(connectionFieldName, ...sortKeyFields.map((it) => it.name.value));
    const relatedTypeObject = ctx.output.getType(relatedType.name.value);
    const connectionAttributeName = (0, utils_1.getConnectionAttributeName)(ctx.transformParameters, object.name.value, field.name.value, connectionFieldName);
    const isConnectionFieldsNonNull = (0, graphql_transformer_common_1.isNonNullType)(field.type);
    const primaryKeyConnectionFieldType = getPrimaryKeyConnectionFieldType(ctx, primaryKeyField);
    if (relatedTypeObject) {
        updateTypeWithConnectionFields(ctx, relatedTypeObject, object, connectionAttributeName, primaryKeyConnectionFieldType, field, sortKeyFields, isConnectionFieldsNonNull);
    }
    const createInputName = graphql_transformer_common_1.ModelResourceIDs.ModelCreateInputObjectName(relatedType.name.value);
    const createInput = ctx.output.getType(createInputName);
    if (createInput) {
        updateInputWithConnectionFields(ctx, createInput, object, connectionAttributeName, primaryKeyConnectionFieldType, field, sortKeyFields, isConnectionFieldsNonNull);
    }
    const updateInputName = graphql_transformer_common_1.ModelResourceIDs.ModelUpdateInputObjectName(relatedType.name.value);
    const updateInput = ctx.output.getType(updateInputName);
    if (updateInput) {
        updateInputWithConnectionFields(ctx, updateInput, object, connectionAttributeName, primaryKeyConnectionFieldType, field, sortKeyFields, false);
    }
    const filterInputName = (0, graphql_transformer_common_1.toPascalCase)(['Model', relatedType.name.value, 'FilterInput']);
    const filterInput = ctx.output.getType(filterInputName);
    if (filterInput) {
        updateFilterConnectionInputWithConnectionFields(ctx, filterInput, object, connectionAttributeName, primaryKeyConnectionFieldType, field, sortKeyFields);
    }
    const conditionInputName = (0, graphql_transformer_common_1.toPascalCase)(['Model', relatedType.name.value, 'ConditionInput']);
    const conditionInput = ctx.output.getType(conditionInputName);
    if (conditionInput) {
        updateFilterConnectionInputWithConnectionFields(ctx, conditionInput, object, connectionAttributeName, primaryKeyConnectionFieldType, field, sortKeyFields);
    }
    const subscriptionFilterInputName = (0, graphql_transformer_core_1.getSubscriptionFilterInputName)(object.name.value);
    const filterSubscriptionInput = ctx.output.getType(subscriptionFilterInputName);
    if (filterSubscriptionInput) {
        updateFilterConnectionInputWithConnectionFields(ctx, filterSubscriptionInput, object, connectionAttributeName, primaryKeyConnectionFieldType, field, sortKeyFields, true);
    }
};
exports.ensureHasManyConnectionField = ensureHasManyConnectionField;
const getTypeFieldsWithConnectionField = (objectFields, connectionFieldName, type, nonNull = false) => {
    const keyFieldExists = objectFields.some((f) => f.name.value === connectionFieldName);
    if (keyFieldExists) {
        return [];
    }
    return [(0, graphql_transformer_common_1.makeField)(connectionFieldName, [], nonNull ? (0, graphql_transformer_common_1.makeNonNullType)((0, graphql_transformer_common_1.makeNamedType)(type)) : (0, graphql_transformer_common_1.makeNamedType)(type), [])];
};
const getInputFieldsWithConnectionField = (inputFields, connectionFieldName, type, nonNull = false) => {
    const keyFieldExists = inputFields.some((f) => f.name.value === connectionFieldName);
    if (keyFieldExists) {
        return [];
    }
    return [(0, graphql_transformer_common_1.makeInputValueDefinition)(connectionFieldName, nonNull ? (0, graphql_transformer_common_1.makeNonNullType)((0, graphql_transformer_common_1.makeNamedType)(type)) : (0, graphql_transformer_common_1.makeNamedType)(type))];
};
const getFilterConnectionInputFieldsWithConnectionField = (inputFields, connectionFieldName, type) => {
    const keyFieldExists = inputFields.some((f) => f.name.value === connectionFieldName);
    if (keyFieldExists) {
        return [];
    }
    return [(0, graphql_transformer_common_1.makeInputValueDefinition)(connectionFieldName, (0, graphql_transformer_common_1.makeNamedType)(type))];
};
const makeModelConnectionField = (config) => {
    const { field, fields, indexName, relatedType, relatedTypeIndex } = config;
    const args = [
        (0, graphql_transformer_common_1.makeInputValueDefinition)('filter', (0, graphql_transformer_common_1.makeNamedType)(graphql_transformer_common_1.ModelResourceIDs.ModelFilterInputTypeName(relatedType.name.value))),
        (0, graphql_transformer_common_1.makeInputValueDefinition)('sortDirection', (0, graphql_transformer_common_1.makeNamedType)('ModelSortDirection')),
        (0, graphql_transformer_common_1.makeInputValueDefinition)('limit', (0, graphql_transformer_common_1.makeNamedType)('Int')),
        (0, graphql_transformer_common_1.makeInputValueDefinition)('nextToken', (0, graphql_transformer_common_1.makeNamedType)('String')),
    ];
    if (fields && fields.length < 2 && relatedTypeIndex.length > 1) {
        let fieldName;
        let namedType;
        if (relatedTypeIndex.length === 2) {
            const sortKeyField = relatedTypeIndex[1];
            const baseType = (0, graphql_transformer_common_1.getBaseType)(sortKeyField.type);
            fieldName = sortKeyField.name.value;
            namedType = (0, graphql_transformer_common_1.makeNamedType)(graphql_transformer_common_1.ModelResourceIDs.ModelKeyConditionInputTypeName(baseType));
        }
        else {
            const sortKeyFieldNames = relatedTypeIndex.slice(1).map((relatedTypeField) => relatedTypeField.name.value);
            fieldName = (0, graphql_transformer_common_1.toCamelCase)(sortKeyFieldNames);
            namedType = (0, graphql_transformer_common_1.makeNamedType)(graphql_transformer_common_1.ModelResourceIDs.ModelCompositeKeyConditionInputTypeName(relatedType.name.value, (0, graphql_transformer_common_1.toUpper)(indexName !== null && indexName !== void 0 ? indexName : 'Primary')));
        }
        args.unshift((0, graphql_transformer_common_1.makeInputValueDefinition)(fieldName, namedType));
    }
    return (0, graphql_transformer_common_1.makeField)(field.name.value, args, (0, graphql_transformer_common_1.makeNamedType)(graphql_transformer_common_1.ModelResourceIDs.ModelConnectionTypeName(relatedType.name.value)), field.directives);
};
const makeModelXFilterInputObject = (config, ctx) => {
    const { relatedType } = config;
    const name = graphql_transformer_common_1.ModelResourceIDs.ModelFilterInputTypeName(relatedType.name.value);
    const fields = relatedType
        .fields.filter((field) => {
        const fieldType = ctx.output.getType((0, graphql_transformer_common_1.getBaseType)(field.type));
        return (0, graphql_transformer_common_1.isScalar)(field.type) || (fieldType && fieldType.kind === graphql_1.Kind.ENUM_TYPE_DEFINITION);
    })
        .map((field) => {
        const baseType = (0, graphql_transformer_common_1.getBaseType)(field.type);
        const isList = (0, graphql_transformer_common_1.isListType)(field.type);
        const fieldType = ctx.output.getType((0, graphql_transformer_common_1.getBaseType)(field.type));
        let filterTypeName = baseType;
        if ((0, graphql_transformer_common_1.isScalar)(field.type) || (fieldType && fieldType.kind === graphql_1.Kind.ENUM_TYPE_DEFINITION)) {
            filterTypeName = graphql_transformer_common_1.ModelResourceIDs.ModelScalarFilterInputTypeName(baseType, false);
        }
        else if (isList) {
            filterTypeName = graphql_transformer_common_1.ModelResourceIDs.ModelFilterListInputTypeName(baseType, true);
        }
        return {
            kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
            name: field.name,
            type: (0, graphql_transformer_common_1.makeNamedType)(filterTypeName),
            directives: [],
        };
    });
    fields.push(makeAdditionalFilterInputField('and', (0, graphql_transformer_common_1.makeListType)((0, graphql_transformer_common_1.makeNamedType)(name))), makeAdditionalFilterInputField('or', (0, graphql_transformer_common_1.makeListType)((0, graphql_transformer_common_1.makeNamedType)(name))), makeAdditionalFilterInputField('not', (0, graphql_transformer_common_1.makeNamedType)(name)));
    if (ctx.isProjectUsingDataStore()) {
        fields.push(makeAdditionalFilterInputField('_deleted', (0, graphql_transformer_common_1.makeNamedType)(graphql_transformer_common_1.ModelResourceIDs.ModelScalarFilterInputTypeName(graphql_transformer_common_1.STANDARD_SCALARS.Boolean, false))));
    }
    return {
        kind: 'InputObjectTypeDefinition',
        name: {
            kind: 'Name',
            value: name,
        },
        fields,
        directives: [],
    };
};
const makeAdditionalFilterInputField = (name, type) => ({
    kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
    name: {
        kind: 'Name',
        value: name,
    },
    type,
    directives: [],
});
const getPartitionKeyField = (ctx, object) => {
    const outputObject = ctx.output.getType(object.name.value);
    if (!outputObject) {
        throw new Error(`Expected to find output object defined for ${object.name.value}, but did not.`);
    }
    return (0, exports.getPartitionKeyFieldNoContext)(outputObject);
};
exports.getPartitionKeyField = getPartitionKeyField;
const getPartitionKeyFieldNoContext = (object) => {
    var _a;
    const fieldMap = new Map();
    let name = 'id';
    object.fields.forEach((field) => {
        fieldMap.set(field.name.value, field);
        field.directives.forEach((directive) => {
            if (directive.name.value === 'primaryKey') {
                name = field.name.value;
            }
        });
    });
    return (_a = fieldMap.get(name)) !== null && _a !== void 0 ? _a : (0, graphql_transformer_common_1.makeField)('id', [], (0, graphql_transformer_common_1.wrapNonNull)((0, graphql_transformer_common_1.makeNamedType)('ID')));
};
exports.getPartitionKeyFieldNoContext = getPartitionKeyFieldNoContext;
const getSortKeyFields = (ctx, object) => {
    const outputObject = ctx.output.getType(object.name.value);
    if (!outputObject) {
        throw new Error(`Expected to find output object defined for ${object.name.value}, but did not.`);
    }
    return (0, exports.getSortKeyFieldsNoContext)(outputObject);
};
exports.getSortKeyFields = getSortKeyFields;
const getSortKeyFieldsNoContext = (object) => {
    const fieldMap = new Map();
    object.fields.forEach((field) => {
        fieldMap.set(field.name.value, field);
    });
    const sortKeyFields = [];
    object.fields.forEach((field) => {
        field.directives.forEach((directive) => {
            var _a, _b;
            if (directive.name.value === 'primaryKey') {
                const values = (_b = (_a = directive.arguments) === null || _a === void 0 ? void 0 : _a.find((arg) => arg.name.value === 'sortKeyFields')) === null || _b === void 0 ? void 0 : _b.value;
                if (values) {
                    switch (values.kind) {
                        case 'StringValue':
                            sortKeyFields.push(fieldMap.get(values.value));
                            break;
                        case 'ListValue':
                            sortKeyFields.push(...values.values.map((val) => fieldMap.get(val.value)));
                            break;
                        default:
                            break;
                    }
                }
            }
        });
    });
    return sortKeyFields;
};
exports.getSortKeyFieldsNoContext = getSortKeyFieldsNoContext;
const getPrimaryKeyConnectionFieldType = (ctx, primaryKeyField) => ctx.transformParameters.respectPrimaryKeyAttributesOnConnectionField ? (0, graphql_transformer_common_1.getBaseType)(primaryKeyField.type) : 'ID';
const updateInputWithConnectionFields = (ctx, input, object, connectionAttributeName, primaryKeyConnectionFieldType, field, sortKeyFields, isConnectionFieldsNonNull) => {
    const updatedFields = [...input.fields];
    updatedFields.push(...getInputFieldsWithConnectionField(updatedFields, connectionAttributeName, primaryKeyConnectionFieldType, isConnectionFieldsNonNull));
    sortKeyFields.forEach((it) => {
        updatedFields.push(...getInputFieldsWithConnectionField(updatedFields, (0, utils_1.getSortKeyConnectionAttributeName)(object.name.value, field.name.value, it.name.value), (0, graphql_transformer_common_1.getBaseType)(it.type), isConnectionFieldsNonNull));
    });
    ctx.output.putType({
        ...input,
        fields: updatedFields,
    });
};
const updateFilterConnectionInputWithConnectionFields = (ctx, input, object, connectionAttributeName, primaryKeyConnectionFieldType, field, sortKeyFields, isSubscriptionFilter = false) => {
    const updatedFields = [...input.fields];
    updatedFields.push(...getFilterConnectionInputFieldsWithConnectionField(updatedFields, connectionAttributeName, (0, graphql_model_transformer_1.generateModelScalarFilterInputName)(primaryKeyConnectionFieldType, false, isSubscriptionFilter)));
    sortKeyFields.forEach((it) => {
        updatedFields.push(...getFilterConnectionInputFieldsWithConnectionField(updatedFields, (0, utils_1.getSortKeyConnectionAttributeName)(object.name.value, field.name.value, it.name.value), (0, graphql_model_transformer_1.generateModelScalarFilterInputName)((0, graphql_transformer_common_1.getBaseType)(it.type), false, isSubscriptionFilter)));
    });
    ctx.output.putType({
        ...input,
        fields: updatedFields,
    });
};
const updateTypeWithConnectionFields = (ctx, targetObject, object, connectionAttributeName, primaryKeyConnectionFieldType, field, sortKeyFields, isConnectionFieldsNonNull) => {
    const updatedFields = [...targetObject.fields];
    updatedFields.push(...getTypeFieldsWithConnectionField(updatedFields, connectionAttributeName, primaryKeyConnectionFieldType, isConnectionFieldsNonNull));
    sortKeyFields.forEach((it) => {
        updatedFields.push(...getTypeFieldsWithConnectionField(updatedFields, (0, utils_1.getSortKeyConnectionAttributeName)(object.name.value, field.name.value, it.name.value), (0, graphql_transformer_common_1.getBaseType)(it.type), isConnectionFieldsNonNull));
    });
    ctx.output.putType({
        ...targetObject,
        fields: updatedFields,
    });
};
const addFieldsToDefinition = (object, fields) => {
    fields.forEach((field) => {
        var _a, _b;
        if (!((_a = object === null || object === void 0 ? void 0 : object.fields) === null || _a === void 0 ? void 0 : _a.some((objField) => objField.name.value === field.name.value))) {
            (_b = object === null || object === void 0 ? void 0 : object.fields) === null || _b === void 0 ? void 0 : _b.push(field);
        }
    });
};
exports.addFieldsToDefinition = addFieldsToDefinition;
const convertSortKeyFieldsToSortKeyConnectionFields = (sortKeyFields, object, connectingField) => {
    const createdFields = new Array();
    sortKeyFields.forEach((skf) => {
        createdFields.push(...getTypeFieldsWithConnectionField([], (0, utils_1.getSortKeyConnectionAttributeName)(object.name.value, connectingField.name.value, skf.name.value), (0, graphql_transformer_common_1.getBaseType)(skf.type), (0, graphql_transformer_common_1.isNonNullType)(skf.type)));
    });
    return createdFields;
};
exports.convertSortKeyFieldsToSortKeyConnectionFields = convertSortKeyFieldsToSortKeyConnectionFields;
//# sourceMappingURL=schema.js.map