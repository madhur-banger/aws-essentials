"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.addDirectivesToOperation = exports.addDirectivesToField = exports.extendTypeWithDirectives = exports.makeSearchableXAggregationInputObject = exports.makeSearchableAggregateTypeEnumObject = exports.makeSearchableXSortInputObject = exports.makeSearchableXAggregateFieldEnumObject = exports.makeSearchableXSortableFieldsEnumObject = exports.makeSearchableSortDirectionEnumObject = exports.makeSearchableXFilterInputObject = exports.makeSearchableScalarInputObject = exports.DATASTORE_SYNC_FIELDS = exports.AGGREGATE_TYPES = void 0;
const graphql_1 = require("graphql");
const graphql_transformer_common_1 = require("graphql-transformer-common");
const graphql_transformer_core_1 = require("@aws-amplify/graphql-transformer-core");
const ID_CONDITIONS = [
    'ne',
    'gt',
    'lt',
    'gte',
    'lte',
    'eq',
    'match',
    'matchPhrase',
    'matchPhrasePrefix',
    'multiMatch',
    'exists',
    'wildcard',
    'regexp',
    'range',
];
const STRING_CONDITIONS = ID_CONDITIONS;
const INT_CONDITIONS = ['ne', 'gt', 'lt', 'gte', 'lte', 'eq', 'range'];
const FLOAT_CONDITIONS = ['ne', 'gt', 'lt', 'gte', 'lte', 'eq', 'range'];
const BOOLEAN_CONDITIONS = ['eq', 'ne'];
exports.AGGREGATE_TYPES = [
    'SearchableAggregateResult',
    'SearchableAggregateScalarResult',
    'SearchableAggregateBucketResult',
    'SearchableAggregateBucketResultItem',
];
exports.DATASTORE_SYNC_FIELDS = ['_version', '_deleted', '_lastChangedAt'];
const getScalarFilterInputType = (condition, type) => {
    switch (condition) {
        case 'range':
            return (0, graphql_transformer_common_1.makeListType)((0, graphql_transformer_common_1.makeNamedType)(type));
        case 'exists':
            return (0, graphql_transformer_common_1.makeNamedType)('Boolean');
        default:
            return (0, graphql_transformer_common_1.makeNamedType)(type);
    }
};
const getScalarConditions = (type) => {
    switch (type) {
        case 'String':
            return STRING_CONDITIONS;
        case 'ID':
            return ID_CONDITIONS;
        case 'Int':
            return INT_CONDITIONS;
        case 'Float':
            return FLOAT_CONDITIONS;
        case 'Boolean':
            return BOOLEAN_CONDITIONS;
        default:
            throw new Error('Valid types are String, ID, Int, Float, Boolean');
    }
};
const makeSearchableScalarInputObject = (type) => {
    const name = graphql_transformer_common_1.SearchableResourceIDs.SearchableFilterInputTypeName(type);
    const conditions = getScalarConditions(type);
    const fields = conditions.map((condition) => ({
        kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
        name: { kind: 'Name', value: condition },
        type: getScalarFilterInputType(condition, type),
        directives: [],
    }));
    return {
        kind: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION,
        name: {
            kind: 'Name',
            value: name,
        },
        fields,
        directives: [],
    };
};
exports.makeSearchableScalarInputObject = makeSearchableScalarInputObject;
const makeSearchableXFilterInputObject = (obj, document) => {
    const name = graphql_transformer_common_1.SearchableResourceIDs.SearchableFilterInputTypeName(obj.name.value);
    if (!obj.fields) {
        throw new graphql_transformer_core_1.InvalidDirectiveError('Models decorated with @searchable require fields defined within them.');
    }
    const fields = obj.fields
        .filter((field) => (0, graphql_transformer_common_1.isScalar)(field.type))
        .map((field) => ({
        kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
        name: field.name,
        type: (0, graphql_transformer_common_1.makeNamedType)(graphql_transformer_common_1.SearchableResourceIDs.SearchableFilterInputTypeName((0, graphql_transformer_common_1.getBaseType)(field.type))),
        directives: [],
    }));
    fields.push(...obj.fields
        .filter((field) => (0, graphql_transformer_common_1.isEnum)(field.type, document))
        .map((field) => ({
        kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
        name: field.name,
        type: (0, graphql_transformer_common_1.makeNamedType)(graphql_transformer_common_1.SearchableResourceIDs.SearchableFilterInputTypeName('String')),
        directives: [],
    })));
    fields.push({
        kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
        name: {
            kind: 'Name',
            value: 'and',
        },
        type: (0, graphql_transformer_common_1.makeListType)((0, graphql_transformer_common_1.makeNamedType)(name)),
        directives: [],
    }, {
        kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
        name: {
            kind: 'Name',
            value: 'or',
        },
        type: (0, graphql_transformer_common_1.makeListType)((0, graphql_transformer_common_1.makeNamedType)(name)),
        directives: [],
    }, {
        kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
        name: {
            kind: 'Name',
            value: 'not',
        },
        type: (0, graphql_transformer_common_1.makeNamedType)(name),
        directives: [],
    });
    return {
        kind: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION,
        name: {
            kind: 'Name',
            value: name,
        },
        fields,
        directives: [],
    };
};
exports.makeSearchableXFilterInputObject = makeSearchableXFilterInputObject;
const makeSearchableSortDirectionEnumObject = () => {
    const name = (0, graphql_transformer_common_1.graphqlName)('SearchableSortDirection');
    return {
        kind: graphql_1.Kind.ENUM_TYPE_DEFINITION,
        name: {
            kind: 'Name',
            value: name,
        },
        values: [
            {
                kind: graphql_1.Kind.ENUM_VALUE_DEFINITION,
                name: { kind: 'Name', value: 'asc' },
                directives: [],
            },
            {
                kind: graphql_1.Kind.ENUM_VALUE_DEFINITION,
                name: { kind: 'Name', value: 'desc' },
                directives: [],
            },
        ],
        directives: [],
    };
};
exports.makeSearchableSortDirectionEnumObject = makeSearchableSortDirectionEnumObject;
const makeSearchableXSortableFieldsEnumObject = (obj) => {
    const name = (0, graphql_transformer_common_1.graphqlName)(`Searchable${obj.name.value}SortableFields`);
    if (!obj.fields) {
        throw new graphql_transformer_core_1.InvalidDirectiveError('Models decorated with @searchable require fields defined within them.');
    }
    const values = obj.fields
        .filter((field) => (0, graphql_transformer_common_1.isScalar)(field.type))
        .map((field) => ({
        kind: graphql_1.Kind.ENUM_VALUE_DEFINITION,
        name: field.name,
        directives: [],
    }));
    return {
        kind: graphql_1.Kind.ENUM_TYPE_DEFINITION,
        name: {
            kind: 'Name',
            value: name,
        },
        values,
        directives: [],
    };
};
exports.makeSearchableXSortableFieldsEnumObject = makeSearchableXSortableFieldsEnumObject;
const makeSearchableXAggregateFieldEnumObject = (obj, document) => {
    const name = (0, graphql_transformer_common_1.graphqlName)(`Searchable${obj.name.value}AggregateField`);
    if (!obj.fields) {
        throw new graphql_transformer_core_1.InvalidDirectiveError('Models decorated with @searchable require fields defined within them.');
    }
    const values = obj.fields
        .filter((field) => (0, graphql_transformer_common_1.isScalar)(field.type) || (0, graphql_transformer_common_1.isEnum)(field.type, document))
        .map((field) => ({
        kind: graphql_1.Kind.ENUM_VALUE_DEFINITION,
        name: field.name,
        directives: [],
    }));
    return {
        kind: graphql_1.Kind.ENUM_TYPE_DEFINITION,
        name: {
            kind: 'Name',
            value: name,
        },
        values,
        directives: [],
    };
};
exports.makeSearchableXAggregateFieldEnumObject = makeSearchableXAggregateFieldEnumObject;
const makeSearchableXSortInputObject = (obj) => {
    const name = (0, graphql_transformer_common_1.graphqlName)(`Searchable${obj.name.value}SortInput`);
    return {
        kind: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION,
        name: {
            kind: 'Name',
            value: name,
        },
        fields: [
            {
                kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
                name: { kind: 'Name', value: 'field' },
                type: (0, graphql_transformer_common_1.makeNamedType)(`Searchable${obj.name.value}SortableFields`),
                directives: [],
            },
            {
                kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
                name: { kind: 'Name', value: 'direction' },
                type: (0, graphql_transformer_common_1.makeNamedType)('SearchableSortDirection'),
                directives: [],
            },
        ],
        directives: [],
    };
};
exports.makeSearchableXSortInputObject = makeSearchableXSortInputObject;
const makeSearchableAggregateTypeEnumObject = () => {
    const name = (0, graphql_transformer_common_1.graphqlName)('SearchableAggregateType');
    const values = ['terms', 'avg', 'min', 'max', 'sum', 'cardinality'].map((type) => ({
        kind: graphql_1.Kind.ENUM_VALUE_DEFINITION,
        name: { kind: 'Name', value: type },
        directives: [],
    }));
    return {
        kind: graphql_1.Kind.ENUM_TYPE_DEFINITION,
        name: {
            kind: 'Name',
            value: name,
        },
        values,
        directives: [],
    };
};
exports.makeSearchableAggregateTypeEnumObject = makeSearchableAggregateTypeEnumObject;
const makeSearchableXAggregationInputObject = (obj) => {
    const name = (0, graphql_transformer_common_1.graphqlName)(`Searchable${obj.name.value}AggregationInput`);
    return {
        kind: graphql_1.Kind.INPUT_OBJECT_TYPE_DEFINITION,
        name: {
            kind: 'Name',
            value: name,
        },
        fields: [
            {
                kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
                name: { kind: 'Name', value: 'name' },
                type: (0, graphql_transformer_common_1.makeNonNullType)((0, graphql_transformer_common_1.makeNamedType)('String')),
                directives: [],
            },
            {
                kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
                name: { kind: 'Name', value: 'type' },
                type: (0, graphql_transformer_common_1.makeNonNullType)((0, graphql_transformer_common_1.makeNamedType)('SearchableAggregateType')),
                directives: [],
            },
            {
                kind: graphql_1.Kind.INPUT_VALUE_DEFINITION,
                name: { kind: 'Name', value: 'field' },
                type: (0, graphql_transformer_common_1.makeNonNullType)((0, graphql_transformer_common_1.makeNamedType)(`Searchable${obj.name.value}AggregateField`)),
                directives: [],
            },
        ],
        directives: [],
    };
};
exports.makeSearchableXAggregationInputObject = makeSearchableXAggregationInputObject;
const extendTypeWithDirectives = (ctx, typeName, directives) => {
    let objectTypeExtension = (0, graphql_transformer_common_1.blankObjectExtension)(typeName);
    objectTypeExtension = (0, graphql_transformer_common_1.extensionWithDirectives)(objectTypeExtension, directives);
    ctx.output.addObjectExtension(objectTypeExtension);
};
exports.extendTypeWithDirectives = extendTypeWithDirectives;
const addDirectivesToField = (ctx, typeName, fieldName, directives) => {
    var _a;
    const type = ctx.output.getType(typeName);
    if (type) {
        const field = (_a = type.fields) === null || _a === void 0 ? void 0 : _a.find((f) => f.name.value === fieldName);
        if (field) {
            const newFields = [...type.fields.filter((f) => f.name.value !== field.name.value), (0, graphql_transformer_common_1.extendFieldWithDirectives)(field, directives)];
            const newType = {
                ...type,
                fields: newFields,
            };
            ctx.output.putType(newType);
        }
    }
};
exports.addDirectivesToField = addDirectivesToField;
const addDirectivesToOperation = (ctx, typeName, operationName, directives) => {
    (0, exports.addDirectivesToField)(ctx, typeName, operationName, directives);
    const type = ctx.output.getType(typeName);
    if (type) {
        const field = type.fields.find((f) => f.name.value === operationName);
        if (field) {
            const returnFieldType = field.type;
            if (returnFieldType.name) {
                const returnTypeName = returnFieldType.name.value;
                (0, exports.extendTypeWithDirectives)(ctx, returnTypeName, directives);
            }
        }
    }
};
exports.addDirectivesToOperation = addDirectivesToOperation;
//# sourceMappingURL=definitions.js.map