"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateFieldMapping = exports.getMappedFieldName = exports.getMappedName = exports.shouldBeAppliedToModel = exports.updateTypeMapping = exports.setTypeMappingInSchema = void 0;
const graphql_1 = require("graphql");
const graphql_transformer_core_1 = require("@aws-amplify/graphql-transformer-core");
const setTypeMappingInSchema = (context, directiveName) => {
    var _a, _b;
    (_b = (_a = context.inputDocument) === null || _a === void 0 ? void 0 : _a.definitions) === null || _b === void 0 ? void 0 : _b.forEach((def) => {
        var _a;
        if (def.kind === 'ObjectTypeDefinition' || def.kind === 'ObjectTypeExtension') {
            (_a = def === null || def === void 0 ? void 0 : def.directives) === null || _a === void 0 ? void 0 : _a.forEach((dir) => {
                if (dir.name.value === directiveName) {
                    const modelName = def.name.value;
                    const mappedName = (0, exports.getMappedName)(def, dir, directiveName, context.inputDocument);
                    (0, exports.updateTypeMapping)(modelName, mappedName, context.schemaHelper.setTypeMapping);
                }
            });
        }
    });
};
exports.setTypeMappingInSchema = setTypeMappingInSchema;
const updateTypeMapping = (modelName, mappedName, updateFunction) => {
    updateFunction(modelName, mappedName);
};
exports.updateTypeMapping = updateTypeMapping;
const shouldBeAppliedToModel = (definition, directiveName) => {
    var _a;
    const typeName = definition.name.value;
    const hasModelDirective = !!((_a = definition.directives) === null || _a === void 0 ? void 0 : _a.find((directive) => directive.name.value === 'model'));
    if (!hasModelDirective) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`@${directiveName} is not supported on type ${typeName}. It can only be used on a @model type.`);
    }
};
exports.shouldBeAppliedToModel = shouldBeAppliedToModel;
const getMappedName = (definition, directive, directiveName, inputDocument) => {
    var _a, _b, _c;
    const modelName = definition.name.value;
    const mappedName = getNameInput(directive, directiveName);
    const schemaHasConflictingModel = !!inputDocument.definitions.find(hasModelWithNamePredicate(mappedName));
    if (schemaHasConflictingModel) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`Cannot apply @${directiveName} with name "${mappedName}" on type "${modelName}" because "${mappedName}" model already exists in the schema.`);
    }
    const modelsWithDuplicateName = (_a = inputDocument === null || inputDocument === void 0 ? void 0 : inputDocument.definitions) === null || _a === void 0 ? void 0 : _a.filter((def) => isModelWithDuplicateMapping(def, modelName, mappedName, directiveName));
    if ((modelsWithDuplicateName === null || modelsWithDuplicateName === void 0 ? void 0 : modelsWithDuplicateName.length) > 0) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`Cannot apply @${directiveName} with name "${mappedName}" on type "${modelName}" because "${(_c = (_b = modelsWithDuplicateName[0]) === null || _b === void 0 ? void 0 : _b.name) === null || _c === void 0 ? void 0 : _c.value}" model already has the same name mapping.`);
    }
    return mappedName;
};
exports.getMappedName = getMappedName;
const getMappedFieldName = (parent, definition, directive, directiveName) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    const modelName = (_a = parent === null || parent === void 0 ? void 0 : parent.name) === null || _a === void 0 ? void 0 : _a.value;
    const fieldName = (_b = definition === null || definition === void 0 ? void 0 : definition.name) === null || _b === void 0 ? void 0 : _b.value;
    const mappedName = getNameInput(directive, directiveName);
    const fieldsWithSameMappings = (_c = parent === null || parent === void 0 ? void 0 : parent.fields) === null || _c === void 0 ? void 0 : _c.filter((field) => isFieldWithDuplicateMapping(field, fieldName, mappedName, directiveName));
    if (fieldsWithSameMappings && (fieldsWithSameMappings === null || fieldsWithSameMappings === void 0 ? void 0 : fieldsWithSameMappings.length) > 0) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`Cannot apply @${directiveName} with name "${mappedName}" on field "${(_d = definition === null || definition === void 0 ? void 0 : definition.name) === null || _d === void 0 ? void 0 : _d.value}" in type "${modelName}" because "${(_f = (_e = fieldsWithSameMappings[0]) === null || _e === void 0 ? void 0 : _e.name) === null || _f === void 0 ? void 0 : _f.value}" field already has the same name mapping.`);
    }
    const fieldWithMappedName = (_g = parent === null || parent === void 0 ? void 0 : parent.fields) === null || _g === void 0 ? void 0 : _g.find((field) => { var _a; return ((_a = field === null || field === void 0 ? void 0 : field.name) === null || _a === void 0 ? void 0 : _a.value) === mappedName; });
    if (fieldWithMappedName) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`Cannot apply @${directiveName} with name "${mappedName}" on field "${(_h = definition === null || definition === void 0 ? void 0 : definition.name) === null || _h === void 0 ? void 0 : _h.value}" in type "${modelName}" because "${(_j = fieldWithMappedName === null || fieldWithMappedName === void 0 ? void 0 : fieldWithMappedName.name) === null || _j === void 0 ? void 0 : _j.value}" field already exists in the model.`);
    }
    return mappedName;
};
exports.getMappedFieldName = getMappedFieldName;
const getNameInput = (directive, directiveName) => {
    var _a, _b;
    const mappedNameNode = (_a = directive.arguments) === null || _a === void 0 ? void 0 : _a.find((arg) => arg.name.value === 'name');
    if (!mappedNameNode) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`name is required in @${directiveName} directive.`);
    }
    if (mappedNameNode.value.kind !== 'StringValue') {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`A single string must be provided for "name" in @${directiveName} directive`);
    }
    return (_b = mappedNameNode === null || mappedNameNode === void 0 ? void 0 : mappedNameNode.value) === null || _b === void 0 ? void 0 : _b.value;
};
const hasModelWithNamePredicate = (name) => (node) => { var _a; return node.kind === graphql_1.Kind.OBJECT_TYPE_DEFINITION && !!((_a = node.directives) === null || _a === void 0 ? void 0 : _a.find((dir) => dir.name.value === 'model')) && node.name.value === name; };
const isModelWithDuplicateMapping = (node, modelName, mappedName, directiveName) => {
    var _a, _b;
    return node.kind === graphql_1.Kind.OBJECT_TYPE_DEFINITION &&
        ((_a = node === null || node === void 0 ? void 0 : node.name) === null || _a === void 0 ? void 0 : _a.value) !== modelName &&
        !!((_b = node.directives) === null || _b === void 0 ? void 0 : _b.find((dir) => {
            var _a;
            return dir.name.value === directiveName &&
                ((_a = dir.arguments) === null || _a === void 0 ? void 0 : _a.find((arg) => arg.name.value === 'name' && arg.value.kind === graphql_1.Kind.STRING && arg.value.value === mappedName));
        }));
};
const isFieldWithDuplicateMapping = (node, fieldName, mappedName, directiveName) => {
    var _a, _b;
    return ((_a = node === null || node === void 0 ? void 0 : node.name) === null || _a === void 0 ? void 0 : _a.value) !== fieldName &&
        !!((_b = node.directives) === null || _b === void 0 ? void 0 : _b.find((dir) => {
            var _a;
            return dir.name.value === directiveName &&
                ((_a = dir.arguments) === null || _a === void 0 ? void 0 : _a.find((arg) => arg.name.value === 'name' && arg.value.kind === graphql_1.Kind.STRING && arg.value.value === mappedName));
        }));
};
const updateFieldMapping = (modelName, fieldName, mappedName, context) => {
    const modelFieldMap = context.resourceHelper.getModelFieldMap(modelName);
    modelFieldMap.addMappedField({ currentFieldName: fieldName, originalFieldName: mappedName });
};
exports.updateFieldMapping = updateFieldMapping;
//# sourceMappingURL=graphql-name-mapping.js.map