"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.shouldNotBeOnRelationalField = exports.shouldBeAppliedToRDSModels = exports.RefersToTransformer = void 0;
const graphql_transformer_core_1 = require("@aws-amplify/graphql-transformer-core");
const graphql_transformer_interfaces_1 = require("@aws-amplify/graphql-transformer-interfaces");
const graphql_directives_1 = require("@aws-amplify/graphql-directives");
const graphql_1 = require("graphql");
const graphql_name_mapping_1 = require("./graphql-name-mapping");
const field_mapping_resolvers_1 = require("./field-mapping-resolvers");
class RefersToTransformer extends graphql_transformer_core_1.TransformerPluginBase {
    constructor() {
        super('amplify-refers-to-transformer', graphql_directives_1.RefersToDirective.definition, graphql_transformer_interfaces_1.TransformerPluginType.GENERIC);
        this.object = (definition, directive, ctx) => {
            const context = ctx;
            (0, graphql_name_mapping_1.shouldBeAppliedToModel)(definition, graphql_directives_1.RefersToDirective.name);
            (0, exports.shouldBeAppliedToRDSModels)(definition, context);
            const modelName = definition.name.value;
            const mappedName = (0, graphql_name_mapping_1.getMappedName)(definition, directive, graphql_directives_1.RefersToDirective.name, ctx.inputDocument);
            (0, graphql_name_mapping_1.updateTypeMapping)(modelName, mappedName, ctx.resourceHelper.setModelNameMapping);
        };
        this.field = (parent, definition, directive, ctx) => {
            var _a, _b, _c, _d;
            if (parent.kind === graphql_1.Kind.INTERFACE_TYPE_DEFINITION) {
                throw new graphql_transformer_core_1.InvalidDirectiveError(`@refersTo directive cannot be placed on "${(_a = parent === null || parent === void 0 ? void 0 : parent.name) === null || _a === void 0 ? void 0 : _a.value}" interface's ${(_b = definition === null || definition === void 0 ? void 0 : definition.name) === null || _b === void 0 ? void 0 : _b.value} field.`);
            }
            const context = ctx;
            const modelName = (_c = parent === null || parent === void 0 ? void 0 : parent.name) === null || _c === void 0 ? void 0 : _c.value;
            (0, graphql_name_mapping_1.shouldBeAppliedToModel)(parent, graphql_directives_1.RefersToDirective.name);
            (0, exports.shouldBeAppliedToRDSModels)(parent, context);
            (0, exports.shouldNotBeOnRelationalField)(definition, modelName);
            const mappedName = (0, graphql_name_mapping_1.getMappedFieldName)(parent, definition, directive, graphql_directives_1.RefersToDirective.name);
            (0, graphql_name_mapping_1.updateFieldMapping)(modelName, (_d = definition === null || definition === void 0 ? void 0 : definition.name) === null || _d === void 0 ? void 0 : _d.value, mappedName, ctx);
        };
        this.after = (context) => {
            context.resourceHelper.getModelFieldMapKeys().forEach((modelName) => {
                if (!(0, graphql_transformer_core_1.isSqlModel)(context, modelName)) {
                    return;
                }
                const modelFieldMap = context.resourceHelper.getModelFieldMap(modelName);
                if (!modelFieldMap.getMappedFields().length) {
                    return;
                }
                modelFieldMap.getResolverReferences().forEach(({ typeName, fieldName, isList }) => {
                    const resolver = context.resolvers.getResolver(typeName, fieldName);
                    if (!resolver) {
                        return;
                    }
                    (0, field_mapping_resolvers_1.attachFieldMappingSlot)({
                        resolver,
                        resolverTypeName: typeName,
                        resolverFieldName: fieldName,
                        fieldMap: modelFieldMap.getMappedFields(),
                    });
                });
            });
        };
        this.preMutateSchema = (context) => {
            (0, graphql_name_mapping_1.setTypeMappingInSchema)(context, graphql_directives_1.RefersToDirective.name);
        };
    }
}
exports.RefersToTransformer = RefersToTransformer;
const shouldBeAppliedToRDSModels = (definition, ctx) => {
    const modelName = definition.name.value;
    if (!(0, graphql_transformer_core_1.isSqlModel)(ctx, modelName)) {
        throw new Error(`@${graphql_directives_1.RefersToDirective.name} is only supported on SQL models. ${modelName} is not a SQL model.`);
    }
};
exports.shouldBeAppliedToRDSModels = shouldBeAppliedToRDSModels;
const shouldNotBeOnRelationalField = (definition, modelName) => {
    var _a, _b;
    const relationalDirectives = ['hasOne', 'hasMany', 'belongsTo', 'manyToMany'];
    if ((_a = definition === null || definition === void 0 ? void 0 : definition.directives) === null || _a === void 0 ? void 0 : _a.some((directive) => { var _a; return relationalDirectives.includes((_a = directive === null || directive === void 0 ? void 0 : directive.name) === null || _a === void 0 ? void 0 : _a.value); })) {
        throw new Error(`@${graphql_directives_1.RefersToDirective.name} is not supported on "${(_b = definition === null || definition === void 0 ? void 0 : definition.name) === null || _b === void 0 ? void 0 : _b.value}" relational field in "${modelName}" model.`);
    }
};
exports.shouldNotBeOnRelationalField = shouldNotBeOnRelationalField;
//# sourceMappingURL=graphql-refers-to-transformer.js.map