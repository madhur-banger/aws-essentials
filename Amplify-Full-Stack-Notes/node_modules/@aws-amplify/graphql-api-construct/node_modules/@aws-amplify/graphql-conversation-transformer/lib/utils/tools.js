"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processTools = void 0;
const graphql_transformer_core_1 = require("@aws-amplify/graphql-transformer-core");
const graphql_transformer_common_1 = require("graphql-transformer-common");
const graphql_json_schema_type_1 = require("./graphql-json-schema-type");
const generateSelectionSet = (currentType, ctx, seenTypes = new Set(), fieldName = '') => {
    if ((0, graphql_transformer_common_1.isScalar)(currentType)) {
        return fieldName;
    }
    const typeName = (0, graphql_transformer_common_1.getBaseType)(currentType);
    if (seenTypes.has(typeName)) {
        return '';
    }
    const type = getObjectTypeFromName(typeName, ctx);
    seenTypes.add(type.name.value);
    if (!type.fields || type.fields.length === 0) {
        return '';
    }
    const fieldSelections = type.fields
        .map((field) => {
        if ((0, graphql_transformer_common_1.isScalar)(field.type)) {
            return field.name.value;
        }
        else {
            const nestedSelection = generateSelectionSet(field.type, ctx, new Set(seenTypes), field.name.value);
            return nestedSelection ? `${field.name.value} { ${nestedSelection} }` : '';
        }
    })
        .filter(Boolean);
    return fieldSelections.join(' ');
};
const getObjectTypeFromName = (name, ctx) => {
    const node = ctx.output.getObject(name);
    if (!node) {
        throw new Error(`Could not find type definition for ${name}`);
    }
    return node;
};
const processTools = (toolDefinitions, ctx) => {
    if (!toolDefinitions || toolDefinitions.length === 0) {
        return undefined;
    }
    const queryType = ctx.output.getType('Query');
    if (!queryType.fields || queryType.fields.length === 0) {
        throw new graphql_transformer_core_1.InvalidDirectiveError('Tools must be queries - no queries found in the schema');
    }
    const tools = toolDefinitions.map((toolDefinition) => {
        var _a;
        const { name: toolName, description } = toolDefinition;
        const queryField = (_a = queryType.fields) === null || _a === void 0 ? void 0 : _a.find((field) => field.name.value === toolName);
        if (!queryField) {
            throw new graphql_transformer_core_1.InvalidDirectiveError(`Tool "${toolName}" defined in @conversation directive has no matching Query field definition`);
        }
        return createTool(toolName, description, queryField, ctx);
    });
    return { tools };
};
exports.processTools = processTools;
const createTool = (toolName, description, queryField, ctx) => {
    const { type: returnType, arguments: fieldArguments } = queryField;
    const { properties, required } = generateToolProperties(fieldArguments, ctx, toolName, returnType);
    const selectionSet = generateSelectionSet(returnType, ctx).trim();
    const propertyTypes = generatePropertyTypes(fieldArguments, toolName, returnType);
    const graphqlRequestInputDescriptor = {
        selectionSet,
        propertyTypes,
        queryName: toolName,
    };
    return {
        name: toolName,
        description,
        inputSchema: {
            json: {
                type: 'object',
                properties,
                required,
            },
        },
        graphqlRequestInputDescriptor,
    };
};
const generateToolProperties = (fieldArguments, ctx, toolName, returnType) => {
    if (!fieldArguments || fieldArguments.length === 0) {
        return { properties: {}, required: [] };
    }
    if (isModelListOperation(toolName, returnType)) {
        return { properties: {}, required: [] };
    }
    return fieldArguments.reduce((acc, fieldArgument) => {
        const fieldArgumentSchema = (0, graphql_json_schema_type_1.generateJSONSchemaFromTypeNode)(fieldArgument.type, ctx);
        acc.properties[fieldArgument.name.value] = fieldArgumentSchema;
        if (fieldArgument.type.kind === 'NonNullType') {
            acc.required.push(fieldArgument.name.value);
        }
        return acc;
    }, { properties: {}, required: [] });
};
const generatePropertyTypes = (fieldArguments, toolName, returnType) => {
    if (!fieldArguments || fieldArguments.length === 0) {
        return {};
    }
    if (isModelListOperation(toolName, returnType)) {
        return {};
    }
    return fieldArguments.reduce((acc, fieldArgument) => {
        const name = fieldArgument.name.value;
        const suffix = (0, graphql_transformer_common_1.isNonNullType)(fieldArgument.type) ? '!' : '';
        acc[name] = (0, graphql_transformer_common_1.getBaseType)(fieldArgument.type) + suffix;
        return acc;
    }, {});
};
const isModelListOperation = (toolName, responseType) => {
    return (0, graphql_transformer_common_1.getBaseType)(responseType).startsWith('Model') && toolName.startsWith('list');
};
//# sourceMappingURL=tools.js.map