"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.commonRuleValidation = exports.validateFieldRules = exports.validateRules = exports.validateRuleAuthStrategy = void 0;
const graphql_transformer_core_1 = require("@aws-amplify/graphql-transformer-core");
const index_1 = require("./index");
const validateRuleAuthStrategy = (rule, configuredAuthProviders) => {
    if (rule.allow === 'groups' && rule.provider !== 'userPools' && rule.provider !== 'oidc') {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`@auth directive with 'groups' strategy only supports 'userPools' and 'oidc' providers, but found '${rule.provider}' assigned.`);
    }
    if (rule.allow === 'groups' && !rule.groups && !rule.groupsField) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`@auth directive with 'groups' should have a defined groups list or a groupsField.`);
    }
    if (rule.allow === 'owner') {
        if (rule.provider && rule.provider !== 'userPools' && rule.provider !== 'oidc') {
            throw new graphql_transformer_core_1.InvalidDirectiveError(`@auth directive with 'owner' strategy only supports 'userPools' (default) and 'oidc' providers, but \
found '${rule.provider}' assigned.`);
        }
    }
    if (rule.allow === 'public') {
        if (rule.provider && !(0, index_1.isAuthProviderEqual)(rule.provider, 'apiKey') && !(0, index_1.isAuthProviderEqual)(rule.provider, 'identityPool')) {
            throw new graphql_transformer_core_1.InvalidDirectiveError(`@auth directive with 'public' strategy only supports 'apiKey' (default) and 'identityPool' providers, but \
found '${rule.provider}' assigned.`);
        }
    }
    if (rule.allow === 'private') {
        if (rule.provider &&
            !(0, index_1.isAuthProviderEqual)(rule.provider, 'userPools') &&
            !(0, index_1.isAuthProviderEqual)(rule.provider, 'identityPool') &&
            !(0, index_1.isAuthProviderEqual)(rule.provider, 'oidc')) {
            throw new graphql_transformer_core_1.InvalidDirectiveError(`@auth directive with 'private' strategy only supports 'userPools' (default) and 'identityPool' providers, but \
found '${rule.provider}' assigned.`);
        }
    }
    if (rule.allow === 'custom') {
        if (rule.provider && rule.provider !== 'function') {
            throw new graphql_transformer_core_1.InvalidDirectiveError(`@auth directive with 'custom' strategy only supports 'function' (default) provider, but \
found '${rule.provider}' assigned.`);
        }
    }
    if (rule.provider === 'apiKey' && configuredAuthProviders.hasApiKey === false) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`@auth directive with 'apiKey' provider found, but the project has no API Key authentication provider configured.`);
    }
    else if (rule.provider === 'oidc' && configuredAuthProviders.hasOIDC === false) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`@auth directive with 'oidc' provider found, but the project has no OPENID_CONNECT authentication provider configured.`);
    }
    else if (rule.provider === 'userPools' && configuredAuthProviders.hasUserPools === false) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`@auth directive with 'userPools' provider found, but the project has no Cognito User Pools authentication provider configured.`);
    }
    else if (rule.provider === 'iam' && configuredAuthProviders.hasIAM === false) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`@auth directive with 'iam' provider found, but the project has no IAM authentication provider configured.`);
    }
    else if (rule.provider === 'identityPool' && configuredAuthProviders.hasIAM === false) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`@auth directive with 'identityPool' provider found, but the project has no IAM authentication provider configured.`);
    }
    else if (rule.provider === 'function' && configuredAuthProviders.hasLambda === false) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`@auth directive with 'function' provider found, but the project has no Lambda authentication provider configured.`);
    }
};
exports.validateRuleAuthStrategy = validateRuleAuthStrategy;
const validateRules = (rules, configuredAuthProviders, typeName, dataSourceStrategies) => {
    if (rules.length === 0) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`@auth on ${typeName} does not have any auth rules.`);
    }
    for (const rule of rules) {
        (0, exports.validateRuleAuthStrategy)(rule, configuredAuthProviders);
        (0, exports.commonRuleValidation)(rule);
        validateRuleOperations(rule, dataSourceStrategies, typeName);
    }
};
exports.validateRules = validateRules;
const validateRuleOperations = (rule, dataSourceStrategies, typeName, fieldName) => {
    if (!(0, graphql_transformer_core_1.isModelType)(dataSourceStrategies, typeName) || !(0, graphql_transformer_core_1.isSqlModel)(dataSourceStrategies, typeName)) {
        return;
    }
    if (!rule.operations || rule.operations.length === 0) {
        return;
    }
    if (rule.operations.includes('sync')) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`@auth on ${typeName}${fieldName ? `.${fieldName}` : ''} cannot specify 'sync' operation as it is not supported for SQL data sources`);
    }
    if (rule.operations.includes('search')) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`@auth on ${typeName}${fieldName ? `.${fieldName}` : ''} cannot specify 'search' operation as it is not supported for SQL data sources`);
    }
};
const validateFieldRules = (authDir, isParentTypeBuiltinType, parentHasModelDirective, fieldName, transformParameters, parent, dataSourceStrategies) => {
    const rules = authDir.getArguments({ rules: [] }, (0, graphql_transformer_core_1.generateGetArgumentsInput)(transformParameters)).rules;
    if (rules.length === 0) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`@auth on ${fieldName} does not have any auth rules.`);
    }
    for (const rule of rules) {
        if (isParentTypeBuiltinType && rule.operations && rule.operations.length > 0) {
            throw new graphql_transformer_core_1.InvalidDirectiveError(`@auth rules on fields within Query, Mutation, Subscription cannot specify 'operations' argument as these rules \
are already on an operation already.`);
        }
        if (!parentHasModelDirective && rule.operations && rule.operations.length > 0) {
            throw new graphql_transformer_core_1.InvalidDirectiveError(`@auth rules on fields within types that does not have @model directive cannot specify 'operations' argument as there are \
operations will be generated by the CLI.`);
        }
        const typeName = parent.name.value;
        validateRuleOperations(rule, dataSourceStrategies, typeName, fieldName);
    }
};
exports.validateFieldRules = validateFieldRules;
const commonRuleValidation = (rule) => {
    const { identityClaim, allow, groups, groupsField, groupClaim } = rule;
    if (allow === 'groups' && identityClaim) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`
          @auth identityClaim can only be used for 'allow: owner'`);
    }
    if (allow === 'owner' && groupClaim) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`
          @auth groupClaim can only be used 'allow: groups'`);
    }
    if (groupsField && groups) {
        throw new graphql_transformer_core_1.InvalidDirectiveError('This rule has groupsField and groups, please use one or the other');
    }
    if (allow === 'groups' && groups && groups.length < 1) {
        throw new graphql_transformer_core_1.InvalidDirectiveError('@auth rules using groups cannot have an empty list');
    }
};
exports.commonRuleValidation = commonRuleValidation;
//# sourceMappingURL=validations.js.map