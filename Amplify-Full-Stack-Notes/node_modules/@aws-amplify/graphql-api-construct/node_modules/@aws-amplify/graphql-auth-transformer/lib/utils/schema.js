"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSubscriptionFieldNames = exports.getMutationFieldNames = exports.getQueryFieldNames = exports.addDirectivesToOperation = exports.addSubscriptionArguments = exports.addDirectivesToField = exports.extendTypeWithDirectives = exports.getPartitionKey = exports.hasRelationalDirective = exports.getRelationalPrimaryMap = exports.getSearchableConfig = exports.getModelConfig = exports.fieldIsList = exports.collectFieldNames = void 0;
const graphql_model_transformer_1 = require("@aws-amplify/graphql-model-transformer");
const graphql_relational_transformer_1 = require("@aws-amplify/graphql-relational-transformer");
const graphql_transformer_core_1 = require("@aws-amplify/graphql-transformer-core");
const graphql_transformer_interfaces_1 = require("@aws-amplify/graphql-transformer-interfaces");
const graphql_transformer_common_1 = require("graphql-transformer-common");
const md5_1 = __importDefault(require("md5"));
const constants_1 = require("./constants");
const collectFieldNames = (object) => object.fields.map((field) => field.name.value);
exports.collectFieldNames = collectFieldNames;
const fieldIsList = (fields, fieldName) => fields.some((field) => field.name.value === fieldName && (0, graphql_transformer_common_1.isListType)(field.type));
exports.fieldIsList = fieldIsList;
const getModelConfig = (directive, typeName, transformParameters, isDataStoreEnabled = false) => {
    const directiveWrapped = new graphql_transformer_core_1.DirectiveWrapper(directive);
    const options = directiveWrapped.getArguments({
        queries: {
            get: (0, graphql_transformer_common_1.toCamelCase)(['get', typeName]),
            list: (0, graphql_transformer_common_1.toCamelCase)(['list', (0, graphql_transformer_common_1.plurality)(typeName, true)]),
            ...(isDataStoreEnabled ? { sync: (0, graphql_transformer_common_1.toCamelCase)(['sync', (0, graphql_transformer_common_1.plurality)(typeName, true)]) } : undefined),
        },
        mutations: {
            create: (0, graphql_transformer_common_1.toCamelCase)(['create', typeName]),
            update: (0, graphql_transformer_common_1.toCamelCase)(['update', typeName]),
            delete: (0, graphql_transformer_common_1.toCamelCase)(['delete', typeName]),
        },
        subscriptions: {
            level: graphql_model_transformer_1.SubscriptionLevel.on,
            onCreate: [ensureValidSubscriptionName((0, graphql_transformer_common_1.toCamelCase)(['onCreate', typeName]))],
            onDelete: [ensureValidSubscriptionName((0, graphql_transformer_common_1.toCamelCase)(['onDelete', typeName]))],
            onUpdate: [ensureValidSubscriptionName((0, graphql_transformer_common_1.toCamelCase)(['onUpdate', typeName]))],
        },
        timestamps: {
            createdAt: 'createdAt',
            updatedAt: 'updatedAt',
        },
    }, (0, graphql_transformer_core_1.generateGetArgumentsInput)(transformParameters));
    return options;
};
exports.getModelConfig = getModelConfig;
const getSearchableConfig = (directive, typeName, transformParameters) => {
    const directiveWrapped = new graphql_transformer_core_1.DirectiveWrapper(directive);
    const options = directiveWrapped.getArguments({
        queries: {
            search: (0, graphql_transformer_common_1.graphqlName)(`search${(0, graphql_transformer_common_1.plurality)((0, graphql_transformer_common_1.toUpper)(typeName), true)}`),
        },
    }, (0, graphql_transformer_core_1.generateGetArgumentsInput)(transformParameters));
    return options;
};
exports.getSearchableConfig = getSearchableConfig;
const getRelationalPrimaryMap = (ctx, def, field, relatedModel) => {
    const relationalDirective = field.directives.find((dir) => constants_1.RELATIONAL_DIRECTIVES.includes(dir.name.value));
    const directiveWrapped = new graphql_transformer_core_1.DirectiveWrapper(relationalDirective);
    const primaryFieldMap = new Map();
    if (relationalDirective.name.value === 'hasMany') {
        const args = directiveWrapped.getArguments({
            indexName: undefined,
            fields: undefined,
        }, (0, graphql_transformer_core_1.generateGetArgumentsInput)(ctx.transformParameters));
        if (args.indexName || args.fields) {
            const fields = args.fields ? args.fields : [(0, graphql_transformer_core_1.getTable)(ctx, def).keySchema.find((att) => att.keyType === 'HASH').attributeName];
            const relatedTable = args.indexName
                ? (0, graphql_transformer_core_1.getKeySchema)((0, graphql_transformer_core_1.getTable)(ctx, relatedModel), args.indexName).map((att) => att.attributeName)
                : getKeyFields(ctx, relatedModel);
            relatedTable.forEach((att, idx) => {
                var _a;
                primaryFieldMap.set(att, {
                    claim: fields[idx] ? 'source' : 'args',
                    field: (_a = fields[idx]) !== null && _a !== void 0 ? _a : att,
                });
            });
        }
    }
    else if (relationalDirective.name.value !== 'manyToMany') {
        const args = directiveWrapped.getArguments({
            fields: [
                (0, graphql_relational_transformer_1.getConnectionAttributeName)(ctx.transformParameters, def.name.value, field.name.value, relatedModel.name.value),
                ...(0, graphql_transformer_core_1.getSortKeyFieldNames)(relatedModel).map((it) => (0, graphql_relational_transformer_1.getSortKeyConnectionAttributeName)(def.name.value, field.name.value, it)),
            ],
        }, (0, graphql_transformer_core_1.generateGetArgumentsInput)(ctx.transformParameters));
        const relatedPrimaryFields = getKeyFields(ctx, relatedModel);
        if (args.fields.length !== relatedPrimaryFields.length) {
            throw new graphql_transformer_core_1.InvalidDirectiveError(`Invalid @${relationalDirective.name.value} on ${def.name.value}:${field.name.value}. ` +
                `Provided fields do not match the size of primary key(s) for ${relatedModel.name.value}`);
        }
        relatedPrimaryFields.forEach((field, idx) => {
            primaryFieldMap.set(field, {
                claim: 'source',
                field: args.fields[idx],
            });
        });
    }
    return primaryFieldMap;
};
exports.getRelationalPrimaryMap = getRelationalPrimaryMap;
const hasRelationalDirective = (field) => field.directives && field.directives.some((dir) => constants_1.RELATIONAL_DIRECTIVES.includes(dir.name.value));
exports.hasRelationalDirective = hasRelationalDirective;
const getPartitionKey = (ks) => ks.find((att) => att.keyType === 'HASH').attributeName;
exports.getPartitionKey = getPartitionKey;
const extendTypeWithDirectives = (ctx, typeName, directives) => {
    let objectTypeExtension = (0, graphql_transformer_common_1.blankObjectExtension)(typeName);
    objectTypeExtension = (0, graphql_transformer_common_1.extensionWithDirectives)(objectTypeExtension, directives);
    ctx.output.addObjectExtension(objectTypeExtension);
};
exports.extendTypeWithDirectives = extendTypeWithDirectives;
const addDirectivesToField = (ctx, typeName, fieldName, directives) => {
    var _a;
    const type = ctx.output.getType(typeName);
    if (type) {
        const field = (_a = type.fields) === null || _a === void 0 ? void 0 : _a.find((f) => f.name.value === fieldName);
        if (field) {
            const newFields = [...type.fields.filter((f) => f.name.value !== field.name.value), (0, graphql_transformer_common_1.extendFieldWithDirectives)(field, directives)];
            const newType = {
                ...type,
                fields: newFields,
            };
            ctx.output.putType(newType);
        }
    }
};
exports.addDirectivesToField = addDirectivesToField;
const addSubscriptionArguments = (ctx, operationName, subscriptionRoles) => {
    let subscription = ctx.output.getSubscription();
    let createField = subscription.fields.find((field) => field.name.value === operationName);
    const subscriptionArgumentList = subscriptionRoles.map((role) => (0, graphql_transformer_common_1.makeInputValueDefinition)(role.entity, (0, graphql_transformer_common_1.makeNamedType)('String')));
    createField = {
        ...createField,
        arguments: [...createField.arguments, ...subscriptionArgumentList],
    };
    subscription = {
        ...subscription,
        fields: subscription.fields.map((field) => (field.name.value === operationName ? createField : field)),
    };
    ctx.output.putType(subscription);
};
exports.addSubscriptionArguments = addSubscriptionArguments;
const addDirectivesToOperation = (ctx, typeName, operationName, directives) => {
    (0, exports.addDirectivesToField)(ctx, typeName, operationName, directives);
    const type = ctx.output.getType(typeName);
    if (type) {
        const field = type.fields.find((f) => f.name.value === operationName);
        if (field) {
            const returnFieldType = field.type;
            if (returnFieldType.name) {
                const returnTypeName = returnFieldType.name.value;
                (0, exports.extendTypeWithDirectives)(ctx, returnTypeName, directives);
            }
        }
    }
};
exports.addDirectivesToOperation = addDirectivesToOperation;
const getQueryFieldNames = (modelDirectiveConfig) => {
    var _a, _b, _c;
    const fields = new Set();
    if ((_a = modelDirectiveConfig === null || modelDirectiveConfig === void 0 ? void 0 : modelDirectiveConfig.queries) === null || _a === void 0 ? void 0 : _a.get) {
        fields.add({
            typeName: 'Query',
            fieldName: modelDirectiveConfig.queries.get,
            type: graphql_transformer_interfaces_1.QueryFieldType.GET,
        });
    }
    if ((_b = modelDirectiveConfig === null || modelDirectiveConfig === void 0 ? void 0 : modelDirectiveConfig.queries) === null || _b === void 0 ? void 0 : _b.list) {
        fields.add({
            typeName: 'Query',
            fieldName: modelDirectiveConfig.queries.list,
            type: graphql_transformer_interfaces_1.QueryFieldType.LIST,
        });
    }
    if ((_c = modelDirectiveConfig === null || modelDirectiveConfig === void 0 ? void 0 : modelDirectiveConfig.queries) === null || _c === void 0 ? void 0 : _c.sync) {
        fields.add({
            typeName: 'Query',
            fieldName: modelDirectiveConfig.queries.sync,
            type: graphql_transformer_interfaces_1.QueryFieldType.SYNC,
        });
    }
    return fields;
};
exports.getQueryFieldNames = getQueryFieldNames;
const getMutationFieldNames = (modelDirectiveConfig) => {
    const getMutationType = (type) => {
        switch (type) {
            case 'create':
                return graphql_transformer_interfaces_1.MutationFieldType.CREATE;
            case 'update':
                return graphql_transformer_interfaces_1.MutationFieldType.UPDATE;
            case 'delete':
                return graphql_transformer_interfaces_1.MutationFieldType.DELETE;
            default:
                throw new Error('Unknown mutation type');
        }
    };
    const fieldNames = new Set();
    for (const [mutationType, mutationName] of Object.entries((modelDirectiveConfig === null || modelDirectiveConfig === void 0 ? void 0 : modelDirectiveConfig.mutations) || {})) {
        if (mutationName) {
            fieldNames.add({
                typeName: 'Mutation',
                fieldName: mutationName,
                type: getMutationType(mutationType),
            });
        }
    }
    return fieldNames;
};
exports.getMutationFieldNames = getMutationFieldNames;
const getSubscriptionFieldNames = (modelDirectiveConfig) => {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const fields = new Set();
    const subscriptionLevel = (_b = (_a = modelDirectiveConfig === null || modelDirectiveConfig === void 0 ? void 0 : modelDirectiveConfig.subscriptions) === null || _a === void 0 ? void 0 : _a.level) !== null && _b !== void 0 ? _b : graphql_model_transformer_1.SubscriptionLevel.on;
    if (subscriptionLevel !== graphql_model_transformer_1.SubscriptionLevel.on) {
        return fields;
    }
    if (((_c = modelDirectiveConfig === null || modelDirectiveConfig === void 0 ? void 0 : modelDirectiveConfig.subscriptions) === null || _c === void 0 ? void 0 : _c.onCreate) && ((_d = modelDirectiveConfig.mutations) === null || _d === void 0 ? void 0 : _d.create)) {
        for (const fieldName of modelDirectiveConfig.subscriptions.onCreate) {
            fields.add({
                typeName: 'Subscription',
                fieldName,
            });
        }
    }
    if (((_e = modelDirectiveConfig === null || modelDirectiveConfig === void 0 ? void 0 : modelDirectiveConfig.subscriptions) === null || _e === void 0 ? void 0 : _e.onUpdate) && ((_f = modelDirectiveConfig.mutations) === null || _f === void 0 ? void 0 : _f.update)) {
        for (const fieldName of modelDirectiveConfig.subscriptions.onUpdate) {
            fields.add({
                typeName: 'Subscription',
                fieldName,
            });
        }
    }
    if (((_g = modelDirectiveConfig === null || modelDirectiveConfig === void 0 ? void 0 : modelDirectiveConfig.subscriptions) === null || _g === void 0 ? void 0 : _g.onDelete) && ((_h = modelDirectiveConfig.mutations) === null || _h === void 0 ? void 0 : _h.delete)) {
        for (const fieldName of modelDirectiveConfig.subscriptions.onDelete) {
            fields.add({
                typeName: 'Subscription',
                fieldName,
            });
        }
    }
    return fields;
};
exports.getSubscriptionFieldNames = getSubscriptionFieldNames;
const ensureValidSubscriptionName = (name) => {
    if (name.length <= 50)
        return name;
    return name.slice(0, 45) + (0, md5_1.default)(name).slice(0, 5);
};
const getKeyFields = (ctx, model) => {
    var _a;
    const table = (0, graphql_transformer_core_1.getTable)(ctx, model);
    const hashKeyField = table.keySchema.find((f) => f.keyType === 'HASH').attributeName;
    const sortKeyFields = (_a = table.keySchema.find((f) => f.keyType === 'RANGE')) === null || _a === void 0 ? void 0 : _a.attributeName.split('#');
    const keyFields = [hashKeyField];
    if (sortKeyFields) {
        keyFields.push(...sortKeyFields);
    }
    return keyFields;
};
//# sourceMappingURL=schema.js.map