"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccessControlMatrix = void 0;
const graphql_transformer_core_1 = require("@aws-amplify/graphql-transformer-core");
class AccessControlMatrix {
    constructor(config) {
        this.name = config.name;
        this.operations = config.operations;
        this.resources = config.resources;
        this.matrix = [];
        this.roles = [];
    }
    setRole(input) {
        const { role, resource, operations, allowRoleOverwrite = false } = input;
        this.validate({ resource, operations });
        let allowedVector;
        if (!this.roles.includes(role)) {
            allowedVector = this.getResourceOperationMatrix({ operations, resource });
            this.roles.push(input.role);
            this.matrix.push(allowedVector);
            if (this.roles.length !== this.matrix.length) {
                throw new Error('Roles are not aligned with Roles added in Matrix');
            }
        }
        else if (this.roles.includes(role) && (resource || allowRoleOverwrite)) {
            allowedVector = this.getResourceOperationMatrix({ operations, resource, role });
            const roleIndex = this.roles.indexOf(role);
            this.matrix[roleIndex] = allowedVector;
        }
        else {
            throw new graphql_transformer_core_1.InvalidDirectiveError(`@auth ${role} already exists for ${this.name}`);
        }
    }
    hasRole(role) {
        return this.roles.includes(role);
    }
    getName() {
        return this.name;
    }
    getRoles() {
        return this.roles;
    }
    getResources() {
        return this.resources;
    }
    hasResource(resource) {
        return this.resources.includes(resource);
    }
    isAllowed(role, resource, operation) {
        this.validate({ role, resource, operations: [operation] });
        const roleIndex = this.roles.indexOf(role);
        const resourceIndex = this.resources.indexOf(resource);
        const operationIndex = this.operations.indexOf(operation);
        return this.matrix[roleIndex][resourceIndex][operationIndex];
    }
    resetAccessForResource(resource) {
        this.validate({ resource });
        const resourceIndex = this.resources.indexOf(resource);
        this.roles.forEach((_, i) => {
            this.matrix[i][resourceIndex] = new Array(this.operations.length).fill(false);
        });
    }
    getRolesPerOperation(operation, fullAccess = false) {
        this.validate({ operations: [operation] });
        const operationIndex = this.operations.indexOf(operation);
        const roles = new Array();
        this.roles.forEach((_, x) => {
            let hasOperation = false;
            if (fullAccess) {
                hasOperation = this.resources.every((_, idx) => this.matrix[x][idx][operationIndex]);
            }
            else {
                hasOperation = this.resources.some((_, idx) => this.matrix[x][idx][operationIndex]);
            }
            if (hasOperation)
                roles.push(this.roles[x]);
        });
        return roles;
    }
    getAcmPerRole() {
        const acmPerRole = new Map();
        this.matrix.forEach((_, i) => {
            const tableObj = {};
            this.matrix[i].forEach((_, y) => {
                tableObj[this.resources[y]] = this.matrix[i][y].reduce((prev, resource, index) => {
                    prev[this.operations[index]] = resource;
                    return prev;
                }, {});
            });
            acmPerRole.set(this.roles[i], tableObj);
        });
        return acmPerRole;
    }
    validate(input) {
        if (input.resource && !this.resources.includes(input.resource)) {
            throw new graphql_transformer_core_1.TransformerContractError(`Resource: ${input.resource} is not configured in the ACM`);
        }
        if (input.role && !this.roles.includes(input.role)) {
            throw new graphql_transformer_core_1.TransformerContractError(`Role: ${input.role} does not exist in ACM.`);
        }
        if (input.operations) {
            input.operations.forEach((operation) => {
                if (this.operations.indexOf(operation) === -1) {
                    throw new graphql_transformer_core_1.TransformerContractError(`Operation: ${operation} does not exist in the ACM.`);
                }
            });
        }
    }
    getResourceOperationMatrix(input) {
        const { operations, resource, role } = input;
        let fieldAllowVector = [];
        const operationList = this.getOperationList(operations);
        if (role && resource) {
            const roleIndex = this.roles.indexOf(role);
            const resourceIndex = this.resources.indexOf(resource);
            fieldAllowVector = this.matrix[roleIndex];
            fieldAllowVector[resourceIndex] = operationList;
            return fieldAllowVector;
        }
        this.resources.forEach((_, i) => {
            if (resource) {
                if (this.resources.indexOf(resource) === i) {
                    fieldAllowVector.push(operationList);
                }
                else {
                    fieldAllowVector.push(new Array(this.operations.length).fill(false));
                }
            }
            else {
                fieldAllowVector.push(operationList);
            }
        });
        return fieldAllowVector;
    }
    getOperationList(operations) {
        const operationList = [];
        this.operations.forEach((operation) => {
            operationList.push(operations.includes(operation));
        });
        return operationList;
    }
}
exports.AccessControlMatrix = AccessControlMatrix;
//# sourceMappingURL=acm.js.map