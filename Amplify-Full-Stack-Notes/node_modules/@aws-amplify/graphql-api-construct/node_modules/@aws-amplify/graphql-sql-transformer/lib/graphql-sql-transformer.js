"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateSqlLambdaResponseMappingTemplate = exports.generateSqlLambdaRequestTemplate = exports.SqlTransformer = void 0;
const graphql_transformer_core_1 = require("@aws-amplify/graphql-transformer-core");
const graphql_directives_1 = require("@aws-amplify/graphql-directives");
const cdk = __importStar(require("aws-cdk-lib"));
const graphql_mapping_template_1 = require("graphql-mapping-template");
const graphql_transformer_common_1 = require("graphql-transformer-common");
const SQL_DIRECTIVE_STACK = 'CustomSQLStack';
class SqlTransformer extends graphql_transformer_core_1.TransformerPluginBase {
    constructor() {
        super('amplify-sql-transformer', graphql_directives_1.SqlDirective.definition);
        this.sqlDirectiveFields = new Map();
        this.field = (parent, definition, directive, ctx) => {
            var _a, _b;
            if (parent.name.value !== 'Query' && parent.name.value !== 'Mutation') {
                throw new graphql_transformer_core_1.InvalidDirectiveError(`@sql directive can only be used on Query or Mutation types. Check type "${parent.name.value}" and field "${definition.name.value}".`);
            }
            const directiveWrapped = new graphql_transformer_core_1.DirectiveWrapper(directive);
            if (!((_a = directive === null || directive === void 0 ? void 0 : directive.arguments) === null || _a === void 0 ? void 0 : _a.find((arg) => arg.name.value === 'statement')) &&
                !((_b = directive === null || directive === void 0 ? void 0 : directive.arguments) === null || _b === void 0 ? void 0 : _b.find((arg) => arg.name.value === 'reference'))) {
                throw new graphql_transformer_core_1.InvalidDirectiveError(`@sql directive must have either a 'statement' or a 'reference' argument. Check type "${parent.name.value}" and field "${definition.name.value}".`);
            }
            const args = directiveWrapped.getArguments({
                resolverTypeName: parent.name.value,
                resolverFieldName: definition.name.value,
            }, (0, graphql_transformer_core_1.generateGetArgumentsInput)(ctx.transformParameters));
            let resolver = this.sqlDirectiveFields.get(definition);
            if (resolver === undefined) {
                resolver = [];
                this.sqlDirectiveFields.set(definition, resolver);
            }
            resolver.push(args);
        };
        this.generateResolvers = (context) => {
            if (this.sqlDirectiveFields.size === 0) {
                return;
            }
            const stack = context.stackManager.createStack(SQL_DIRECTIVE_STACK);
            const env = context.synthParameters.amplifyEnvironmentName;
            stack.templateOptions.templateFormatVersion = '2010-09-09';
            stack.templateOptions.description = 'An auto-generated nested stack for the @sql directive.';
            new cdk.CfnCondition(stack, graphql_transformer_common_1.ResourceConstants.CONDITIONS.HasEnvironmentParameter, {
                expression: cdk.Fn.conditionNot(cdk.Fn.conditionEquals(env, graphql_transformer_common_1.ResourceConstants.NONE)),
            });
            this.sqlDirectiveFields.forEach((resolverFns) => {
                resolverFns.forEach((config) => {
                    var _a;
                    const typeName = config.resolverTypeName;
                    const fieldName = config.resolverFieldName;
                    const strategy = (_a = context.sqlDirectiveDataSourceStrategies) === null || _a === void 0 ? void 0 : _a.find((css) => css.typeName === typeName && css.fieldName === fieldName);
                    if (!strategy) {
                        throw new Error(`Could not find custom SQL strategy for ${typeName}.${fieldName}`);
                    }
                    const resourceNames = (0, graphql_transformer_core_1.getResourceNamesForStrategy)(strategy.strategy);
                    const dataSourceId = resourceNames.sqlLambdaDataSource;
                    const dataSource = context.api.host.getDataSource(dataSourceId);
                    const statement = getStatement(config, strategy.customSqlStatements);
                    const resolverResourceId = graphql_transformer_common_1.ResolverResourceIDs.ResolverResourceID(config.resolverTypeName, config.resolverFieldName);
                    const resolver = context.resolvers.generateQueryResolver(config.resolverTypeName, config.resolverFieldName, resolverResourceId, dataSource, graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString((0, exports.generateSqlLambdaRequestTemplate)(statement, 'RAW_SQL', config.resolverFieldName), `${config.resolverTypeName}.${config.resolverFieldName}.req.vtl`), graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString((0, exports.generateSqlLambdaResponseMappingTemplate)(), `${config.resolverTypeName}.${config.resolverFieldName}.res.vtl`));
                    resolver.addVtlFunctionToSlot('postAuth', graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(generatePostAuthExpression(context.transformParameters.sandboxModeEnabled, context.synthParameters.enableIamAccess), `${config.resolverTypeName}.${config.resolverFieldName}.{slotName}.{slotIndex}.req.vtl`));
                    resolver.setScope(context.stackManager.getScopeFor(resolverResourceId, SQL_DIRECTIVE_STACK));
                    context.resolvers.addResolver(config.resolverTypeName, config.resolverFieldName, resolver);
                });
            });
        };
    }
}
exports.SqlTransformer = SqlTransformer;
const generatePostAuthExpression = (isSandboxModeEnabled, genericIamAccessEnabled) => {
    const API_KEY = 'API Key Authorization';
    const IAM_AUTH_TYPE = 'IAM Authorization';
    const expressions = [];
    if (isSandboxModeEnabled) {
        expressions.push((0, graphql_mapping_template_1.iff)((0, graphql_mapping_template_1.equals)((0, graphql_mapping_template_1.methodCall)((0, graphql_mapping_template_1.ref)('util.authType')), (0, graphql_mapping_template_1.str)(API_KEY)), (0, graphql_mapping_template_1.ret)((0, graphql_mapping_template_1.toJson)((0, graphql_mapping_template_1.obj)({})))));
    }
    if (genericIamAccessEnabled) {
        const isNonCognitoIAMPrincipal = (0, graphql_mapping_template_1.and)([
            (0, graphql_mapping_template_1.equals)((0, graphql_mapping_template_1.ref)('util.authType()'), (0, graphql_mapping_template_1.str)(IAM_AUTH_TYPE)),
            (0, graphql_mapping_template_1.methodCall)((0, graphql_mapping_template_1.ref)('util.isNull'), (0, graphql_mapping_template_1.ref)('ctx.identity.cognitoIdentityPoolId')),
            (0, graphql_mapping_template_1.methodCall)((0, graphql_mapping_template_1.ref)('util.isNull'), (0, graphql_mapping_template_1.ref)('ctx.identity.cognitoIdentityId')),
        ]);
        expressions.push((0, graphql_mapping_template_1.iff)(isNonCognitoIAMPrincipal, (0, graphql_mapping_template_1.ret)((0, graphql_mapping_template_1.toJson)((0, graphql_mapping_template_1.obj)({})))));
    }
    expressions.push((0, graphql_mapping_template_1.methodCall)((0, graphql_mapping_template_1.ref)('util.unauthorized')));
    return (0, graphql_mapping_template_1.printBlock)(`Sandbox Mode ${isSandboxModeEnabled ? 'Enabled' : 'Disabled'}, IAM Access ${genericIamAccessEnabled ? 'Enabled' : 'Disabled'}`)((0, graphql_mapping_template_1.compoundExpression)([(0, graphql_mapping_template_1.iff)((0, graphql_mapping_template_1.not)((0, graphql_mapping_template_1.ref)('ctx.stash.get("hasAuth")')), (0, graphql_mapping_template_1.compoundExpression)(expressions)), (0, graphql_mapping_template_1.toJson)((0, graphql_mapping_template_1.obj)({}))]));
};
const getStatementFromStatementAttribute = (config) => {
    const statement = config.statement;
    if (statement === undefined || statement.trim().length === 0) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`@sql directive 'statement' argument must not be empty. Check type "${config.resolverTypeName}" and field "${config.resolverFieldName}".`);
    }
    return statement;
};
const getStatementFromReferenceAttribute = (config, customQueries) => {
    if (!config.reference || !customQueries || !customQueries[config.reference]) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`The ${config.resolverTypeName} field "${config.resolverFieldName}" references a custom SQL statement "${config.reference}" that ` +
            `doesn't exist. Verify that "${config.reference}" is a key in the customSqlStatements property.`);
    }
    return customQueries[config.reference];
};
const getStatement = (config, customQueries) => {
    if (config.reference && config.statement) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`@sql directive can have either a 'statement' or a 'reference' argument but not both. Check type "${config.resolverTypeName}" and field "${config.resolverFieldName}".`);
    }
    if (typeof config.statement === 'string') {
        return getStatementFromStatementAttribute(config);
    }
    if (typeof config.reference === 'string') {
        return getStatementFromReferenceAttribute(config, customQueries);
    }
    throw new graphql_transformer_core_1.InvalidDirectiveError(`@sql directive must have either a 'statement' or a 'reference' argument. Check type "${config.resolverTypeName}" and field "${config.resolverFieldName}".`);
};
const generateSqlLambdaRequestTemplate = (statement, operation, operationName) => {
    return (0, graphql_mapping_template_1.printBlock)('Invoke RDS Lambda data source')((0, graphql_mapping_template_1.compoundExpression)([
        (0, graphql_mapping_template_1.set)((0, graphql_mapping_template_1.ref)('lambdaInput'), (0, graphql_mapping_template_1.obj)({})),
        (0, graphql_mapping_template_1.set)((0, graphql_mapping_template_1.ref)('lambdaInput.parameters'), (0, graphql_mapping_template_1.obj)({})),
        (0, graphql_mapping_template_1.set)((0, graphql_mapping_template_1.ref)('lambdaInput.statement'), (0, graphql_mapping_template_1.str)(statement)),
        (0, graphql_mapping_template_1.set)((0, graphql_mapping_template_1.ref)('lambdaInput.operation'), (0, graphql_mapping_template_1.str)(operation)),
        (0, graphql_mapping_template_1.set)((0, graphql_mapping_template_1.ref)('lambdaInput.operationName'), (0, graphql_mapping_template_1.str)(operationName)),
        (0, graphql_mapping_template_1.set)((0, graphql_mapping_template_1.ref)('lambdaInput.parameters'), (0, graphql_mapping_template_1.methodCall)((0, graphql_mapping_template_1.ref)('util.defaultIfNull'), (0, graphql_mapping_template_1.ref)('context.arguments'), (0, graphql_mapping_template_1.obj)({}))),
        (0, graphql_mapping_template_1.obj)({
            version: (0, graphql_mapping_template_1.str)('2018-05-29'),
            operation: (0, graphql_mapping_template_1.str)('Invoke'),
            payload: (0, graphql_mapping_template_1.methodCall)((0, graphql_mapping_template_1.ref)('util.toJson'), (0, graphql_mapping_template_1.ref)('lambdaInput')),
        }),
    ]));
};
exports.generateSqlLambdaRequestTemplate = generateSqlLambdaRequestTemplate;
const generateSqlLambdaResponseMappingTemplate = () => {
    const statements = [];
    statements.push((0, graphql_mapping_template_1.ifElse)((0, graphql_mapping_template_1.ref)('ctx.error'), (0, graphql_mapping_template_1.methodCall)((0, graphql_mapping_template_1.ref)('util.error'), (0, graphql_mapping_template_1.ref)('ctx.error.message'), (0, graphql_mapping_template_1.ref)('ctx.error.type')), (0, graphql_mapping_template_1.toJson)((0, graphql_mapping_template_1.ref)('ctx.result'))));
    return (0, graphql_mapping_template_1.printBlock)('ResponseTemplate')((0, graphql_mapping_template_1.compoundExpression)(statements));
};
exports.generateSqlLambdaResponseMappingTemplate = generateSqlLambdaResponseMappingTemplate;
//# sourceMappingURL=graphql-sql-transformer.js.map