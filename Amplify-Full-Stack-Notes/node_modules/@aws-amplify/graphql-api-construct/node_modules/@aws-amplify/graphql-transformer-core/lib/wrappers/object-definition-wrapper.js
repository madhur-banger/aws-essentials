"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EnumWrapper = exports.InputObjectDefinitionWrapper = exports.ObjectDefinitionWrapper = exports.FieldWrapper = exports.InputFieldWrapper = exports.GenericFieldWrapper = void 0;
const graphql_1 = require("graphql");
const graphql_transformer_common_1 = require("graphql-transformer-common");
const directive_wrapper_1 = require("../utils/directive-wrapper");
class GenericFieldWrapper {
    constructor(field) {
        this.isList = () => {
            return this.isListType(this.type);
        };
        this.isNonNullable = () => {
            return this.type.kind === 'NonNullType';
        };
        this.makeNullable = () => {
            if (this.isNonNullable()) {
                this.type = this.type.type;
                return true;
            }
            return false;
        };
        this.makeNonNullable = () => {
            if (!this.isNonNullable()) {
                this.type = { kind: 'NonNullType', type: this.type };
                return true;
            }
            return false;
        };
        this.wrapListType = () => {
            if (!this.isList()) {
                this.type = {
                    kind: 'ListType',
                    type: this.type,
                };
            }
            return this;
        };
        this.unWrapListType = () => {
            if (!this.isList()) {
                this.type = this.type.type;
                return true;
            }
            return false;
        };
        this.isListType = (type) => {
            if (type.kind === graphql_1.Kind.NON_NULL_TYPE) {
                return (0, graphql_1.isListType)(type.type);
            }
            else {
                return type.kind === graphql_1.Kind.LIST_TYPE;
            }
        };
        this.getBaseType = () => {
            let node = this.type;
            while (node.kind === graphql_1.Kind.LIST_TYPE || node.kind === graphql_1.Kind.NON_NULL_TYPE) {
                node = node.type;
            }
            return node;
        };
        this.getTypeName = () => {
            return this.getBaseType().name.value;
        };
        this.isScalar = () => {
            const typeName = this.getTypeName();
            return Object.keys(graphql_transformer_common_1.DEFAULT_SCALARS).includes(typeName);
        };
        this.type = field.type;
        this.name = field.name.value;
        this.loc = field.loc;
        this.directives = (field.directives || []).map((d) => new directive_wrapper_1.DirectiveWrapper(d));
    }
}
exports.GenericFieldWrapper = GenericFieldWrapper;
class InputFieldWrapper extends GenericFieldWrapper {
    constructor(field) {
        super(field);
        this.field = field;
        this.serialize = () => {
            var _a;
            return {
                ...this.field,
                kind: 'InputValueDefinition',
                name: { kind: 'Name', value: this.name },
                type: this.type,
                description: this.description,
                directives: (_a = this.directives) === null || _a === void 0 ? void 0 : _a.map((d) => d.serialize()),
            };
        };
        this.type = field.type;
        this.name = field.name.value;
    }
}
exports.InputFieldWrapper = InputFieldWrapper;
InputFieldWrapper.fromField = (name, field, parent, document) => {
    var _a;
    const autoGeneratableFieldsWithType = {
        id: ['ID'],
        createdAt: ['AWSDateTime', 'String'],
        updatedAt: ['AWSDateTime', 'String'],
    };
    let type;
    if (((_a = parent.directives) === null || _a === void 0 ? void 0 : _a.some((directive) => directive.name.value === 'model')) &&
        Object.keys(autoGeneratableFieldsWithType).indexOf(name) !== -1 &&
        autoGeneratableFieldsWithType[name].indexOf((0, graphql_transformer_common_1.unwrapNonNull)(field.type).name.value) !== -1) {
        type = (0, graphql_transformer_common_1.unwrapNonNull)(field.type);
    }
    else {
        type =
            (0, graphql_transformer_common_1.isScalar)(field.type) || (0, graphql_transformer_common_1.isEnum)(field.type, document)
                ? field.type
                : (0, graphql_transformer_common_1.withNamedNodeNamed)(field.type, graphql_transformer_common_1.ModelResourceIDs.NonModelInputObjectName((0, graphql_transformer_common_1.getBaseType)(field.type)));
    }
    return new InputFieldWrapper({
        kind: 'InputValueDefinition',
        name: { kind: 'Name', value: name },
        type,
    });
};
InputFieldWrapper.create = (name, type, isNullable = false, isList = false) => {
    const field = new InputFieldWrapper({
        kind: 'InputValueDefinition',
        name: {
            kind: 'Name',
            value: name,
        },
        type: {
            kind: 'NamedType',
            name: {
                value: type,
                kind: 'Name',
            },
        },
    });
    if (!isNullable) {
        field.makeNonNullable();
    }
    if (isList) {
        field.wrapListType();
    }
    return field;
};
class FieldWrapper extends GenericFieldWrapper {
    constructor(field) {
        super(field);
        this.serialize = () => {
            var _a;
            return {
                kind: 'FieldDefinition',
                name: { kind: 'Name', value: this.name },
                type: this.type,
                arguments: this.argumenets,
                description: this.description,
                directives: (_a = this.directives) === null || _a === void 0 ? void 0 : _a.map((d) => d.serialize()),
            };
        };
        this.argumenets = [...(field.arguments || [])];
        this.description = field.description;
        this.loc = field.loc;
    }
}
exports.FieldWrapper = FieldWrapper;
FieldWrapper.create = (name, type, isNullable = false, isList = false) => {
    const field = new FieldWrapper({
        kind: 'FieldDefinition',
        name: {
            kind: 'Name',
            value: name,
        },
        type: {
            kind: 'NamedType',
            name: {
                value: type,
                kind: 'Name',
            },
        },
    });
    if (!isNullable) {
        field.makeNonNullable();
    }
    if (isList) {
        field.wrapListType().makeNonNullable();
    }
    return field;
};
class ObjectDefinitionWrapper {
    constructor(node) {
        this.node = node;
        this.serialize = () => {
            var _a;
            return {
                ...this.node,
                name: {
                    kind: 'Name',
                    value: this.name,
                },
                fields: this.fields.map((f) => f.serialize()),
                directives: (_a = this.directives) === null || _a === void 0 ? void 0 : _a.map((d) => d.serialize()),
            };
        };
        this.hasField = (name) => {
            const field = this.fields.find((f) => f.name === name);
            return !!field;
        };
        this.getField = (name) => {
            const field = this.fields.find((f) => f.name === name);
            if (!field) {
                throw new Error(`Field ${name} missing in type ${this.name}`);
            }
            return field;
        };
        this.addField = (field) => {
            if (this.hasField(field.name)) {
                throw new Error(`type ${this.name} has already a field with name ${field.name}`);
            }
            this.fields.push(field);
        };
        this.removeField = (field) => {
            if (this.hasField(field.name)) {
                throw new Error(`type ${this.name} does not have the field with name ${field.name}`);
            }
            const index = this.fields.indexOf(field);
            this.fields.splice(index, 1);
        };
        this.directives = (node.directives || []).map((d) => new directive_wrapper_1.DirectiveWrapper(d));
        this.fields = (node.fields || []).map((f) => new FieldWrapper(f));
        this.name = node.name.value;
    }
}
exports.ObjectDefinitionWrapper = ObjectDefinitionWrapper;
ObjectDefinitionWrapper.create = (name, fields = [], directives = []) => {
    return new ObjectDefinitionWrapper({
        kind: 'ObjectTypeDefinition',
        name: {
            kind: 'Name',
            value: name,
        },
        fields: fields,
        directives: directives,
    });
};
class InputObjectDefinitionWrapper {
    constructor(node) {
        this.node = node;
        this.serialize = () => {
            var _a;
            return {
                ...this.node,
                fields: this.fields.map((f) => f.serialize()),
                directives: (_a = this.directives) === null || _a === void 0 ? void 0 : _a.map((d) => d.serialize()),
            };
        };
        this.hasField = (name) => {
            const field = this.fields.find((f) => f.name === name);
            return !!field;
        };
        this.getField = (name) => {
            const field = this.fields.find((f) => f.name === name);
            if (!field) {
                throw new Error(`Field ${name} missing in type ${this.name}`);
            }
            return field;
        };
        this.addField = (field) => {
            if (this.hasField(field.name)) {
                throw new Error(`type ${this.name} has already a field with name ${field.name}`);
            }
            this.fields.push(field);
        };
        this.removeField = (field) => {
            if (!this.hasField(field.name)) {
                throw new Error(`type ${this.name} does not have the field with name ${field.name}`);
            }
            const index = this.fields.indexOf(field);
            this.fields.splice(index, 1);
        };
        this.directives = (node.directives || []).map((d) => new directive_wrapper_1.DirectiveWrapper(d));
        this.fields = (node.fields || []).map((f) => new InputFieldWrapper(f));
        this.name = node.name.value;
    }
}
exports.InputObjectDefinitionWrapper = InputObjectDefinitionWrapper;
InputObjectDefinitionWrapper.create = (name, fields = [], directives = []) => {
    const wrappedObj = new InputObjectDefinitionWrapper({
        kind: 'InputObjectTypeDefinition',
        name: {
            kind: 'Name',
            value: name,
        },
        fields: [],
        directives: directives,
    });
    for (let field of fields) {
        const fieldWrapper = new InputFieldWrapper(field);
        wrappedObj.addField(fieldWrapper);
    }
    return wrappedObj;
};
InputObjectDefinitionWrapper.fromObject = (name, def, document) => {
    const inputObj = {
        kind: 'InputObjectTypeDefinition',
        name: { kind: 'Name', value: name },
        fields: [],
        directives: [],
    };
    const wrappedInput = new InputObjectDefinitionWrapper(inputObj);
    for (let f of def.fields || []) {
        const wrappedField = InputFieldWrapper.fromField(f.name.value, f, def, document);
        wrappedInput.fields.push(wrappedField);
    }
    return wrappedInput;
};
class EnumWrapper {
    constructor(node) {
        var _a;
        this.node = node;
        this.addValue = (value) => {
            this.values.push(value);
        };
        this.serialize = () => {
            return {
                ...this.node,
                name: {
                    kind: 'Name',
                    value: this.name,
                },
                directives: this.directives.map((d) => d.serialize()),
                values: this.values.map((value) => ({
                    kind: 'EnumValueDefinition',
                    name: {
                        kind: 'Name',
                        value: value,
                    },
                })),
            };
        };
        this.name = node.name.value;
        this.values = ((_a = node.values) === null || _a === void 0 ? void 0 : _a.map((v) => v.name.value)) || [];
        this.directives = (node.directives || []).map((d) => new directive_wrapper_1.DirectiveWrapper(d));
    }
}
exports.EnumWrapper = EnumWrapper;
EnumWrapper.create = (name, values = []) => {
    const wrappedEnum = new EnumWrapper({
        kind: 'EnumTypeDefinition',
        name: {
            kind: 'Name',
            value: name,
        },
        values: [],
    });
    values.forEach((val) => {
        wrappedEnum.addValue(val);
    });
    return wrappedEnum;
};
//# sourceMappingURL=object-definition-wrapper.js.map