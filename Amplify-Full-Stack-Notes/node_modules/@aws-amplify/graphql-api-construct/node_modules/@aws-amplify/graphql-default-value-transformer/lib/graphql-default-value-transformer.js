"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultValueTransformer = void 0;
const graphql_transformer_core_1 = require("@aws-amplify/graphql-transformer-core");
const graphql_directives_1 = require("@aws-amplify/graphql-directives");
const graphql_1 = require("graphql");
const graphql_mapping_template_1 = require("graphql-mapping-template");
const graphql_transformer_common_1 = require("graphql-transformer-common");
const validators_1 = require("./validators");
const nonStringTypes = ['Int', 'Float', 'Boolean', 'AWSTimestamp', 'AWSJSON'];
const validateFieldType = (ctx, config) => {
    var _a, _b;
    const type = config.field.type;
    const argc = (_b = (_a = config.directive.arguments) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
    const enums = ctx.output.getTypeDefinitionsOfKind(graphql_1.Kind.ENUM_TYPE_DEFINITION);
    if ((0, graphql_transformer_common_1.isListType)(type) || !(0, graphql_transformer_common_1.isScalarOrEnum)(type, enums)) {
        throw new graphql_transformer_core_1.InvalidDirectiveError('The @default directive may only be added to scalar or enum field types.');
    }
    if ((0, graphql_transformer_core_1.isPostgresModel)(ctx, config.object.name.value) && argc === 0 && (0, graphql_transformer_common_1.getBaseType)(type) !== 'Int') {
        throw new graphql_transformer_core_1.InvalidDirectiveError('The @default directive requires a value property on non-Int types.');
    }
};
const validateDirectiveArguments = (ctx, config) => {
    var _a, _b;
    const argc = (_b = (_a = config.directive.arguments) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
    const isPostgres = (0, graphql_transformer_core_1.isPostgresModel)(ctx, config.object.name.value);
    if (!isPostgres && argc === 0)
        throw new graphql_transformer_core_1.InvalidDirectiveError('The @default directive requires a value property on non-Postgres datasources.');
    if (argc > 1)
        throw new graphql_transformer_core_1.InvalidDirectiveError('The @default directive only takes a value property');
};
const validateModelDirective = (config) => {
    const modelDirective = config.object.directives.find((dir) => dir.name.value === 'model');
    if (!modelDirective) {
        throw new graphql_transformer_core_1.InvalidDirectiveError('The @default directive may only be added to object definitions annotated with @model.');
    }
};
const validateDefaultValueType = (ctx, config) => {
    if (config.value === null) {
        throw new graphql_transformer_core_1.InvalidDirectiveError('The @default directive does not support null values.');
    }
    const enums = ctx.output.getTypeDefinitionsOfKind(graphql_1.Kind.ENUM_TYPE_DEFINITION);
    if (enums &&
        (0, graphql_transformer_common_1.isEnum)(config.field.type, ctx.inputDocument) &&
        !enums.find((it) => it.name.value === (0, graphql_transformer_common_1.getBaseType)(config.field.type)).values.find((v) => v.name.value === config.value)) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`Default value "${config.value}" is not a member of ${(0, graphql_transformer_common_1.getBaseType)(config.field.type)} enum.`);
    }
    const typeValidators = new validators_1.TypeValidators();
    if (!(0, graphql_transformer_common_1.isEnum)(config.field.type, ctx.inputDocument) && !typeValidators[(0, graphql_transformer_common_1.getBaseType)(config.field.type)](config.value)) {
        throw new graphql_transformer_core_1.InvalidDirectiveError(`Default value "${config.value}" is not a valid ${(0, graphql_transformer_common_1.getBaseType)(config.field.type)}.`);
    }
};
const validate = (ctx, config) => {
    validateModelDirective(config);
    validateFieldType(ctx, config);
    validateDirectiveArguments(ctx, config);
    const isDynamoDB = (0, graphql_transformer_core_1.isDynamoDbModel)(ctx, config.object.name.value);
    if (isDynamoDB) {
        validateDefaultValueType(ctx, config);
    }
};
class DefaultValueTransformer extends graphql_transformer_core_1.TransformerPluginBase {
    constructor() {
        super('amplify-default-value-transformer', graphql_directives_1.DefaultDirective.definition);
        this.directiveMap = new Map();
        this.field = (parent, definition, directive, ctx) => {
            const directiveWrapped = new graphql_transformer_core_1.DirectiveWrapper(directive);
            const config = directiveWrapped.getArguments({
                object: parent,
                field: definition,
                directive,
            }, (0, graphql_transformer_core_1.generateGetArgumentsInput)(ctx.transformParameters));
            validate(ctx, config);
            if (!this.directiveMap.has(parent.name.value)) {
                this.directiveMap.set(parent.name.value, []);
            }
            this.directiveMap.get(parent.name.value).push(config);
        };
        this.transformSchema = (ctx) => {
            for (const typeName of this.directiveMap.keys()) {
                const name = graphql_transformer_common_1.ModelResourceIDs.ModelCreateInputObjectName(typeName);
                for (const config of this.directiveMap.get(typeName)) {
                    const input = graphql_transformer_core_1.InputObjectDefinitionWrapper.fromObject(name, config.object, ctx.inputDocument);
                    const fieldWrapper = input.fields.find((f) => f.name === config.field.name.value);
                    fieldWrapper === null || fieldWrapper === void 0 ? void 0 : fieldWrapper.makeNullable();
                    if ((0, graphql_transformer_core_1.isPostgresModel)(ctx, typeName)) {
                        ctx.output.updateInput(input.serialize());
                    }
                }
            }
        };
        this.generateResolvers = (ctx) => {
            const context = ctx;
            for (const typeName of this.directiveMap.keys()) {
                const isDynamoDB = (0, graphql_transformer_core_1.isDynamoDbModel)(ctx, typeName);
                if (!isDynamoDB) {
                    continue;
                }
                const snippets = [];
                for (const config of this.directiveMap.get(typeName)) {
                    const fieldName = config.field.name.value;
                    const defaultValueArgumentValueNode = config.directive.arguments[0].value;
                    const defaultValue = defaultValueArgumentValueNode.value;
                    snippets.push(this.makeDefaultValueSnippet(fieldName, defaultValue, !nonStringTypes.includes((0, graphql_transformer_common_1.getBaseType)(config.field.type))));
                }
                this.updateResolverWithDefaultValues(context, (0, graphql_transformer_common_1.toCamelCase)(['create', typeName]), snippets);
            }
        };
        this.makeDefaultValueSnippet = (fieldName, defaultValue, isString) => (0, graphql_mapping_template_1.printBlock)(`Setting "${fieldName}" to default value of "${defaultValue}"`)((0, graphql_mapping_template_1.qref)((0, graphql_mapping_template_1.methodCall)((0, graphql_mapping_template_1.ref)('context.args.input.put'), (0, graphql_mapping_template_1.str)(fieldName), (0, graphql_mapping_template_1.methodCall)((0, graphql_mapping_template_1.ref)('util.defaultIfNull'), (0, graphql_mapping_template_1.ref)(`ctx.args.input.${fieldName}`), isString ? (0, graphql_mapping_template_1.str)(defaultValue) : (0, graphql_mapping_template_1.raw)(defaultValue)))));
        this.updateResolverWithDefaultValues = (ctx, resolverLogicalId, snippets) => {
            const resolver = this.getResolverObject(ctx, resolverLogicalId);
            if (resolver) {
                this.addSnippetToResolverSlot(resolver, snippets);
            }
        };
        this.getResolverObject = (ctx, resolverLogicalId) => {
            var _a;
            const objectName = ctx.output.getMutationTypeName();
            if (!objectName) {
                return null;
            }
            return (_a = ctx.resolvers.getResolver(objectName, resolverLogicalId)) !== null && _a !== void 0 ? _a : null;
        };
        this.addSnippetToResolverSlot = (resolver, snippets) => {
            const res = resolver;
            res.addVtlFunctionToSlot('init', graphql_transformer_core_1.MappingTemplate.s3MappingTemplateFromString(snippets.join('\n') + '\n{}', `${res.typeName}.${res.fieldName}.{slotName}.{slotIndex}.req.vtl`));
        };
    }
}
exports.DefaultValueTransformer = DefaultValueTransformer;
//# sourceMappingURL=graphql-default-value-transformer.js.map