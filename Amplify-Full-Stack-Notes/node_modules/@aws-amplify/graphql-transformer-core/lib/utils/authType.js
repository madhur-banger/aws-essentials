"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.adoptAuthMode = exports.adoptAuthModes = void 0;
const aws_appsync_1 = require("aws-cdk-lib/aws-appsync");
const aws_cognito_1 = require("aws-cdk-lib/aws-cognito");
const aws_cdk_lib_1 = require("aws-cdk-lib");
const authTypeMap = {
    API_KEY: aws_appsync_1.AuthorizationType.API_KEY,
    AMAZON_COGNITO_USER_POOLS: aws_appsync_1.AuthorizationType.USER_POOL,
    AWS_IAM: aws_appsync_1.AuthorizationType.IAM,
    OPENID_CONNECT: aws_appsync_1.AuthorizationType.OIDC,
    AWS_LAMBDA: 'AWS_LAMBDA',
};
const adoptAuthModes = (stackManager, synthParameters, authConfig) => {
    var _a;
    return {
        defaultAuthorization: (0, exports.adoptAuthMode)(stackManager, synthParameters, authConfig.defaultAuthentication),
        additionalAuthorizationModes: (_a = authConfig.additionalAuthenticationProviders) === null || _a === void 0 ? void 0 : _a.map((entry) => (0, exports.adoptAuthMode)(stackManager, synthParameters, entry)),
    };
};
exports.adoptAuthModes = adoptAuthModes;
const adoptAuthMode = (stackManager, synthParameters, entry) => {
    var _a, _b;
    const authType = authTypeMap[entry.authenticationType];
    switch (entry.authenticationType) {
        case aws_appsync_1.AuthorizationType.API_KEY:
            return {
                authorizationType: authType,
                apiKeyConfig: {
                    description: (_a = entry.apiKeyConfig) === null || _a === void 0 ? void 0 : _a.description,
                    expires: ((_b = entry.apiKeyConfig) === null || _b === void 0 ? void 0 : _b.apiKeyExpirationDays)
                        ? aws_cdk_lib_1.Expiration.after(aws_cdk_lib_1.Duration.days(entry.apiKeyConfig.apiKeyExpirationDays))
                        : undefined,
                },
            };
        case aws_appsync_1.AuthorizationType.USER_POOL: {
            if (!synthParameters.userPoolId) {
                throw new Error('Expected userPoolId to be present in synth parameters when user pool auth is specified.');
            }
            return {
                authorizationType: authType,
                userPoolConfig: {
                    userPool: aws_cognito_1.UserPool.fromUserPoolId(stackManager.scope, 'transformer-user-pool', synthParameters.userPoolId),
                },
            };
        }
        case aws_appsync_1.AuthorizationType.IAM:
            return {
                authorizationType: authType,
            };
        case aws_appsync_1.AuthorizationType.OIDC:
            return {
                authorizationType: authType,
                openIdConnectConfig: {
                    oidcProvider: entry.openIDConnectConfig.issuerUrl,
                    clientId: entry.openIDConnectConfig.clientId,
                    tokenExpiryFromAuth: strToNumber(entry.openIDConnectConfig.authTTL),
                    tokenExpiryFromIssue: strToNumber(entry.openIDConnectConfig.iatTTL),
                },
            };
        case 'AWS_LAMBDA':
            return {
                authorizationType: authType,
                lambdaAuthorizerConfig: {
                    lambdaArn: entry.lambdaAuthorizerConfig.lambdaArn,
                    lambdaFunction: entry.lambdaAuthorizerConfig.lambdaFunction,
                    ttlSeconds: strToNumber(entry.lambdaAuthorizerConfig.ttlSeconds),
                },
            };
        default:
            throw new Error('Invalid auth config');
    }
};
exports.adoptAuthMode = adoptAuthMode;
const strToNumber = (input) => {
    if (typeof input === 'string') {
        return Number.parseInt(input, 10);
    }
    return input;
};
//# sourceMappingURL=authType.js.map