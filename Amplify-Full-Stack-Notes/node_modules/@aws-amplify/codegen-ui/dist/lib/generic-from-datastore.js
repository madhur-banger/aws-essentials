"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getGenericFromDataStore = void 0;
const errors_1 = require("./errors");
const isFieldModelType = (field) => typeof field.type === 'object' && 'model' in field.type;
const getAssociatedFieldNames = (field) => {
    if (!field.association || !('associatedWith' in field.association)) {
        return [];
    }
    return Array.isArray(field.association.associatedWith)
        ? field.association.associatedWith
        : [field.association.associatedWith];
};
const getTargetNames = (field) => {
    const { association } = field;
    if (association) {
        const targetName = 'targetName' in association && association.targetName;
        const targetNames = 'targetNames' in association && association.targetNames;
        if (typeof targetName === 'string') {
            return [targetName];
        }
        if (Array.isArray(targetNames)) {
            return targetNames;
        }
    }
    return [];
};
/**
  Disclaimer: there's no 100% sure way of telling if something's a join table.
  This is best effort.
  Feature request w/ amplify-codegen: https://github.com/aws-amplify/amplify-codegen/issues/543
  After fulfilled, this can be fallback
 */
function checkIsModelAJoinTable(modelName, schema) {
    var _a;
    const model = schema.models[modelName];
    if (!model) {
        return false;
    }
    let numberOfKeyTypeAttributes = 0;
    const allowedNonModelFields = ['id', 'createdAt', 'updatedAt'];
    (_a = model.attributes) === null || _a === void 0 ? void 0 : _a.forEach((attribute) => {
        if (attribute.type === 'key') {
            numberOfKeyTypeAttributes += 1;
            if (attribute.properties && 'fields' in attribute.properties && Array.isArray(attribute.properties.fields)) {
                allowedNonModelFields.push(...attribute.properties.fields);
            }
        }
    });
    // should have 2 keys
    if (numberOfKeyTypeAttributes !== 2) {
        return false;
    }
    const modelFieldTuples = [];
    let allFieldsAllowed = true;
    Object.entries(model.fields).forEach((field) => {
        const [name, value] = field;
        if (isFieldModelType(value)) {
            modelFieldTuples.push(field);
        }
        else if (!allowedNonModelFields.includes(name)) {
            allFieldsAllowed = false;
        }
    });
    // non-model fields should be limited
    if (!allFieldsAllowed) {
        return false;
    }
    // should have 2 model fields
    if (modelFieldTuples.length !== 2) {
        return false;
    }
    return modelFieldTuples.every(([fieldName, fieldValue]) => {
        var _a;
        // should be required
        if (!fieldValue.isRequired) {
            return false;
        }
        // should be BELONGS_TO
        if (((_a = fieldValue.association) === null || _a === void 0 ? void 0 : _a.connectionType) !== 'BELONGS_TO') {
            return false;
        }
        const relatedModel = isFieldModelType(fieldValue) && schema.models[fieldValue.type.model];
        if (!relatedModel) {
            return false;
        }
        // should be bidirectional with HAS_MANY
        // that has a different model type
        return Object.values(relatedModel.fields).some((field) => {
            var _a;
            if (!isFieldModelType(field) || ((_a = field.association) === null || _a === void 0 ? void 0 : _a.connectionType) !== 'HAS_MANY') {
                return false;
            }
            const associatedFieldNames = getAssociatedFieldNames(field);
            return associatedFieldNames.length === 1 && associatedFieldNames.includes(fieldName);
        });
    });
}
function getGenericDataField(field) {
    return {
        dataType: field.type,
        required: !!field.isRequired,
        readOnly: !!field.isReadOnly,
        isArray: field.isArray,
    };
}
/* eslint-disable no-param-reassign */
function addRelationship(fields, modelName, fieldName, relationship) {
    // handle prototype-pollution vulnerability
    if (modelName === '__proto__') {
        throw new errors_1.InvalidInputError('Invalid model name "__proto__"');
    }
    if (!fields[modelName]) {
        fields[modelName] = {};
    }
    const existingRelationship = fields[modelName][fieldName];
    const isHasManyIndex = existingRelationship && 'isHasManyIndex' in existingRelationship && existingRelationship.isHasManyIndex;
    if ((relationship === null || relationship === void 0 ? void 0 : relationship.type) === 'HAS_ONE' || (relationship === null || relationship === void 0 ? void 0 : relationship.type) === 'BELONGS_TO') {
        // give priority to designations as isHasManyIndex and BELONGS_TO
        if (isHasManyIndex) {
            relationship.isHasManyIndex = true;
        }
        if ((existingRelationship === null || existingRelationship === void 0 ? void 0 : existingRelationship.type) === 'BELONGS_TO') {
            relationship.type = 'BELONGS_TO';
        }
    }
    fields[modelName][fieldName] = relationship;
}
/* eslint-enable no-param-reassign */
// get custom primary keys || id
// TODO: when moved over to use introspection schema, this can be vastly simplified
function getPrimaryKeys({ model }) {
    var _a, _b, _c;
    const customPrimaryKeys = (_c = (_b = (_a = model.attributes) === null || _a === void 0 ? void 0 : _a.find((attr) => attr.type === 'key' &&
        (attr.properties === undefined ||
            // presence of name indicates that it is a secondary index and not a primary key
            !Object.keys(attr.properties).includes('name')))) === null || _b === void 0 ? void 0 : _b.properties) === null || _c === void 0 ? void 0 : _c.fields;
    return customPrimaryKeys && Array.isArray(customPrimaryKeys) && customPrimaryKeys.length ? customPrimaryKeys : ['id'];
}
function getGenericFromDataStore(dataStoreSchema) {
    const genericSchema = {
        dataSourceType: 'DataStore',
        models: {},
        enums: {},
        nonModels: {},
    };
    const fieldsWithImplicitRelationships = {};
    const joinTableNames = [];
    Object.values(dataStoreSchema.models).forEach((model) => {
        const genericFields = {};
        Object.values(model.fields).forEach((field) => {
            var _a;
            const genericField = getGenericDataField(field);
            // handle relationships
            if (isFieldModelType(field)) {
                if (field.association) {
                    const relationshipType = field.association.connectionType;
                    let relatedModelName = field.type.model;
                    let relatedJoinFieldName;
                    let relatedJoinTableName;
                    let modelRelationship;
                    if (relationshipType === 'HAS_MANY' && 'associatedWith' in field.association) {
                        // for 1:m relationships, we will not attach these
                        // (i.e. model-type fields) as relatedModelFields
                        const modelTypeFieldsOnHasManyChild = new Set();
                        const associatedModel = dataStoreSchema.models[relatedModelName];
                        const associatedFieldNames = getAssociatedFieldNames(field);
                        let canUnlinkAssociatedModel = true;
                        associatedFieldNames.forEach((associatedFieldName) => {
                            const associatedField = associatedModel === null || associatedModel === void 0 ? void 0 : associatedModel.fields[associatedFieldName];
                            // if any of the associatedField is required, you cannot unlink from parent model
                            if (associatedField === null || associatedField === void 0 ? void 0 : associatedField.isRequired) {
                                canUnlinkAssociatedModel = false;
                            }
                            // if the associated model is a join table, update relatedModelName to the actual related model
                            if (associatedModel && checkIsModelAJoinTable(associatedModel.name, dataStoreSchema)) {
                                joinTableNames.push(associatedModel.name);
                                const relatedJoinField = Object.values(associatedModel.fields).find((joinField) => joinField.name !== associatedFieldName && isFieldModelType(joinField));
                                if (relatedJoinField && isFieldModelType(relatedJoinField)) {
                                    relatedJoinTableName = relatedModelName;
                                    relatedModelName = relatedJoinField.type.model;
                                    relatedJoinFieldName = relatedJoinField.name;
                                }
                                // if the associated model is not a join table, note implicit relationship for associated field
                            }
                            else if (associatedField) {
                                if (isFieldModelType(associatedField)) {
                                    modelTypeFieldsOnHasManyChild.add(associatedFieldName);
                                }
                                else {
                                    addRelationship(fieldsWithImplicitRelationships, relatedModelName, associatedFieldName, {
                                        type: 'HAS_ONE',
                                        relatedModelName: model.name,
                                        // identify index on 1:m child as such
                                        isHasManyIndex: true,
                                    });
                                }
                            }
                        });
                        const belongsToFieldOnRelatedModelTuple = Object.entries((_a = associatedModel === null || associatedModel === void 0 ? void 0 : associatedModel.fields) !== null && _a !== void 0 ? _a : {}).find(([, f]) => { var _a; return isFieldModelType(f) && f.type.model === model.name && ((_a = f.association) === null || _a === void 0 ? void 0 : _a.connectionType) === 'BELONGS_TO'; });
                        if (belongsToFieldOnRelatedModelTuple && belongsToFieldOnRelatedModelTuple[1].isRequired) {
                            canUnlinkAssociatedModel = false;
                        }
                        modelRelationship = {
                            type: relationshipType,
                            canUnlinkAssociatedModel,
                            relatedModelName,
                            relatedModelFields: associatedFieldNames.filter((n) => !modelTypeFieldsOnHasManyChild.has(n)),
                            relatedJoinFieldName,
                            relatedJoinTableName,
                        };
                        if (belongsToFieldOnRelatedModelTuple) {
                            const [belongsToField] = belongsToFieldOnRelatedModelTuple;
                            modelRelationship.belongsToFieldOnRelatedModel = belongsToField;
                        }
                    }
                    if (relationshipType === 'HAS_ONE' || relationshipType === 'BELONGS_TO') {
                        const targetNames = getTargetNames(field);
                        const associatedFields = [];
                        // note implicit relationship for associated field within same model
                        if (targetNames) {
                            targetNames.forEach((targetName) => {
                                addRelationship(fieldsWithImplicitRelationships, model.name, targetName, {
                                    type: relationshipType,
                                    relatedModelName,
                                });
                                associatedFields.push(targetName);
                            });
                        }
                        modelRelationship = {
                            type: relationshipType,
                            relatedModelName,
                            associatedFields: associatedFields.length ? associatedFields : undefined,
                        };
                    }
                    genericField.relationship = modelRelationship;
                }
            }
            genericFields[field.name] = genericField;
        });
        genericSchema.models[model.name] = { fields: genericFields, primaryKeys: getPrimaryKeys({ model }) };
    });
    Object.entries(fieldsWithImplicitRelationships).forEach(([modelName, fields]) => {
        Object.entries(fields).forEach(([fieldName, relationship]) => {
            var _a;
            const field = (_a = genericSchema.models[modelName]) === null || _a === void 0 ? void 0 : _a.fields[fieldName];
            if (field) {
                field.relationship = relationship;
            }
        });
    });
    joinTableNames.forEach((joinTableName) => {
        const model = genericSchema.models[joinTableName];
        if (model) {
            model.isJoinTable = true;
        }
    });
    genericSchema.enums = dataStoreSchema.enums;
    if (dataStoreSchema.nonModels) {
        Object.values(dataStoreSchema.nonModels).forEach((nonModel) => {
            const genericFields = {};
            Object.values(nonModel.fields).forEach((field) => {
                const genericField = getGenericDataField(field);
                genericFields[field.name] = genericField;
            });
            genericSchema.nonModels[nonModel.name] = { fields: genericFields };
        });
    }
    return genericSchema;
}
exports.getGenericFromDataStore = getGenericFromDataStore;
//# sourceMappingURL=generic-from-datastore.js.map