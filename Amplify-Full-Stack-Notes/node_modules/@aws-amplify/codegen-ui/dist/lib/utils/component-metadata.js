"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.computeComponentMetadata = void 0;
const state_reference_metadata_1 = require("./state-reference-metadata");
/**
 * Component Structure Functions
 */
// Check top-level binding properties, then call helper on the chilren.
function computeComponentMetadata(component) {
    const { bindingProperties, collectionProperties } = component;
    const componentMetadataWithoutDataDependencies = dedupeComponentMetadata(reduceComponentMetadata([
        ...(bindingProperties ? Object.values(bindingProperties).map(computeBindingPropertyMetadata) : []),
        ...(collectionProperties ? Object.values(collectionProperties).map(computeCollectionPropertyMetadata) : []),
        computeComponentMetadataHelper(component),
    ]));
    return {
        ...componentMetadataWithoutDataDependencies,
        stateReferences: (0, state_reference_metadata_1.computeStateReferenceMetadata)(component, componentMetadataWithoutDataDependencies.stateReferences.map(({ reference }) => reference)),
    };
}
exports.computeComponentMetadata = computeComponentMetadata;
// Check names, properties, events, and recurse through children.
function computeComponentMetadataHelper(component) {
    return reduceComponentMetadata([
        generateNameMappingMetadata(component.name, component.componentType),
        ...(component.properties ? Object.values(component.properties).map(computePropertyMetadata) : []),
        ...(component.events ? Object.values(component.events).map(computeEventMetadata) : []),
        ...(component.children ? component.children.map(computeComponentMetadataHelper) : []),
    ]);
}
/**
 * Utility Functions
 */
// Because object equality won't catch dupes here, we'll map by component Name, dedupe
// properties, then unroll to a list.
// Dont dedupe setters though, since they'll all be their own ref
function dedupeStateReferences(stateReferences) {
    const stateReferenceMap = {};
    stateReferences
        .filter(({ reference }) => !('set' in reference) || reference.set === null || reference.set === undefined)
        .forEach(({ reference: { componentName, property } }) => {
        if (!(componentName in stateReferenceMap)) {
            stateReferenceMap[componentName] = new Set([]);
        }
        stateReferenceMap[componentName].add(property);
    });
    return Object.entries(stateReferenceMap)
        .flatMap(([componentName, properties]) => [...properties].map((property) => {
        const dataDependencies = [];
        return { reference: { componentName, property }, dataDependencies };
    }))
        .concat(stateReferences.filter(({ reference }) => 'set' in reference && reference.set));
}
function dedupeComponentMetadata(componentMetadata) {
    const { hasAuthBindings, requiredDataModels, stateReferences, componentNameToTypeMap } = componentMetadata;
    return {
        hasAuthBindings,
        requiredDataModels: [...new Set(requiredDataModels)],
        stateReferences: dedupeStateReferences(stateReferences),
        componentNameToTypeMap,
    };
}
function reduceComponentMetadata(componentMetadata) {
    const mergeMetadata = (lhs, rhs) => {
        return {
            hasAuthBindings: lhs.hasAuthBindings || rhs.hasAuthBindings,
            requiredDataModels: [...lhs.requiredDataModels, ...rhs.requiredDataModels],
            stateReferences: [...lhs.stateReferences, ...rhs.stateReferences],
            componentNameToTypeMap: { ...lhs.componentNameToTypeMap, ...rhs.componentNameToTypeMap },
        };
    };
    return componentMetadata.reduce(mergeMetadata, generateEmptyMetadata());
}
function generateEmptyMetadata() {
    return {
        hasAuthBindings: false,
        requiredDataModels: [],
        stateReferences: [],
        componentNameToTypeMap: {},
    };
}
function generateAuthBindingMetadata() {
    return {
        hasAuthBindings: true,
        requiredDataModels: [],
        stateReferences: [],
        componentNameToTypeMap: {},
    };
}
function generateModelMetadata(model) {
    return {
        hasAuthBindings: false,
        requiredDataModels: [model],
        stateReferences: [],
        componentNameToTypeMap: {},
    };
}
function generateReferenceMetadata(reference) {
    return {
        hasAuthBindings: false,
        requiredDataModels: [],
        stateReferences: [{ reference, dataDependencies: [] }],
        componentNameToTypeMap: {},
    };
}
function generateNameMappingMetadata(componentName, componentType) {
    if (componentName) {
        return {
            hasAuthBindings: false,
            requiredDataModels: [],
            stateReferences: [],
            componentNameToTypeMap: { [componentName]: componentType },
        };
    }
    return generateEmptyMetadata();
}
/**
 * Binding Property Functions
 */
function computeCollectionPropertyMetadata(dataConfiguration) {
    return generateModelMetadata(dataConfiguration.model);
}
function computeBindingPropertyMetadata(bindingProperty) {
    switch (bindingProperty.type) {
        case 'Event':
            return generateEmptyMetadata();
        case 'Data':
            return generateModelMetadata(bindingProperty.bindingProperties.model);
        case 'Storage':
            return generateEmptyMetadata();
        default:
            if ('type' in bindingProperty) {
                return generateEmptyMetadata();
            }
            throw new Error(`Binding Property ${JSON.stringify(bindingProperty)} could not be parsed for Metadata.`);
    }
}
/**
 * Property Functions
 */
function computePropertyMetadata(property) {
    const meta = typeof property !== 'object'
        ? []
        : []
            .concat('concat' in property && property.concat ? property.concat.map(computePropertyMetadata) : [])
            .concat('userAttribute' in property && property.userAttribute ? [generateAuthBindingMetadata()] : [])
            .concat('condition' in property && property.condition && 'then' in property.condition && property.condition.then
            ? [computePropertyMetadata(property.condition.then)]
            : [])
            .concat('condition' in property && property.condition && 'else' in property.condition && property.condition.else
            ? [computePropertyMetadata(property.condition.else)]
            : [])
            .concat('componentName' in property && property.componentName && 'property' in property && property.property
            ? [generateReferenceMetadata(property)]
            : []);
    return reduceComponentMetadata(meta);
}
/**
 * Event Functions
 */
function computeEventMetadata(event) {
    if (!('action' in event) || event.action === undefined || event.action === null) {
        return generateEmptyMetadata();
    }
    switch (event.action) {
        case 'Amplify.Navigation':
            return reduceComponentMetadata(Object.values(event.parameters).map(computePropertyMetadata));
        case 'Amplify.AuthSignOut':
            return reduceComponentMetadata(Object.values(event.parameters).map(computePropertyMetadata));
        case 'Amplify.DataStoreCreateItemAction':
            return reduceComponentMetadata([
                generateModelMetadata(event.parameters.model),
                ...Object.values(event.parameters.fields).map(computePropertyMetadata),
            ]);
        case 'Amplify.DataStoreUpdateItemAction':
            return reduceComponentMetadata([
                generateModelMetadata(event.parameters.model),
                computePropertyMetadata(event.parameters.id),
                ...Object.values(event.parameters.fields).map(computePropertyMetadata),
            ]);
        case 'Amplify.DataStoreDeleteItemAction':
            return reduceComponentMetadata([
                generateModelMetadata(event.parameters.model),
                computePropertyMetadata(event.parameters.id),
            ]);
        case 'Amplify.Mutation':
            return reduceComponentMetadata([
                generateReferenceMetadata(event.parameters.state),
                computePropertyMetadata(event.parameters.state.set),
            ]);
        default:
            throw new Error(`Event ${JSON.stringify(event)} could not be parsed for Metadata.`);
    }
}
//# sourceMappingURL=component-metadata.js.map