"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.resolveBetweenPredicateToMultiplePredicates = exports.OPERAND_DELIMITER = exports.isSlotBinding = exports.isEventPropertyBinding = exports.isSimplePropertyBinding = exports.isDataPropertyBinding = exports.isStudioComponentWithBreakpoints = exports.isStudioComponentWithVariants = exports.isStudioComponentWithCollectionProperties = exports.isAuthProperty = exports.isStudioComponentWithBinding = void 0;
/*
  Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.

  Licensed under the Apache License, Version 2.0 (the "License").
  You may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
 */
const errors_1 = require("./errors");
const types_1 = require("./types");
const breakpoint_utils_1 = require("./utils/breakpoint-utils");
function isStudioComponentWithBinding(component) {
    return typeof component === 'object' && 'bindingProperties' in component;
}
exports.isStudioComponentWithBinding = isStudioComponentWithBinding;
function isAuthProperty(prop) {
    return typeof prop === 'object' && 'userAttribute' in prop;
}
exports.isAuthProperty = isAuthProperty;
/**
 * Verify if this is 1) a type that has the collectionProperties, and 2) that the collection
 * properties object is set. Then provide the typehint back to the compiler that this attribute exists.
 */
function isStudioComponentWithCollectionProperties(component) {
    return (typeof component === 'object' && 'collectionProperties' in component && component.collectionProperties !== undefined);
}
exports.isStudioComponentWithCollectionProperties = isStudioComponentWithCollectionProperties;
function isStudioComponentWithVariants(component) {
    return (typeof component === 'object' &&
        'variants' in component &&
        component.variants !== undefined &&
        component.variants.length > 0);
}
exports.isStudioComponentWithVariants = isStudioComponentWithVariants;
function isStudioComponentWithBreakpoints(component) {
    if (isStudioComponentWithVariants(component)) {
        return component.variants.some((variant) => { var _a; return breakpoint_utils_1.breakpointSizes.includes((_a = variant === null || variant === void 0 ? void 0 : variant.variantValues) === null || _a === void 0 ? void 0 : _a.breakpoint); });
    }
    return false;
}
exports.isStudioComponentWithBreakpoints = isStudioComponentWithBreakpoints;
function isDataPropertyBinding(prop) {
    return typeof prop === 'object' && 'type' in prop && prop.type === 'Data';
}
exports.isDataPropertyBinding = isDataPropertyBinding;
function isSimplePropertyBinding(prop) {
    return (typeof prop === 'object' &&
        'type' in prop &&
        [
            types_1.StudioComponentPropertyType.Boolean.toString(),
            types_1.StudioComponentPropertyType.Number.toString(),
            types_1.StudioComponentPropertyType.String.toString(),
            types_1.StudioComponentPropertyType.Date.toString(),
        ].includes(prop.type));
}
exports.isSimplePropertyBinding = isSimplePropertyBinding;
function isEventPropertyBinding(prop) {
    return typeof prop === 'object' && 'type' in prop && prop.type === 'Event';
}
exports.isEventPropertyBinding = isEventPropertyBinding;
function isSlotBinding(prop) {
    return typeof prop === 'object' && 'type' in prop && prop.type === 'Amplify.Slot';
}
exports.isSlotBinding = isSlotBinding;
/**
 For StudioComponentPredicate, there are cases when
 we want multiple operands. This string indicates the end of
 one operand and start of another.
 Warning: if you change this, saved schemas may break.
 */
exports.OPERAND_DELIMITER = '<Amplify.OperandDelimiter>';
function resolveBetweenPredicateToMultiplePredicates(betweenPredicate) {
    var _a;
    const operands = (_a = betweenPredicate.operand) === null || _a === void 0 ? void 0 : _a.split(exports.OPERAND_DELIMITER);
    if (!operands || operands.length !== 2) {
        throw new errors_1.InvalidInputError('There must be 2 operands for a `between` predicate');
    }
    return {
        and: [
            { field: betweenPredicate.field, operator: 'ge', operand: operands[0] },
            { field: betweenPredicate.field, operator: 'le', operand: operands[1] },
        ],
    };
}
exports.resolveBetweenPredicateToMultiplePredicates = resolveBetweenPredicateToMultiplePredicates;
//# sourceMappingURL=renderer-helper.js.map