#!/usr/bin/env node
import { createMainParser } from './main_parser_factory.js';
import { attachUnhandledExceptionListeners, generateCommandFailureHandler, } from './error_handler.js';
import { extractSubCommands } from './extract_sub_commands.js';
import { AmplifyFault, PackageJsonReader, UsageDataEmitterFactory, } from '@aws-amplify/platform-core';
import { fileURLToPath } from 'node:url';
import { verifyCommandName } from './verify_command_name.js';
import { hideBin } from 'yargs/helpers';
import { format } from '@aws-amplify/cli-core';
const packageJson = new PackageJsonReader().read(fileURLToPath(new URL('../package.json', import.meta.url)));
const libraryVersion = packageJson.version;
if (libraryVersion == undefined) {
    throw new AmplifyFault('UnknownVersionFault', {
        message: 'Library version cannot be determined. Check the library installation',
    });
}
const usageDataEmitter = await new UsageDataEmitterFactory().getInstance(libraryVersion);
attachUnhandledExceptionListeners(usageDataEmitter);
verifyCommandName();
const parser = createMainParser(libraryVersion);
const errorHandler = generateCommandFailureHandler(parser, usageDataEmitter);
try {
    await parser.parseAsync(hideBin(process.argv));
    const metricDimension = {};
    const subCommands = extractSubCommands(parser);
    if (subCommands) {
        metricDimension.command = subCommands;
    }
    await usageDataEmitter.emitSuccess({}, metricDimension);
}
catch (e) {
    if (e instanceof Error) {
        await errorHandler(format.error(e), e);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW1weC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9hbXB4LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUM1RCxPQUFPLEVBQ0wsaUNBQWlDLEVBQ2pDLDZCQUE2QixHQUM5QixNQUFNLG9CQUFvQixDQUFDO0FBQzVCLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBQy9ELE9BQU8sRUFDTCxZQUFZLEVBQ1osaUJBQWlCLEVBQ2pCLHVCQUF1QixHQUN4QixNQUFNLDRCQUE0QixDQUFDO0FBQ3BDLE9BQU8sRUFBRSxhQUFhLEVBQUUsTUFBTSxVQUFVLENBQUM7QUFDekMsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sMEJBQTBCLENBQUM7QUFDN0QsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN4QyxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFFL0MsTUFBTSxXQUFXLEdBQUcsSUFBSSxpQkFBaUIsRUFBRSxDQUFDLElBQUksQ0FDOUMsYUFBYSxDQUFDLElBQUksR0FBRyxDQUFDLGlCQUFpQixFQUFFLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FDM0QsQ0FBQztBQUNGLE1BQU0sY0FBYyxHQUFHLFdBQVcsQ0FBQyxPQUFPLENBQUM7QUFFM0MsSUFBSSxjQUFjLElBQUksU0FBUyxFQUFFO0lBQy9CLE1BQU0sSUFBSSxZQUFZLENBQUMscUJBQXFCLEVBQUU7UUFDNUMsT0FBTyxFQUNMLHNFQUFzRTtLQUN6RSxDQUFDLENBQUM7Q0FDSjtBQUVELE1BQU0sZ0JBQWdCLEdBQUcsTUFBTSxJQUFJLHVCQUF1QixFQUFFLENBQUMsV0FBVyxDQUN0RSxjQUFjLENBQ2YsQ0FBQztBQUVGLGlDQUFpQyxDQUFDLGdCQUFnQixDQUFDLENBQUM7QUFFcEQsaUJBQWlCLEVBQUUsQ0FBQztBQUVwQixNQUFNLE1BQU0sR0FBRyxnQkFBZ0IsQ0FBQyxjQUFjLENBQUMsQ0FBQztBQUNoRCxNQUFNLFlBQVksR0FBRyw2QkFBNkIsQ0FBQyxNQUFNLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztBQUU3RSxJQUFJO0lBQ0YsTUFBTSxNQUFNLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztJQUMvQyxNQUFNLGVBQWUsR0FBMkIsRUFBRSxDQUFDO0lBQ25ELE1BQU0sV0FBVyxHQUFHLGtCQUFrQixDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBRS9DLElBQUksV0FBVyxFQUFFO1FBQ2YsZUFBZSxDQUFDLE9BQU8sR0FBRyxXQUFXLENBQUM7S0FDdkM7SUFFRCxNQUFNLGdCQUFnQixDQUFDLFdBQVcsQ0FBQyxFQUFFLEVBQUUsZUFBZSxDQUFDLENBQUM7Q0FDekQ7QUFBQyxPQUFPLENBQUMsRUFBRTtJQUNWLElBQUksQ0FBQyxZQUFZLEtBQUssRUFBRTtRQUN0QixNQUFNLFlBQVksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0tBQ3hDO0NBQ0YiLCJzb3VyY2VzQ29udGVudCI6WyIjIS91c3IvYmluL2VudiBub2RlXG5pbXBvcnQgeyBjcmVhdGVNYWluUGFyc2VyIH0gZnJvbSAnLi9tYWluX3BhcnNlcl9mYWN0b3J5LmpzJztcbmltcG9ydCB7XG4gIGF0dGFjaFVuaGFuZGxlZEV4Y2VwdGlvbkxpc3RlbmVycyxcbiAgZ2VuZXJhdGVDb21tYW5kRmFpbHVyZUhhbmRsZXIsXG59IGZyb20gJy4vZXJyb3JfaGFuZGxlci5qcyc7XG5pbXBvcnQgeyBleHRyYWN0U3ViQ29tbWFuZHMgfSBmcm9tICcuL2V4dHJhY3Rfc3ViX2NvbW1hbmRzLmpzJztcbmltcG9ydCB7XG4gIEFtcGxpZnlGYXVsdCxcbiAgUGFja2FnZUpzb25SZWFkZXIsXG4gIFVzYWdlRGF0YUVtaXR0ZXJGYWN0b3J5LFxufSBmcm9tICdAYXdzLWFtcGxpZnkvcGxhdGZvcm0tY29yZSc7XG5pbXBvcnQgeyBmaWxlVVJMVG9QYXRoIH0gZnJvbSAnbm9kZTp1cmwnO1xuaW1wb3J0IHsgdmVyaWZ5Q29tbWFuZE5hbWUgfSBmcm9tICcuL3ZlcmlmeV9jb21tYW5kX25hbWUuanMnO1xuaW1wb3J0IHsgaGlkZUJpbiB9IGZyb20gJ3lhcmdzL2hlbHBlcnMnO1xuaW1wb3J0IHsgZm9ybWF0IH0gZnJvbSAnQGF3cy1hbXBsaWZ5L2NsaS1jb3JlJztcblxuY29uc3QgcGFja2FnZUpzb24gPSBuZXcgUGFja2FnZUpzb25SZWFkZXIoKS5yZWFkKFxuICBmaWxlVVJMVG9QYXRoKG5ldyBVUkwoJy4uL3BhY2thZ2UuanNvbicsIGltcG9ydC5tZXRhLnVybCkpXG4pO1xuY29uc3QgbGlicmFyeVZlcnNpb24gPSBwYWNrYWdlSnNvbi52ZXJzaW9uO1xuXG5pZiAobGlicmFyeVZlcnNpb24gPT0gdW5kZWZpbmVkKSB7XG4gIHRocm93IG5ldyBBbXBsaWZ5RmF1bHQoJ1Vua25vd25WZXJzaW9uRmF1bHQnLCB7XG4gICAgbWVzc2FnZTpcbiAgICAgICdMaWJyYXJ5IHZlcnNpb24gY2Fubm90IGJlIGRldGVybWluZWQuIENoZWNrIHRoZSBsaWJyYXJ5IGluc3RhbGxhdGlvbicsXG4gIH0pO1xufVxuXG5jb25zdCB1c2FnZURhdGFFbWl0dGVyID0gYXdhaXQgbmV3IFVzYWdlRGF0YUVtaXR0ZXJGYWN0b3J5KCkuZ2V0SW5zdGFuY2UoXG4gIGxpYnJhcnlWZXJzaW9uXG4pO1xuXG5hdHRhY2hVbmhhbmRsZWRFeGNlcHRpb25MaXN0ZW5lcnModXNhZ2VEYXRhRW1pdHRlcik7XG5cbnZlcmlmeUNvbW1hbmROYW1lKCk7XG5cbmNvbnN0IHBhcnNlciA9IGNyZWF0ZU1haW5QYXJzZXIobGlicmFyeVZlcnNpb24pO1xuY29uc3QgZXJyb3JIYW5kbGVyID0gZ2VuZXJhdGVDb21tYW5kRmFpbHVyZUhhbmRsZXIocGFyc2VyLCB1c2FnZURhdGFFbWl0dGVyKTtcblxudHJ5IHtcbiAgYXdhaXQgcGFyc2VyLnBhcnNlQXN5bmMoaGlkZUJpbihwcm9jZXNzLmFyZ3YpKTtcbiAgY29uc3QgbWV0cmljRGltZW5zaW9uOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG4gIGNvbnN0IHN1YkNvbW1hbmRzID0gZXh0cmFjdFN1YkNvbW1hbmRzKHBhcnNlcik7XG5cbiAgaWYgKHN1YkNvbW1hbmRzKSB7XG4gICAgbWV0cmljRGltZW5zaW9uLmNvbW1hbmQgPSBzdWJDb21tYW5kcztcbiAgfVxuXG4gIGF3YWl0IHVzYWdlRGF0YUVtaXR0ZXIuZW1pdFN1Y2Nlc3Moe30sIG1ldHJpY0RpbWVuc2lvbik7XG59IGNhdGNoIChlKSB7XG4gIGlmIChlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICBhd2FpdCBlcnJvckhhbmRsZXIoZm9ybWF0LmVycm9yKGUpLCBlKTtcbiAgfVxufVxuIl19