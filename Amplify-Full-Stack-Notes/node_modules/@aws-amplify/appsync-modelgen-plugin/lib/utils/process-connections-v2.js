"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.processConnectionsV2 = exports.getConnectedFieldForReferences = exports.getConnectedFieldV2 = void 0;
const process_connections_1 = require("./process-connections");
const process_has_one_1 = require("./process-has-one");
const process_belongs_to_1 = require("./process-belongs-to");
const process_has_many_1 = require("./process-has-many");
const fieldUtils_1 = require("./fieldUtils");
const constants_1 = require("./constants");
function getConnectedFieldV2(field, model, connectedModel, directiveName, shouldUseModelNameFieldInHasManyAndBelongsTo = false) {
    const connectionInfo = (0, fieldUtils_1.getDirective)(field)(directiveName);
    if (!connectionInfo) {
        throw new Error(`The ${field.name} on model ${model.name} is not connected`);
    }
    if (connectionInfo.name === 'belongsTo') {
        let connectedFieldsBelongsTo = (0, process_belongs_to_1.getBelongsToConnectedFields)(model, connectedModel);
        if (connectedFieldsBelongsTo.length === 1) {
            return connectedFieldsBelongsTo[0];
        }
    }
    const indexName = connectionInfo.arguments.indexName;
    const connectionFields = connectionInfo.arguments.fields;
    if (connectionFields || directiveName === 'hasOne') {
        let connectionDirective;
        if (indexName) {
            connectionDirective = (0, process_connections_1.flattenFieldDirectives)(connectedModel).find(dir => {
                return dir.name === 'index' && dir.arguments.name === indexName;
            });
            if (!connectionDirective) {
                throw new Error(`Error processing @${connectionInfo.name} directive on ${model.name}.${field.name}, @index directive with name ${indexName} was not found in connected model ${connectedModel.name}`);
            }
        }
        else {
            connectionDirective = (0, process_connections_1.flattenFieldDirectives)(connectedModel).find(dir => {
                return dir.name === 'primaryKey';
            });
        }
        const getOtherSideBelongsToField = (type, otherSideModel) => {
            var _a;
            return (_a = otherSideModel.fields
                .filter(f => f.type === type)
                .find(f => f.directives.find(d => d.name === 'belongsTo'))) === null || _a === void 0 ? void 0 : _a.name;
        };
        let connectedFieldName = constants_1.DEFAULT_HASH_KEY_FIELD;
        if (connectionDirective) {
            connectedFieldName = ((fieldDir) => {
                return fieldDir.fieldName;
            })(connectionDirective);
        }
        else {
            const otherSideBelongsToField = getOtherSideBelongsToField(model.name, connectedModel);
            if (otherSideBelongsToField) {
                connectedFieldName = otherSideBelongsToField;
            }
        }
        const otherSideConnectedField = connectedModel.fields
            .filter(f => f.type === model.name)
            .find(f => f.directives.find(d => (d.name === 'belongsTo' || d.name === 'hasOne' || d.name === 'hasMany') &&
            d.arguments.fields &&
            d.arguments.fields[0] === connectedFieldName));
        if (otherSideConnectedField) {
            return otherSideConnectedField;
        }
        const connectedField = connectedModel.fields.find(f => f.name === connectedFieldName);
        if (!connectedField) {
            throw new Error(`Can not find key field ${connectedFieldName} in ${connectedModel.name}`);
        }
        return connectedField;
    }
    if (shouldUseModelNameFieldInHasManyAndBelongsTo) {
        const otherSideConnectedField = connectedModel.fields
            .filter(f => f.type === model.name)
            .find(f => f.directives.find(d => (d.name === 'belongsTo' || d.name === 'hasOne' || d.name === 'hasMany')));
        if (otherSideConnectedField) {
            return otherSideConnectedField;
        }
    }
    const connectedFieldName = (0, process_connections_1.makeConnectionAttributeName)(model.name, field.name);
    const connectedField = connectedModel.fields.find(f => f.name === connectedFieldName);
    return connectedField
        ? connectedField
        : {
            name: connectedFieldName,
            directives: [],
            type: 'ID',
            isList: false,
            isNullable: true,
        };
}
exports.getConnectedFieldV2 = getConnectedFieldV2;
function getConnectedFieldForReferences(field, model, connectedModel, directiveName) {
    var _a, _b;
    const connectionInfo = (0, fieldUtils_1.getDirective)(field)(directiveName);
    if (!connectionInfo) {
        throw new Error(`The ${field.name} on model ${model.name} is not connected`);
    }
    const references = connectionInfo.arguments.references;
    if (!references) {
        throw new Error(`The ${field.name} on model ${model.name} does not have references.`);
    }
    const connectionFields = connectionInfo.arguments.fields;
    if (connectionFields && references) {
        throw new Error(`'fields' and 'references' cannot be used together.`);
    }
    if (connectionInfo.name === 'belongsTo') {
        let connectedFieldsBelongsTo = (0, process_belongs_to_1.getBelongsToConnectedFields)(model, connectedModel);
        const connectedField = connectedFieldsBelongsTo.find((field) => {
            return field.directives.some((dir) => {
                return (dir.name === 'hasOne' || dir.name === 'hasMany')
                    && dir.arguments.references
                    && JSON.stringify(dir.arguments.references) === JSON.stringify(connectionInfo.arguments.references);
            });
        });
        if (!connectedField) {
            throw new Error(`Error processing @belongsTo directive on ${model.name}.${field.name}. @hasOne or @hasMany directive with references ${JSON.stringify((_a = connectionInfo.arguments) === null || _a === void 0 ? void 0 : _a.references)} was not found in connected model ${connectedModel.name}`);
        }
        return connectedField;
    }
    const connectionDirective = (0, process_connections_1.flattenFieldDirectives)(connectedModel).find((dir) => {
        return dir.arguments.references
            && JSON.stringify(dir.arguments.references) === JSON.stringify(connectionInfo.arguments.references);
    });
    if (!connectionDirective) {
        throw new Error(`Error processing @${connectionInfo.name} directive on ${model.name}.${field.name}. @belongsTo directive with references ${JSON.stringify((_b = connectionInfo.arguments) === null || _b === void 0 ? void 0 : _b.references)} was not found in connected model ${connectedModel.name}`);
    }
    const connectedFieldName = ((fieldDir) => {
        return fieldDir.fieldName;
    })(connectionDirective);
    const connectedField = connectedModel.fields.find(f => f.name === connectedFieldName);
    return connectedField;
}
exports.getConnectedFieldForReferences = getConnectedFieldForReferences;
function processConnectionsV2(field, model, modelMap, shouldUseModelNameFieldInHasManyAndBelongsTo = false, isCustomPKEnabled = false, shouldUseFieldsInAssociatedWithInHasOne = false) {
    const connectionDirective = field.directives.find(d => d.name === 'hasOne' || d.name === 'hasMany' || d.name === 'belongsTo');
    if (connectionDirective) {
        switch (connectionDirective.name) {
            case 'hasOne':
                return (0, process_has_one_1.processHasOneConnection)(field, model, modelMap, connectionDirective, isCustomPKEnabled, shouldUseFieldsInAssociatedWithInHasOne);
            case 'belongsTo':
                return (0, process_belongs_to_1.processBelongsToConnection)(field, model, modelMap, connectionDirective, isCustomPKEnabled);
            case 'hasMany':
                return (0, process_has_many_1.processHasManyConnection)(field, model, modelMap, connectionDirective, shouldUseModelNameFieldInHasManyAndBelongsTo, isCustomPKEnabled);
            default:
                break;
        }
    }
}
exports.processConnectionsV2 = processConnectionsV2;
//# sourceMappingURL=process-connections-v2.js.map