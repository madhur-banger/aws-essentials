"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getBelongsToConnectedFields = exports.processBelongsToConnection = void 0;
const fieldUtils_1 = require("./fieldUtils");
const process_connections_1 = require("./process-connections");
const process_connections_v2_1 = require("./process-connections-v2");
function processBelongsToConnection(field, model, modelMap, connectionDirective, isCustomPKEnabled = false) {
    if (field.isList) {
        throw new Error(`A list field does not support the 'belongsTo' relation`);
    }
    const otherSide = modelMap[field.type];
    const otherSideConnectedFields = getBelongsToConnectedFields(model, otherSide);
    if (otherSideConnectedFields.length === 0) {
        throw new Error(`A 'belongsTo' field should match to a corresponding 'hasMany' or 'hasOne' field`);
    }
    const references = connectionDirective.arguments.references || [];
    const isUsingReferences = references.length > 0;
    if (isUsingReferences) {
        (0, process_connections_v2_1.getConnectedFieldForReferences)(field, model, otherSide, connectionDirective.name);
    }
    const otherSideField = isCustomPKEnabled ? otherSideConnectedFields[0] : (0, process_connections_v2_1.getConnectedFieldV2)(field, model, otherSide, connectionDirective.name);
    const connectionFields = connectionDirective.arguments.fields || [];
    const otherSideHasMany = otherSideField.isList;
    let targetNames = [...connectionFields, ...references];
    if (targetNames.length === 0) {
        if (otherSideHasMany) {
            targetNames = isCustomPKEnabled
                ? (0, fieldUtils_1.getModelPrimaryKeyComponentFields)(otherSide).map(componentField => (0, process_connections_1.makeConnectionAttributeName)(otherSide.name, otherSideField.name, componentField.name))
                : [(0, process_connections_1.makeConnectionAttributeName)(otherSide.name, otherSideField.name)];
        }
        else {
            targetNames = isCustomPKEnabled
                ? (0, fieldUtils_1.getModelPrimaryKeyComponentFields)(otherSide).map(componentField => (0, process_connections_1.makeConnectionAttributeName)(model.name, field.name, componentField.name))
                : [(0, process_connections_1.makeConnectionAttributeName)(model.name, field.name)];
        }
    }
    return {
        kind: process_connections_1.CodeGenConnectionType.BELONGS_TO,
        connectedModel: otherSide,
        isConnectingFieldAutoCreated: false,
        targetName: targetNames[0],
        targetNames,
        isUsingReferences,
    };
}
exports.processBelongsToConnection = processBelongsToConnection;
function getBelongsToConnectedFields(model, connectedModel) {
    const otherSideDirectives = (0, process_connections_1.flattenFieldDirectives)(connectedModel).filter(dir => {
        const connectedField = connectedModel.fields.find(connField => { return connField.name === dir.fieldName; });
        const fieldType = connectedField === null || connectedField === void 0 ? void 0 : connectedField.type;
        return ((dir.name === 'hasOne' && !(connectedField === null || connectedField === void 0 ? void 0 : connectedField.isList)) || (dir.name === 'hasMany' && (connectedField === null || connectedField === void 0 ? void 0 : connectedField.isList))) && model.name === fieldType;
    });
    return otherSideDirectives.map(dir => {
        return connectedModel.fields.find(connField => connField.name === dir.fieldName);
    });
}
exports.getBelongsToConnectedFields = getBelongsToConnectedFields;
//# sourceMappingURL=process-belongs-to.js.map