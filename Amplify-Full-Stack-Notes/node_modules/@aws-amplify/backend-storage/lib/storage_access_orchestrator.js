import { entityIdPathToken, entityIdSubstitution } from './constants.js';
import { validateStorageAccessPaths as _validateStorageAccessPaths } from './validate_storage_access_paths.js';
import { roleAccessBuilder as _roleAccessBuilder } from './access_builder.js';
import { AmplifyUserError } from '@aws-amplify/platform-core';
/**
 * Orchestrates the process of converting customer-defined storage access rules into corresponding IAM policies
 * and attaching those policies to the corresponding IAM roles
 */
export class StorageAccessOrchestrator {
    storageAccessGenerator;
    getInstanceProps;
    ssmEnvironmentEntries;
    policyFactory;
    validateStorageAccessPaths;
    roleAccessBuilder;
    /**
     * Maintains a mapping from a resource access acceptor to all of the access grants it has been configured with
     * Each entry of this map is fed into the policy generator to create a single policy for each acceptor
     */
    acceptorAccessMap = new Map();
    /**
     * Maintains pointers to the "deny" StoragePath Set for each access entry in the map above
     * This map is used during a final pass over all the StoragePaths to deny access on any paths where explicit allow rules were not specified
     */
    prefixDenyMap = new Map();
    /**
     * Instantiate with the access generator and other dependencies necessary for evaluating and constructing access policies
     * @param storageAccessGenerator The access callback defined by the customer
     * @param getInstanceProps props for fetching construct instances from the construct container
     * @param ssmEnvironmentEntries SSM context that should be passed to the ResourceAccessAcceptors when configuring access
     * @param policyFactory factory that generates IAM policies for various access control definitions
     * @param validateStorageAccessPaths validator function for checking access definition paths
     * @param roleAccessBuilder builder instance that is injected into the storageAccessGenerator to evaluate the rules
     */
    constructor(storageAccessGenerator, getInstanceProps, ssmEnvironmentEntries, policyFactory, validateStorageAccessPaths = _validateStorageAccessPaths, roleAccessBuilder = _roleAccessBuilder) {
        this.storageAccessGenerator = storageAccessGenerator;
        this.getInstanceProps = getInstanceProps;
        this.ssmEnvironmentEntries = ssmEnvironmentEntries;
        this.policyFactory = policyFactory;
        this.validateStorageAccessPaths = validateStorageAccessPaths;
        this.roleAccessBuilder = roleAccessBuilder;
    }
    /**
     * Orchestrates the process of translating the customer-provided storage access rules into IAM policies and attaching those policies to the appropriate roles.
     *
     * The high level steps are:
     * 1. Invokes the storageAccessGenerator to produce a storageAccessDefinition
     * 2. Validates the paths in the storageAccessDefinition
     * 3. Organizes the storageAccessDefinition into internally managed maps to facilitate translation into allow / deny rules on IAM policies
     * 4. Invokes the policy generator to produce a policy with appropriate allow / deny rules
     * 5. Invokes the resourceAccessAcceptors for each entry in the storageAccessDefinition to accept the corresponding IAM policy
     */
    orchestrateStorageAccess = () => {
        // storageAccessGenerator is the access callback defined by the customer
        // here we inject the roleAccessBuilder into the callback and run it
        // this produces the access definition that will be used to create the storage policies
        const storageAccessDefinition = this.storageAccessGenerator(this.roleAccessBuilder);
        // verify that the paths in the access definition are valid
        this.validateStorageAccessPaths(Object.keys(storageAccessDefinition));
        const storageOutputAccessDefinition = {};
        // iterate over the access definition and group permissions by ResourceAccessAcceptor
        Object.entries(storageAccessDefinition).forEach(([s3Prefix, accessPermissions]) => {
            const uniqueDefinitionIdSet = new Set();
            // iterate over all of the access definitions for a given prefix
            accessPermissions.forEach((permission) => {
                const accessConfig = {};
                // replace "read" with "get" and "list" in actions
                const replaceReadWithGetAndList = permission.actions.flatMap((action) => (action === 'read' ? ['get', 'list'] : [action]));
                // ensure the actions list has no duplicates
                const noDuplicateActions = Array.from(new Set(replaceReadWithGetAndList));
                // iterate over all uniqueDefinitionIdValidations and ensure uniqueness within this path prefix
                permission.uniqueDefinitionIdValidations.forEach(({ uniqueDefinitionId, validationErrorOptions }) => {
                    if (uniqueDefinitionIdSet.has(uniqueDefinitionId)) {
                        throw new AmplifyUserError('InvalidStorageAccessDefinitionError', validationErrorOptions);
                    }
                    else {
                        uniqueDefinitionIdSet.add(uniqueDefinitionId);
                    }
                    accessConfig[uniqueDefinitionId] = noDuplicateActions;
                });
                // make the owner placeholder substitution in the s3 prefix
                const prefix = placeholderSubstitution(s3Prefix, permission.idSubstitution);
                storageOutputAccessDefinition[prefix] = {
                    ...storageOutputAccessDefinition[prefix],
                    ...accessConfig,
                };
                // set an entry that maps this permission to each resource acceptor
                permission.getResourceAccessAcceptors.forEach((getResourceAccessAcceptor) => {
                    this.addAccessDefinition(getResourceAccessAcceptor(this.getInstanceProps), noDuplicateActions, prefix);
                });
            });
        });
        // iterate over the access map entries and invoke each ResourceAccessAcceptor to accept the permissions
        this.attachPolicies(this.ssmEnvironmentEntries);
        return storageOutputAccessDefinition;
    };
    /**
     * Add an entry to the internal acceptorAccessMap and prefixDenyMap.
     * This entry defines a set of actions on a single s3 prefix that should be attached to a given ResourceAccessAcceptor
     */
    addAccessDefinition = (resourceAccessAcceptor, actions, s3Prefix) => {
        const acceptorToken = resourceAccessAcceptor.identifier;
        // if we haven't seen this token before, add it to the map
        if (!this.acceptorAccessMap.has(acceptorToken)) {
            this.acceptorAccessMap.set(acceptorToken, {
                accessMap: new Map(),
                acceptor: resourceAccessAcceptor,
            });
        }
        const accessMap = this.acceptorAccessMap.get(acceptorToken).accessMap;
        // add each action to the accessMap for this acceptorToken
        actions.forEach((action) => {
            if (!accessMap.has(action)) {
                // if we haven't seen this action for this acceptorToken before, add it to the map
                const allowSet = new Set([s3Prefix]);
                const denySet = new Set();
                accessMap.set(action, { allow: allowSet, deny: denySet });
                // this is where we create the reverse mapping that allows us to add entries to the denySet later by looking up the prefix
                this.setPrefixDenyMapEntry(s3Prefix, allowSet, denySet);
            }
            else {
                // otherwise add the prefix to the existing allow set
                const { allow: allowSet, deny: denySet } = accessMap.get(action);
                allowSet.add(s3Prefix);
                // add an entry in the prefixDenyMap for the existing allow and deny set
                this.setPrefixDenyMapEntry(s3Prefix, allowSet, denySet);
            }
        });
    };
    /**
     * Iterates over all of the access definitions that have been added to the orchestrator,
     * generates a policy for each accessMap,
     * and attaches the policy to the corresponding ResourceAccessAcceptor
     *
     * After this method is called, the existing access definition state is cleared.
     * This prevents multiple calls to this method from producing duplicate policies.
     * The class can continue to be used to build up state for a new set of policies if desired.
     * @param ssmEnvironmentEntries Additional SSM context that is passed to each ResourceAccessAcceptor
     */
    attachPolicies = (ssmEnvironmentEntries) => {
        const allPaths = Array.from(this.prefixDenyMap.keys());
        allPaths.forEach((storagePath) => {
            const parent = findParent(storagePath, allPaths);
            // do not add to prefix deny map if there is no parent or the path is a subpath with entity id
            if (!parent ||
                parent === storagePath.replaceAll(`${entityIdSubstitution}/`, '')) {
                return;
            }
            // if a parent path is defined, invoke the denyByDefault callback on this subpath for all policies that exist on the parent path
            this.prefixDenyMap
                .get(parent)
                ?.forEach((denyByDefaultCallback) => denyByDefaultCallback(storagePath));
        });
        this.acceptorAccessMap.forEach(({ acceptor, accessMap }) => {
            // removing subpaths from the allow set prevents unnecessary paths from being added to the policy
            // for example, if there are allow read rules for /foo/* and /foo/bar/* we only need to add /foo/* to the policy because that includes /foo/bar/*
            accessMap.forEach(({ allow }) => {
                removeSubPathsFromSet(allow);
            });
            acceptor.acceptResourceAccess(this.policyFactory.createPolicy(accessMap), ssmEnvironmentEntries);
        });
        this.acceptorAccessMap.clear();
        this.prefixDenyMap.clear();
    };
    setPrefixDenyMapEntry = (storagePath, allowPathSet, denyPathSet) => {
        // function that will add the denyPath to the denyPathSet unless the allowPathSet explicitly allows the path
        const setDenyByDefault = (denyPath) => {
            if (!allowPathSet.has(denyPath)) {
                denyPathSet.add(denyPath);
            }
        };
        if (!this.prefixDenyMap.has(storagePath)) {
            this.prefixDenyMap.set(storagePath, [setDenyByDefault]);
        }
        else {
            this.prefixDenyMap.get(storagePath)?.push(setDenyByDefault);
        }
    };
}
/**
 * This factory is really only necessary for allowing us to mock the StorageAccessOrchestrator in tests
 */
export class StorageAccessOrchestratorFactory {
    getInstance = (storageAccessGenerator, getInstanceProps, ssmEnvironmentEntries, policyFactory) => new StorageAccessOrchestrator(storageAccessGenerator, getInstanceProps, ssmEnvironmentEntries, policyFactory);
}
/**
 * Performs the owner placeholder substitution in the s3 prefix
 */
const placeholderSubstitution = (s3Prefix, idSubstitution) => {
    const prefix = s3Prefix.replaceAll(entityIdPathToken, idSubstitution);
    // for owner paths where prefix ends with '/*/*' remove the last wildcard
    if (prefix.endsWith('/*/*')) {
        return prefix.slice(0, -2);
    }
    return prefix;
};
/**
 * Returns the element in paths that is a prefix of path, if any
 * Note that there can only be one at this point because of upstream validation
 */
const findParent = (path, paths) => paths.find((p) => path !== p && path.startsWith(p.replaceAll('*', '')));
const removeSubPathsFromSet = (paths) => {
    paths.forEach((path) => {
        if (findParent(path, Array.from(paths))) {
            paths.delete(path);
        }
    });
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RvcmFnZV9hY2Nlc3Nfb3JjaGVzdHJhdG9yLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL3N0b3JhZ2VfYWNjZXNzX29yY2hlc3RyYXRvci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFVQSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUV6RSxPQUFPLEVBQUUsMEJBQTBCLElBQUksMkJBQTJCLEVBQUUsTUFBTSxvQ0FBb0MsQ0FBQztBQUMvRyxPQUFPLEVBQUUsaUJBQWlCLElBQUksa0JBQWtCLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQU05RSxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQVU5RDs7O0dBR0c7QUFDSCxNQUFNLE9BQU8seUJBQXlCO0lBZ0NqQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFwQ25COzs7T0FHRztJQUNLLGlCQUFpQixHQUFHLElBQUksR0FBRyxFQVNoQyxDQUFDO0lBRUo7OztPQUdHO0lBQ0ssYUFBYSxHQUFHLElBQUksR0FBRyxFQUFtQyxDQUFDO0lBRW5FOzs7Ozs7OztPQVFHO0lBQ0gsWUFDbUIsc0JBQThDLEVBQzlDLGdCQUFrRCxFQUNsRCxxQkFBNEMsRUFDNUMsYUFBeUMsRUFDekMsNkJBQTZCLDJCQUEyQixFQUN4RCxvQkFBMEMsa0JBQWtCO1FBTDVELDJCQUFzQixHQUF0QixzQkFBc0IsQ0FBd0I7UUFDOUMscUJBQWdCLEdBQWhCLGdCQUFnQixDQUFrQztRQUNsRCwwQkFBcUIsR0FBckIscUJBQXFCLENBQXVCO1FBQzVDLGtCQUFhLEdBQWIsYUFBYSxDQUE0QjtRQUN6QywrQkFBMEIsR0FBMUIsMEJBQTBCLENBQThCO1FBQ3hELHNCQUFpQixHQUFqQixpQkFBaUIsQ0FBMkM7SUFDNUUsQ0FBQztJQUVKOzs7Ozs7Ozs7T0FTRztJQUNILHdCQUF3QixHQUFHLEdBQUcsRUFBRTtRQUM5Qix3RUFBd0U7UUFD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QyxFQUFFO1FBQzNCLE9BQU8sTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQWdCLENBQUM7S0FDM0M7SUFFRCxPQUFPLE1BQXFCLENBQUM7QUFDL0IsQ0FBQyxDQUFDO0FBRUY7OztHQUdHO0FBQ0gsTUFBTSxVQUFVLEdBQUcsQ0FBQyxJQUFZLEVBQUUsS0FBZSxFQUFFLEVBQUUsQ0FDbkQsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsSUFBSSxLQUFLLENBQUMsSUFBSSxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBRXpELENBQUM7QUFFaEIsTUFBTSxxQkFBcUIsR0FBRyxDQUFDLEtBQXVCLEVBQUUsRUFBRTtJQUN4RCxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUU7UUFDckIsSUFBSSxVQUFVLENBQUMsSUFBSSxFQUFFLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTtZQUN2QyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO1NBQ3BCO0lBQ0gsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBDb25zdHJ1Y3RGYWN0b3J5R2V0SW5zdGFuY2VQcm9wcyxcbiAgUmVzb3VyY2VBY2Nlc3NBY2NlcHRvcixcbiAgU3NtRW52aXJvbm1lbnRFbnRyeSxcbn0gZnJvbSAnQGF3cy1hbXBsaWZ5L3BsdWdpbi10eXBlcyc7XG5pbXBvcnQge1xuICBTdG9yYWdlQWNjZXNzQnVpbGRlcixcbiAgU3RvcmFnZUFjY2Vzc0dlbmVyYXRvcixcbiAgU3RvcmFnZVBhdGgsXG59IGZyb20gJy4vdHlwZXMuanMnO1xuaW1wb3J0IHsgZW50aXR5SWRQYXRoVG9rZW4sIGVudGl0eUlkU3Vic3RpdHV0aW9uIH0gZnJvbSAnLi9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgU3RvcmFnZUFjY2Vzc1BvbGljeUZhY3RvcnkgfSBmcm9tICcuL3N0b3JhZ2VfYWNjZXNzX3BvbGljeV9mYWN0b3J5LmpzJztcbmltcG9ydCB7IHZhbGlkYXRlU3RvcmFnZUFjY2Vzc1BhdGhzIGFzIF92YWxpZGF0ZVN0b3JhZ2VBY2Nlc3NQYXRocyB9IGZyb20gJy4vdmFsaWRhdGVfc3RvcmFnZV9hY2Nlc3NfcGF0aHMuanMnO1xuaW1wb3J0IHsgcm9sZUFjY2Vzc0J1aWxkZXIgYXMgX3JvbGVBY2Nlc3NCdWlsZGVyIH0gZnJvbSAnLi9hY2Nlc3NfYnVpbGRlci5qcyc7XG5pbXBvcnQge1xuICBJbnRlcm5hbFN0b3JhZ2VBY3Rpb24sXG4gIFN0b3JhZ2VBY2Nlc3NDb25maWcsXG4gIFN0b3JhZ2VFcnJvcixcbn0gZnJvbSAnLi9wcml2YXRlX3R5cGVzLmpzJztcbmltcG9ydCB7IEFtcGxpZnlVc2VyRXJyb3IgfSBmcm9tICdAYXdzLWFtcGxpZnkvcGxhdGZvcm0tY29yZSc7XG5cbi8qIHNvbWUgdHlwZXMgaW50ZXJuYWwgdG8gdGhpcyBmaWxlIHRvIGltcHJvdmUgcmVhZGFiaWxpdHkgKi9cblxuLy8gQWxpYXMgdHlwZSBmb3IgYSBzdHJpbmcgdGhhdCBpcyBhIFJlc291cmNlQWNjZXNzQWNjZXB0b3IgdG9rZW5cbnR5cGUgQWNjZXB0b3JUb2tlbiA9IHN0cmluZztcblxuLy8gQ2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBwbGFjZXMgc3RvcmFnZVBhdGggaW4gdGhlIGRlbnkgbGlzdCBmb3IgYW4gYWN0aW9uIGlmIGl0IGlzIG5vdCBleHBsaWNpdGx5IGFsbG93ZWQgYnkgYW5vdGhlciBydWxlXG50eXBlIFNldERlbnlCeURlZmF1bHQgPSAoc3RvcmFnZVBhdGg6IFN0b3JhZ2VQYXRoKSA9PiB2b2lkO1xuXG4vKipcbiAqIE9yY2hlc3RyYXRlcyB0aGUgcHJvY2VzcyBvZiBjb252ZXJ0aW5nIGN1c3RvbWVyLWRlZmluZWQgc3RvcmFnZSBhY2Nlc3MgcnVsZXMgaW50byBjb3JyZXNwb25kaW5nIElBTSBwb2xpY2llc1xuICogYW5kIGF0dGFjaGluZyB0aG9zZSBwb2xpY2llcyB0byB0aGUgY29ycmVzcG9uZGluZyBJQU0gcm9sZXNcbiAqL1xuZXhwb3J0IGNsYXNzIFN0b3JhZ2VBY2Nlc3NPcmNoZXN0cmF0b3Ige1xuICAvKipcbiAgICogTWFpbnRhaW5zIGEgbWFwcGluZyBmcm9tIGEgcmVzb3VyY2UgYWNjZXNzIGFjY2VwdG9yIHRvIGFsbCBvZiB0aGUgYWNjZXNzIGdyYW50cyBpdCBoYXMgYmVlbiBjb25maWd1cmVkIHdpdGhcbiAgICogRWFjaCBlbnRyeSBvZiB0aGlzIG1hcCBpcyBmZWQgaW50byB0aGUgcG9saWN5IGdlbmVyYXRvciB0byBjcmVhdGUgYSBzaW5nbGUgcG9saWN5IGZvciBlYWNoIGFjY2VwdG9yXG4gICAqL1xuICBwcml2YXRlIGFjY2VwdG9yQWNjZXNzTWFwID0gbmV3IE1hcDxcbiAgICBBY2NlcHRvclRva2VuLFxuICAgIHtcbiAgICAgIGFjY2VwdG9yOiBSZXNvdXJjZUFjY2Vzc0FjY2VwdG9yO1xuICAgICAgYWNjZXNzTWFwOiBNYXA8XG4gICAgICAgIEludGVybmFsU3RvcmFnZUFjdGlvbixcbiAgICAgICAgeyBhbGxvdzogU2V0PFN0b3JhZ2VQYXRoPjsgZGVueTogU2V0PFN0b3JhZ2VQYXRoPiB9XG4gICAgICA+O1xuICAgIH1cbiAgPigpO1xuXG4gIC8qKlxuICAgKiBNYWludGFpbnMgcG9pbnRlcnMgdG8gdGhlIFwiZGVueVwiIFN0b3JhZ2VQYXRoIFNldCBmb3IgZWFjaCBhY2Nlc3MgZW50cnkgaW4gdGhlIG1hcCBhYm92ZVxuICAgKiBUaGlzIG1hcCBpcyB1c2VkIGR1cmluZyBhIGZpbmFsIHBhc3Mgb3ZlciBhbGwgdGhlIFN0b3JhZ2VQYXRocyB0byBkZW55IGFjY2VzcyBvbiBhbnkgcGF0aHMgd2hlcmUgZXhwbGljaXQgYWxsb3cgcnVsZXMgd2VyZSBub3Qgc3BlY2lmaWVkXG4gICAqL1xuICBwcml2YXRlIHByZWZpeERlbnlNYXAgPSBuZXcgTWFwPFN0b3JhZ2VQYXRoLCBTZXREZW55QnlEZWZhdWx0W10+KCk7XG5cbiAgLyoqXG4gICAqIEluc3RhbnRpYXRlIHdpdGggdGhlIGFjY2VzcyBnZW5lcmF0b3IgYW5kIG90aGVyIGRlcGVuZGVuY2llcyBuZWNlc3NhcnkgZm9yIGV2YWx1YXRpbmcgYW5kIGNvbnN0cnVjdGluZyBhY2Nlc3MgcG9saWNpZXNcbiAgICogQHBhcmFtIHN0b3JhZ2VBY2Nlc3NHZW5lcmF0b3IgVGhlIGFjY2VzcyBjYWxsYmFjayBkZWZpbmVkIGJ5IHRoZSBjdXN0b21lclxuICAgKiBAcGFyYW0gZ2V0SW5zdGFuY2VQcm9wcyBwcm9wcyBmb3IgZmV0Y2hpbmcgY29uc3RydWN0IGluc3RhbmNlcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY29udGFpbmVyXG4gICAqIEBwYXJhbSBzc21FbnZpcm9ubWVudEVudHJpZXMgU1NNIGNvbnRleHQgdGhhdCBzaG91bGQgYmUgcGFzc2VkIHRvIHRoZSBSZXNvdXJjZUFjY2Vzc0FjY2VwdG9ycyB3aGVuIGNvbmZpZ3VyaW5nIGFjY2Vzc1xuICAgKiBAcGFyYW0gcG9saWN5RmFjdG9yeSBmYWN0b3J5IHRoYXQgZ2VuZXJhdGVzIElBTSBwb2xpY2llcyBmb3IgdmFyaW91cyBhY2Nlc3MgY29udHJvbCBkZWZpbml0aW9uc1xuICAgKiBAcGFyYW0gdmFsaWRhdGVTdG9yYWdlQWNjZXNzUGF0aHMgdmFsaWRhdG9yIGZ1bmN0aW9uIGZvciBjaGVja2luZyBhY2Nlc3MgZGVmaW5pdGlvbiBwYXRoc1xuICAgKiBAcGFyYW0gcm9sZUFjY2Vzc0J1aWxkZXIgYnVpbGRlciBpbnN0YW5jZSB0aGF0IGlzIGluamVjdGVkIGludG8gdGhlIHN0b3JhZ2VBY2Nlc3NHZW5lcmF0b3IgdG8gZXZhbHVhdGUgdGhlIHJ1bGVzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IHN0b3JhZ2VBY2Nlc3NHZW5lcmF0b3I6IFN0b3JhZ2VBY2Nlc3NHZW5lcmF0b3IsXG4gICAgcHJpdmF0ZSByZWFkb25seSBnZXRJbnN0YW5jZVByb3BzOiBDb25zdHJ1Y3RGYWN0b3J5R2V0SW5zdGFuY2VQcm9wcyxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHNzbUVudmlyb25tZW50RW50cmllczogU3NtRW52aXJvbm1lbnRFbnRyeVtdLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgcG9saWN5RmFjdG9yeTogU3RvcmFnZUFjY2Vzc1BvbGljeUZhY3RvcnksXG4gICAgcHJpdmF0ZSByZWFkb25seSB2YWxpZGF0ZVN0b3JhZ2VBY2Nlc3NQYXRocyA9IF92YWxpZGF0ZVN0b3JhZ2VBY2Nlc3NQYXRocyxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHJvbGVBY2Nlc3NCdWlsZGVyOiBTdG9yYWdlQWNjZXNzQnVpbGRlciA9IF9yb2xlQWNjZXNzQnVpbGRlclxuICApIHt9XG5cbiAgLyoqXG4gICAqIE9yY2hlc3RyYXRlcyB0aGUgcHJvY2VzcyBvZiB0cmFuc2xhdGluZyB0aGUgY3VzdG9tZXItcHJvdmlkZWQgc3RvcmFnZSBhY2Nlc3MgcnVsZXMgaW50byBJQU0gcG9saWNpZXMgYW5kIGF0dGFjaGluZyB0aG9zZSBwb2xpY2llcyB0byB0aGUgYXBwcm9wcmlhdGUgcm9sZXMuXG4gICAqXG4gICAqIFRoZSBoaWdoIGxldmVsIHN0ZXBzIGFyZTpcbiAgICogMS4gSW52b2tlcyB0aGUgc3RvcmFnZUFjY2Vzc0dlbmVyYXRvciB0byBwcm9kdWNlIGEgc3RvcmFnZUFjY2Vzc0RlZmluaXRpb25cbiAgICogMi4gVmFsaWRhdGVzIHRoZSBwYXRocyBpbiB0aGUgc3RvcmFnZUFjY2Vzc0RlZmluaXRpb25cbiAgICogMy4gT3JnYW5pemVzIHRoZSBzdG9yYWdlQWNjZXNzRGVmaW5pdGlvbiBpbnRvIGludGVybmFsbHkgbWFuYWdlZCBtYXBzIHRvIGZhY2lsaXRhdGUgdHJhbnNsYXRpb24gaW50byBhbGxvdyAvIGRlbnkgcnVsZXMgb24gSUFNIHBvbGljaWVzXG4gICAqIDQuIEludm9rZXMgdGhlIHBvbGljeSBnZW5lcmF0b3IgdG8gcHJvZHVjZSBhIHBvbGljeSB3aXRoIGFwcHJvcHJpYXRlIGFsbG93IC8gZGVueSBydWxlc1xuICAgKiA1LiBJbnZva2VzIHRoZSByZXNvdXJjZUFjY2Vzc0FjY2VwdG9ycyBmb3IgZWFjaCBlbnRyeSBpbiB0aGUgc3RvcmFnZUFjY2Vzc0RlZmluaXRpb24gdG8gYWNjZXB0IHRoZSBjb3JyZXNwb25kaW5nIElBTSBwb2xpY3lcbiAgICovXG4gIG9yY2hlc3RyYXRlU3RvcmFnZUFjY2VzcyA9ICgpID0+IHtcbiAgICAvLyBzdG9yYWdlQWNjZXNzR2VuZXJhdG9yIGlzIHRoZSBhY2Nlc3MgY2FsbGJhY2sgZGVmaW5lZCBieSB0aGUgY3VzdG9tZXJcbiAgICAvLyBoZXJlIHdlIGluamVjdCB0aGUgcm9sZUFjY2Vzc0J1aWxkZXIgaW50byB0aGUgY2FsbGJhY2sgYW5kIHJ1biBpdFxuICAgIC8vIHRoaXMgcHJvZHVjZXMgdGhlIGFjY2VzcyBkZWZpbml0aW9uIHRoYXQgd2lsbCBiZSB1c2VkIHRvIGNyZWF0ZSB0aGUgc3RvcmFnZSBwb2xpY2llc1xuICAgIGNvbnN0IHN0b3JhZ2VBY2Nlc3NEZWZpbml0aW9uID0gdGhpcy5zdG9yYWdlQWNjZXNzR2VuZXJhdG9yKFxuICAgICAgdGhpcy5yb2xlQWNjZXNzQnVpbGRlclxuICAgICk7XG5cbiAgICAvLyB2ZXJpZnkgdGhhdCB0aGUgcGF0aHMgaW4gdGhlIGFjY2VzcyBkZWZpbml0aW9uIGFyZSB2YWxpZFxuICAgIHRoaXMudmFsaWRhdGVTdG9yYWdlQWNjZXNzUGF0aHMoT2JqZWN0LmtleXMoc3RvcmFnZUFjY2Vzc0RlZmluaXRpb24pKTtcblxuICAgIGNvbnN0IHN0b3JhZ2VPdXRwdXRBY2Nlc3NEZWZpbml0aW9uOiBSZWNvcmQ8c3RyaW5nLCBTdG9yYWdlQWNjZXNzQ29uZmlnPiA9XG4gICAgICB7fTtcblxuICAgIC8vIGl0ZXJhdGUgb3ZlciB0aGUgYWNjZXNzIGRlZmluaXRpb24gYW5kIGdyb3VwIHBlcm1pc3Npb25zIGJ5IFJlc291cmNlQWNjZXNzQWNjZXB0b3JcbiAgICBPYmplY3QuZW50cmllcyhzdG9yYWdlQWNjZXNzRGVmaW5pdGlvbikuZm9yRWFjaChcbiAgICAgIChbczNQcmVmaXgsIGFjY2Vzc1Blcm1pc3Npb25zXSkgPT4ge1xuICAgICAgICBjb25zdCB1bmlxdWVEZWZpbml0aW9uSWRTZXQgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICAgICAgLy8gaXRlcmF0ZSBvdmVyIGFsbCBvZiB0aGUgYWNjZXNzIGRlZmluaXRpb25zIGZvciBhIGdpdmVuIHByZWZpeFxuICAgICAgICBhY2Nlc3NQZXJtaXNzaW9ucy5mb3JFYWNoKChwZXJtaXNzaW9uKSA9PiB7XG4gICAgICAgICAgY29uc3QgYWNjZXNzQ29uZmlnOiBTdG9yYWdlQWNjZXNzQ29uZmlnID0ge307XG4gICAgICAgICAgLy8gcmVwbGFjZSBcInJlYWRcIiB3aXRoIFwiZ2V0XCIgYW5kIFwibGlzdFwiIGluIGFjdGlvbnNcbiAgICAgICAgICBjb25zdCByZXBsYWNlUmVhZFdpdGhHZXRBbmRMaXN0ID0gcGVybWlzc2lvbi5hY3Rpb25zLmZsYXRNYXAoXG4gICAgICAgICAgICAoYWN0aW9uKSA9PiAoYWN0aW9uID09PSAncmVhZCcgPyBbJ2dldCcsICdsaXN0J10gOiBbYWN0aW9uXSlcbiAgICAgICAgICApIGFzIEludGVybmFsU3RvcmFnZUFjdGlvbltdO1xuXG4gICAgICAgICAgLy8gZW5zdXJlIHRoZSBhY3Rpb25zIGxpc3QgaGFzIG5vIGR1cGxpY2F0ZXNcbiAgICAgICAgICBjb25zdCBub0R1cGxpY2F0ZUFjdGlvbnMgPSBBcnJheS5mcm9tKFxuICAgICAgICAgICAgbmV3IFNldChyZXBsYWNlUmVhZFdpdGhHZXRBbmRMaXN0KVxuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvLyBpdGVyYXRlIG92ZXIgYWxsIHVuaXF1ZURlZmluaXRpb25JZFZhbGlkYXRpb25zIGFuZCBlbnN1cmUgdW5pcXVlbmVzcyB3aXRoaW4gdGhpcyBwYXRoIHByZWZpeFxuICAgICAgICAgIHBlcm1pc3Npb24udW5pcXVlRGVmaW5pdGlvbklkVmFsaWRhdGlvbnMuZm9yRWFjaChcbiAgICAgICAgICAgICh7IHVuaXF1ZURlZmluaXRpb25JZCwgdmFsaWRhdGlvbkVycm9yT3B0aW9ucyB9KSA9PiB7XG4gICAgICAgICAgICAgIGlmICh1bmlxdWVEZWZpbml0aW9uSWRTZXQuaGFzKHVuaXF1ZURlZmluaXRpb25JZCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQW1wbGlmeVVzZXJFcnJvcjxTdG9yYWdlRXJyb3I+KFxuICAgICAgICAgICAgICAgICAgJ0ludmFsaWRTdG9yYWdlQWNjZXNzRGVmaW5pdGlvbkVycm9yJyxcbiAgICAgICAgICAgICAgICAgIHZhbGlkYXRpb25FcnJvck9wdGlvbnNcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVuaXF1ZURlZmluaXRpb25JZFNldC5hZGQodW5pcXVlRGVmaW5pdGlvbklkKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGFjY2Vzc0NvbmZpZ1t1bmlxdWVEZWZpbml0aW9uSWRdID0gbm9EdXBsaWNhdGVBY3Rpb25zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgICAgLy8gbWFrZSB0aGUgb3duZXIgcGxhY2Vob2xkZXIgc3Vic3RpdHV0aW9uIGluIHRoZSBzMyBwcmVmaXhcbiAgICAgICAgICBjb25zdCBwcmVmaXggPSBwbGFjZWhvbGRlclN1YnN0aXR1dGlvbihcbiAgICAgICAgICAgIHMzUHJlZml4LFxuICAgICAgICAgICAgcGVybWlzc2lvbi5pZFN1YnN0aXR1dGlvblxuICAgICAgICAgICk7XG5cbiAgICAgICAgICBzdG9yYWdlT3V0cHV0QWNjZXNzRGVmaW5pdGlvbltwcmVmaXhdID0ge1xuICAgICAgICAgICAgLi4uc3RvcmFnZU91dHB1dEFjY2Vzc0RlZmluaXRpb25bcHJlZml4XSxcbiAgICAgICAgICAgIC4uLmFjY2Vzc0NvbmZpZyxcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgLy8gc2V0IGFuIGVudHJ5IHRoYXQgbWFwcyB0aGlzIHBlcm1pc3Npb24gdG8gZWFjaCByZXNvdXJjZSBhY2NlcHRvclxuICAgICAgICAgIHBlcm1pc3Npb24uZ2V0UmVzb3VyY2VBY2Nlc3NBY2NlcHRvcnMuZm9yRWFjaChcbiAgICAgICAgICAgIChnZXRSZXNvdXJjZUFjY2Vzc0FjY2VwdG9yKSA9PiB7XG4gICAgICAgICAgICAgIHRoaXMuYWRkQWNjZXNzRGVmaW5pdGlvbihcbiAgICAgICAgICAgICAgICBnZXRSZXNvdXJjZUFjY2Vzc0FjY2VwdG9yKHRoaXMuZ2V0SW5zdGFuY2VQcm9wcyksXG4gICAgICAgICAgICAgICAgbm9EdXBsaWNhdGVBY3Rpb25zLFxuICAgICAgICAgICAgICAgIHByZWZpeFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICk7XG5cbiAgICAvLyBpdGVyYXRlIG92ZXIgdGhlIGFjY2VzcyBtYXAgZW50cmllcyBhbmQgaW52b2tlIGVhY2ggUmVzb3VyY2VBY2Nlc3NBY2NlcHRvciB0byBhY2NlcHQgdGhlIHBlcm1pc3Npb25zXG4gICAgdGhpcy5hdHRhY2hQb2xpY2llcyh0aGlzLnNzbUVudmlyb25tZW50RW50cmllcyk7XG5cbiAgICByZXR1cm4gc3RvcmFnZU91dHB1dEFjY2Vzc0RlZmluaXRpb247XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZCBhbiBlbnRyeSB0byB0aGUgaW50ZXJuYWwgYWNjZXB0b3JBY2Nlc3NNYXAgYW5kIHByZWZpeERlbnlNYXAuXG4gICAqIFRoaXMgZW50cnkgZGVmaW5lcyBhIHNldCBvZiBhY3Rpb25zIG9uIGEgc2luZ2xlIHMzIHByZWZpeCB0aGF0IHNob3VsZCBiZSBhdHRhY2hlZCB0byBhIGdpdmVuIFJlc291cmNlQWNjZXNzQWNjZXB0b3JcbiAgICovXG4gIHByaXZhdGUgYWRkQWNjZXNzRGVmaW5pdGlvbiA9IChcbiAgICByZXNvdXJjZUFjY2Vzc0FjY2VwdG9yOiBSZXNvdXJjZUFjY2Vzc0FjY2VwdG9yLFxuICAgIGFjdGlvbnM6IEludGVybmFsU3RvcmFnZUFjdGlvbltdLFxuICAgIHMzUHJlZml4OiBTdG9yYWdlUGF0aFxuICApID0+IHtcbiAgICBjb25zdCBhY2NlcHRvclRva2VuID0gcmVzb3VyY2VBY2Nlc3NBY2NlcHRvci5pZGVudGlmaWVyO1xuXG4gICAgLy8gaWYgd2UgaGF2ZW4ndCBzZWVuIHRoaXMgdG9rZW4gYmVmb3JlLCBhZGQgaXQgdG8gdGhlIG1hcFxuICAgIGlmICghdGhpcy5hY2NlcHRvckFjY2Vzc01hcC5oYXMoYWNjZXB0b3JUb2tlbikpIHtcbiAgICAgIHRoaXMuYWNjZXB0b3JBY2Nlc3NNYXAuc2V0KGFjY2VwdG9yVG9rZW4sIHtcbiAgICAgICAgYWNjZXNzTWFwOiBuZXcgTWFwKCksXG4gICAgICAgIGFjY2VwdG9yOiByZXNvdXJjZUFjY2Vzc0FjY2VwdG9yLFxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IGFjY2Vzc01hcCA9IHRoaXMuYWNjZXB0b3JBY2Nlc3NNYXAuZ2V0KGFjY2VwdG9yVG9rZW4pIS5hY2Nlc3NNYXA7XG4gICAgLy8gYWRkIGVhY2ggYWN0aW9uIHRvIHRoZSBhY2Nlc3NNYXAgZm9yIHRoaXMgYWNjZXB0b3JUb2tlblxuICAgIGFjdGlvbnMuZm9yRWFjaCgoYWN0aW9uKSA9PiB7XG4gICAgICBpZiAoIWFjY2Vzc01hcC5oYXMoYWN0aW9uKSkge1xuICAgICAgICAvLyBpZiB3ZSBoYXZlbid0IHNlZW4gdGhpcyBhY3Rpb24gZm9yIHRoaXMgYWNjZXB0b3JUb2tlbiBiZWZvcmUsIGFkZCBpdCB0byB0aGUgbWFwXG4gICAgICAgIGNvbnN0IGFsbG93U2V0ID0gbmV3IFNldDxTdG9yYWdlUGF0aD4oW3MzUHJlZml4XSk7XG4gICAgICAgIGNvbnN0IGRlbnlTZXQgPSBuZXcgU2V0PFN0b3JhZ2VQYXRoPigpO1xuICAgICAgICBhY2Nlc3NNYXAuc2V0KGFjdGlvbiwgeyBhbGxvdzogYWxsb3dTZXQsIGRlbnk6IGRlbnlTZXQgfSk7XG5cbiAgICAgICAgLy8gdGhpcyBpcyB3aGVyZSB3ZSBjcmVhdGUgdGhlIHJldmVyc2UgbWFwcGluZyB0aGF0IGFsbG93cyB1cyB0byBhZGQgZW50cmllcyB0byB0aGUgZGVueVNldCBsYXRlciBieSBsb29raW5nIHVwIHRoZSBwcmVmaXhcbiAgICAgICAgdGhpcy5zZXRQcmVmaXhEZW55TWFwRW50cnkoczNQcmVmaXgsIGFsbG93U2V0LCBkZW55U2V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG90aGVyd2lzZSBhZGQgdGhlIHByZWZpeCB0byB0aGUgZXhpc3RpbmcgYWxsb3cgc2V0XG4gICAgICAgIGNvbnN0IHsgYWxsb3c6IGFsbG93U2V0LCBkZW55OiBkZW55U2V0IH0gPSBhY2Nlc3NNYXAuZ2V0KGFjdGlvbikhO1xuICAgICAgICBhbGxvd1NldC5hZGQoczNQcmVmaXgpO1xuXG4gICAgICAgIC8vIGFkZCBhbiBlbnRyeSBpbiB0aGUgcHJlZml4RGVueU1hcCBmb3IgdGhlIGV4aXN0aW5nIGFsbG93IGFuZCBkZW55IHNldFxuICAgICAgICB0aGlzLnNldFByZWZpeERlbnlNYXBFbnRyeShzM1ByZWZpeCwgYWxsb3dTZXQsIGRlbnlTZXQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJdGVyYXRlcyBvdmVyIGFsbCBvZiB0aGUgYWNjZXNzIGRlZmluaXRpb25zIHRoYXQgaGF2ZSBiZWVuIGFkZGVkIHRvIHRoZSBvcmNoZXN0cmF0b3IsXG4gICAqIGdlbmVyYXRlcyBhIHBvbGljeSBmb3IgZWFjaCBhY2Nlc3NNYXAsXG4gICAqIGFuZCBhdHRhY2hlcyB0aGUgcG9saWN5IHRvIHRoZSBjb3JyZXNwb25kaW5nIFJlc291cmNlQWNjZXNzQWNjZXB0b3JcbiAgICpcbiAgICogQWZ0ZXIgdGhpcyBtZXRob2QgaXMgY2FsbGVkLCB0aGUgZXhpc3RpbmcgYWNjZXNzIGRlZmluaXRpb24gc3RhdGUgaXMgY2xlYXJlZC5cbiAgICogVGhpcyBwcmV2ZW50cyBtdWx0aXBsZSBjYWxscyB0byB0aGlzIG1ldGhvZCBmcm9tIHByb2R1Y2luZyBkdXBsaWNhdGUgcG9saWNpZXMuXG4gICAqIFRoZSBjbGFzcyBjYW4gY29udGludWUgdG8gYmUgdXNlZCB0byBidWlsZCB1cCBzdGF0ZSBmb3IgYSBuZXcgc2V0IG9mIHBvbGljaWVzIGlmIGRlc2lyZWQuXG4gICAqIEBwYXJhbSBzc21FbnZpcm9ubWVudEVudHJpZXMgQWRkaXRpb25hbCBTU00gY29udGV4dCB0aGF0IGlzIHBhc3NlZCB0byBlYWNoIFJlc291cmNlQWNjZXNzQWNjZXB0b3JcbiAgICovXG4gIHByaXZhdGUgYXR0YWNoUG9saWNpZXMgPSAoc3NtRW52aXJvbm1lbnRFbnRyaWVzOiBTc21FbnZpcm9ubWVudEVudHJ5W10pID0+IHtcbiAgICBjb25zdCBhbGxQYXRocyA9IEFycmF5LmZyb20odGhpcy5wcmVmaXhEZW55TWFwLmtleXMoKSk7XG4gICAgYWxsUGF0aHMuZm9yRWFjaCgoc3RvcmFnZVBhdGgpID0+IHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IGZpbmRQYXJlbnQoc3RvcmFnZVBhdGgsIGFsbFBhdGhzKTtcbiAgICAgIC8vIGRvIG5vdCBhZGQgdG8gcHJlZml4IGRlbnkgbWFwIGlmIHRoZXJlIGlzIG5vIHBhcmVudCBvciB0aGUgcGF0aCBpcyBhIHN1YnBhdGggd2l0aCBlbnRpdHkgaWRcbiAgICAgIGlmIChcbiAgICAgICAgIXBhcmVudCB8fFxuICAgICAgICBwYXJlbnQgPT09IHN0b3JhZ2VQYXRoLnJlcGxhY2VBbGwoYCR7ZW50aXR5SWRTdWJzdGl0dXRpb259L2AsICcnKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIC8vIGlmIGEgcGFyZW50IHBhdGggaXMgZGVmaW5lZCwgaW52b2tlIHRoZSBkZW55QnlEZWZhdWx0IGNhbGxiYWNrIG9uIHRoaXMgc3VicGF0aCBmb3IgYWxsIHBvbGljaWVzIHRoYXQgZXhpc3Qgb24gdGhlIHBhcmVudCBwYXRoXG4gICAgICB0aGlzLnByZWZpeERlbnlNYXBcbiAgICAgICAgLmdldChwYXJlbnQpXG4gICAgICAgID8uZm9yRWFjaCgoZGVueUJ5RGVmYXVsdENhbGxiYWNrKSA9PlxuICAgICAgICAgIGRlbnlCeURlZmF1bHRDYWxsYmFjayhzdG9yYWdlUGF0aClcbiAgICAgICAgKTtcbiAgICB9KTtcblxuICAgIHRoaXMuYWNjZXB0b3JBY2Nlc3NNYXAuZm9yRWFjaCgoeyBhY2NlcHRvciwgYWNjZXNzTWFwIH0pID0+IHtcbiAgICAgIC8vIHJlbW92aW5nIHN1YnBhdGhzIGZyb20gdGhlIGFsbG93IHNldCBwcmV2ZW50cyB1bm5lY2Vzc2FyeSBwYXRocyBmcm9tIGJlaW5nIGFkZGVkIHRvIHRoZSBwb2xpY3lcbiAgICAgIC8vIGZvciBleGFtcGxlLCBpZiB0aGVyZSBhcmUgYWxsb3cgcmVhZCBydWxlcyBmb3IgL2Zvby8qIGFuZCAvZm9vL2Jhci8qIHdlIG9ubHkgbmVlZCB0byBhZGQgL2Zvby8qIHRvIHRoZSBwb2xpY3kgYmVjYXVzZSB0aGF0IGluY2x1ZGVzIC9mb28vYmFyLypcbiAgICAgIGFjY2Vzc01hcC5mb3JFYWNoKCh7IGFsbG93IH0pID0+IHtcbiAgICAgICAgcmVtb3ZlU3ViUGF0aHNGcm9tU2V0KGFsbG93KTtcbiAgICAgIH0pO1xuICAgICAgYWNjZXB0b3IuYWNjZXB0UmVzb3VyY2VBY2Nlc3MoXG4gICAgICAgIHRoaXMucG9saWN5RmFjdG9yeS5jcmVhdGVQb2xpY3koYWNjZXNzTWFwKSxcbiAgICAgICAgc3NtRW52aXJvbm1lbnRFbnRyaWVzXG4gICAgICApO1xuICAgIH0pO1xuICAgIHRoaXMuYWNjZXB0b3JBY2Nlc3NNYXAuY2xlYXIoKTtcbiAgICB0aGlzLnByZWZpeERlbnlNYXAuY2xlYXIoKTtcbiAgfTtcblxuICBwcml2YXRlIHNldFByZWZpeERlbnlNYXBFbnRyeSA9IChcbiAgICBzdG9yYWdlUGF0aDogU3RvcmFnZVBhdGgsXG4gICAgYWxsb3dQYXRoU2V0OiBTZXQ8U3RvcmFnZVBhdGg+LFxuICAgIGRlbnlQYXRoU2V0OiBTZXQ8U3RvcmFnZVBhdGg+XG4gICkgPT4ge1xuICAgIC8vIGZ1bmN0aW9uIHRoYXQgd2lsbCBhZGQgdGhlIGRlbnlQYXRoIHRvIHRoZSBkZW55UGF0aFNldCB1bmxlc3MgdGhlIGFsbG93UGF0aFNldCBleHBsaWNpdGx5IGFsbG93cyB0aGUgcGF0aFxuICAgIGNvbnN0IHNldERlbnlCeURlZmF1bHQgPSAoZGVueVBhdGg6IFN0b3JhZ2VQYXRoKSA9PiB7XG4gICAgICBpZiAoIWFsbG93UGF0aFNldC5oYXMoZGVueVBhdGgpKSB7XG4gICAgICAgIGRlbnlQYXRoU2V0LmFkZChkZW55UGF0aCk7XG4gICAgICB9XG4gICAgfTtcbiAgICBpZiAoIXRoaXMucHJlZml4RGVueU1hcC5oYXMoc3RvcmFnZVBhdGgpKSB7XG4gICAgICB0aGlzLnByZWZpeERlbnlNYXAuc2V0KHN0b3JhZ2VQYXRoLCBbc2V0RGVueUJ5RGVmYXVsdF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnByZWZpeERlbnlNYXAuZ2V0KHN0b3JhZ2VQYXRoKT8ucHVzaChzZXREZW55QnlEZWZhdWx0KTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBmYWN0b3J5IGlzIHJlYWxseSBvbmx5IG5lY2Vzc2FyeSBmb3IgYWxsb3dpbmcgdXMgdG8gbW9jayB0aGUgU3RvcmFnZUFjY2Vzc09yY2hlc3RyYXRvciBpbiB0ZXN0c1xuICovXG5leHBvcnQgY2xhc3MgU3RvcmFnZUFjY2Vzc09yY2hlc3RyYXRvckZhY3Rvcnkge1xuICBnZXRJbnN0YW5jZSA9IChcbiAgICBzdG9yYWdlQWNjZXNzR2VuZXJhdG9yOiBTdG9yYWdlQWNjZXNzR2VuZXJhdG9yLFxuICAgIGdldEluc3RhbmNlUHJvcHM6IENvbnN0cnVjdEZhY3RvcnlHZXRJbnN0YW5jZVByb3BzLFxuICAgIHNzbUVudmlyb25tZW50RW50cmllczogU3NtRW52aXJvbm1lbnRFbnRyeVtdLFxuICAgIHBvbGljeUZhY3Rvcnk6IFN0b3JhZ2VBY2Nlc3NQb2xpY3lGYWN0b3J5XG4gICkgPT5cbiAgICBuZXcgU3RvcmFnZUFjY2Vzc09yY2hlc3RyYXRvcihcbiAgICAgIHN0b3JhZ2VBY2Nlc3NHZW5lcmF0b3IsXG4gICAgICBnZXRJbnN0YW5jZVByb3BzLFxuICAgICAgc3NtRW52aXJvbm1lbnRFbnRyaWVzLFxuICAgICAgcG9saWN5RmFjdG9yeVxuICAgICk7XG59XG5cbi8qKlxuICogUGVyZm9ybXMgdGhlIG93bmVyIHBsYWNlaG9sZGVyIHN1YnN0aXR1dGlvbiBpbiB0aGUgczMgcHJlZml4XG4gKi9cbmNvbnN0IHBsYWNlaG9sZGVyU3Vic3RpdHV0aW9uID0gKFxuICBzM1ByZWZpeDogc3RyaW5nLFxuICBpZFN1YnN0aXR1dGlvbjogc3RyaW5nXG4pOiBTdG9yYWdlUGF0aCA9PiB7XG4gIGNvbnN0IHByZWZpeCA9IHMzUHJlZml4LnJlcGxhY2VBbGwoXG4gICAgZW50aXR5SWRQYXRoVG9rZW4sXG4gICAgaWRTdWJzdGl0dXRpb25cbiAgKSBhcyBTdG9yYWdlUGF0aDtcblxuICAvLyBmb3Igb3duZXIgcGF0aHMgd2hlcmUgcHJlZml4IGVuZHMgd2l0aCAnLyovKicgcmVtb3ZlIHRoZSBsYXN0IHdpbGRjYXJkXG4gIGlmIChwcmVmaXguZW5kc1dpdGgoJy8qLyonKSkge1xuICAgIHJldHVybiBwcmVmaXguc2xpY2UoMCwgLTIpIGFzIFN0b3JhZ2VQYXRoO1xuICB9XG5cbiAgcmV0dXJuIHByZWZpeCBhcyBTdG9yYWdlUGF0aDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZWxlbWVudCBpbiBwYXRocyB0aGF0IGlzIGEgcHJlZml4IG9mIHBhdGgsIGlmIGFueVxuICogTm90ZSB0aGF0IHRoZXJlIGNhbiBvbmx5IGJlIG9uZSBhdCB0aGlzIHBvaW50IGJlY2F1c2Ugb2YgdXBzdHJlYW0gdmFsaWRhdGlvblxuICovXG5jb25zdCBmaW5kUGFyZW50ID0gKHBhdGg6IHN0cmluZywgcGF0aHM6IHN0cmluZ1tdKSA9PlxuICBwYXRocy5maW5kKChwKSA9PiBwYXRoICE9PSBwICYmIHBhdGguc3RhcnRzV2l0aChwLnJlcGxhY2VBbGwoJyonLCAnJykpKSBhc1xuICAgIHwgU3RvcmFnZVBhdGhcbiAgICB8IHVuZGVmaW5lZDtcblxuY29uc3QgcmVtb3ZlU3ViUGF0aHNGcm9tU2V0ID0gKHBhdGhzOiBTZXQ8U3RvcmFnZVBhdGg+KSA9PiB7XG4gIHBhdGhzLmZvckVhY2goKHBhdGgpID0+IHtcbiAgICBpZiAoZmluZFBhcmVudChwYXRoLCBBcnJheS5mcm9tKHBhdGhzKSkpIHtcbiAgICAgIHBhdGhzLmRlbGV0ZShwYXRoKTtcbiAgICB9XG4gIH0pO1xufTtcbiJdfQ==