import { LogLevel } from '@aws-amplify/cli-core';
import { TagName } from '@aws-amplify/platform-core';
import { GetFunctionCommand } from '@aws-sdk/client-lambda';
/**
 * Logs streamer for customer defined lambda functions in a sandbox.
 */
export class LambdaFunctionLogStreamer {
    lambda;
    logsMonitor;
    backendOutputClient;
    printer;
    enabled = false;
    /**
     * Creates an instance of LambdaFunctionLogStreamer
     */
    constructor(lambda, logsMonitor, backendOutputClient, printer) {
        this.lambda = lambda;
        this.logsMonitor = logsMonitor;
        this.backendOutputClient = backendOutputClient;
        this.printer = printer;
    }
    /**
     * Starts streaming logs in the given sandbox.
     * @param sandboxBackendId The sandbox backend identifier.
     * @param streamingOptions Options to configure the log streaming.
     */
    startStreamingLogs = async (sandboxBackendId, streamingOptions) => {
        if (streamingOptions?.enabled) {
            this.enabled = true;
        }
        else {
            return;
        }
        const backendOutput = await this.backendOutputClient.getOutput(sandboxBackendId);
        const definedFunctionsPayload = backendOutput['AWS::Amplify::Function']?.payload.definedFunctions;
        const definedConversationHandlersPayload = backendOutput['AWS::Amplify::AI::Conversation']?.payload
            .definedConversationHandlers;
        const deployedFunctionNames = definedFunctionsPayload
            ? JSON.parse(definedFunctionsPayload)
            : [];
        deployedFunctionNames.push(...(definedConversationHandlersPayload
            ? JSON.parse(definedConversationHandlersPayload)
            : []));
        for (const functionName of deployedFunctionNames) {
            const getFunctionResponse = await this.lambda.send(new GetFunctionCommand({
                FunctionName: functionName,
            }));
            const logGroupName = getFunctionResponse.Configuration?.LoggingConfig?.LogGroup;
            if (!logGroupName) {
                this.printer.log(`[Sandbox] Could not find logGroup for lambda function ${functionName}. Logs will not be streamed for this function.`, LogLevel.DEBUG);
                continue;
            }
            const friendlyFunctionName = getFunctionResponse.Tags?.[TagName.FRIENDLY_NAME];
            if (!friendlyFunctionName) {
                this.printer.log(`[Sandbox] Could not find user defined name for lambda function ${functionName}. Logs will not be streamed for this function.`, LogLevel.DEBUG);
                continue;
            }
            let shouldStreamLogs = false;
            if (streamingOptions.logsFilters) {
                for (const filter of streamingOptions.logsFilters) {
                    const pattern = new RegExp(filter);
                    if (pattern.test(friendlyFunctionName)) {
                        shouldStreamLogs = true;
                        this.printer.log(`[Sandbox] Logs for function ${friendlyFunctionName} will be streamed as it matched filter '${filter}'`, LogLevel.DEBUG);
                        break;
                    }
                }
            }
            else {
                // No logs filter, means we stream all logs
                this.printer.log(`[Sandbox] Logs for function ${friendlyFunctionName} will be streamed.`, LogLevel.DEBUG);
                shouldStreamLogs = true;
            }
            if (shouldStreamLogs) {
                this.logsMonitor?.addLogGroups(friendlyFunctionName, logGroupName);
            }
            else {
                this.printer.log(`[Sandbox] Skipping logs streaming for function ${friendlyFunctionName} since it did not match any filters. To stream logs for this function, ensure at least one of your logs-filters match this function name.`, LogLevel.DEBUG);
            }
        }
        // finally start listening
        this.logsMonitor?.activate(streamingOptions.logsOutFile);
    };
    stopStreamingLogs = () => {
        if (!this.enabled) {
            return;
        }
        this.printer.log(`[Sandbox] Streaming function logs will be paused during the deployment and will be resumed after the deployment is completed.`, LogLevel.DEBUG);
        this.logsMonitor?.pause();
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGFtYmRhX2Z1bmN0aW9uX2xvZ19zdHJlYW1lci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9sYW1iZGFfZnVuY3Rpb25fbG9nX3N0cmVhbWVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxRQUFRLEVBQVcsTUFBTSx1QkFBdUIsQ0FBQztBQUUxRCxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sNEJBQTRCLENBQUM7QUFHckQsT0FBTyxFQUFFLGtCQUFrQixFQUFnQixNQUFNLHdCQUF3QixDQUFDO0FBSTFFOztHQUVHO0FBQ0gsTUFBTSxPQUFPLHlCQUF5QjtJQU1qQjtJQUNBO0lBQ0E7SUFDQTtJQVJYLE9BQU8sR0FBWSxLQUFLLENBQUM7SUFDakM7O09BRUc7SUFDSCxZQUNtQixNQUFvQixFQUNwQixXQUFzQyxFQUN0QyxtQkFBd0MsRUFDeEMsT0FBZ0I7UUFIaEIsV0FBTSxHQUFOLE1BQU0sQ0FBYztRQUNwQixnQkFBVyxHQUFYLFdBQVcsQ0FBMkI7UUFDdEMsd0JBQW1CLEdBQW5CLG1CQUFtQixDQUFxQjtRQUN4QyxZQUFPLEdBQVAsT0FBTyxDQUFTO0lBQ2hDLENBQUM7SUFFSjs7OztPQUlHO0lBQ0gsa0JBQWtCLEdBQUcsS0FBSyxFQUN4QixnQkFBbUMsRUFDbkMsZ0JBQWtELEVBQ2xELEVBQUU7UUFDRixJQUFJLGdCQUFnQixFQUFFLE9BQU8sRUFBRTtZQUM3QixJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQztTQUNyQjthQUFNO1lBQ0wsT0FBTztTQUNSO1FBRUQsTUFBTSxhQUFhLEdBQ2pCLE1BQU0sSUFBSSxDQUFDLG1CQUFtQixDQUFDLFNBQVMsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO1FBRTdELE1BQU0sdUJBQXVCLEdBQzNCLGFBQWEsQ0FBQyx3QkFBd0IsQ0FBQyxFQUFFLE9BQU8sQ0FBQyxnQkFBZ0IsQ0FBQztRQUNwRSxNQUFNLGtDQUFrQyxHQUN0QyxhQUFhLENBQUMsZ0NBQWdD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QUssRUFBRSxDQUFDO0lBQzVCLENBQUMsQ0FBQztDQUNIIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTG9nTGV2ZWwsIFByaW50ZXIgfSBmcm9tICdAYXdzLWFtcGxpZnkvY2xpLWNvcmUnO1xuaW1wb3J0IHsgQmFja2VuZE91dHB1dENsaWVudCB9IGZyb20gJ0Bhd3MtYW1wbGlmeS9kZXBsb3llZC1iYWNrZW5kLWNsaWVudCc7XG5pbXBvcnQgeyBUYWdOYW1lIH0gZnJvbSAnQGF3cy1hbXBsaWZ5L3BsYXRmb3JtLWNvcmUnO1xuaW1wb3J0IHsgQmFja2VuZElkZW50aWZpZXIsIEJhY2tlbmRPdXRwdXQgfSBmcm9tICdAYXdzLWFtcGxpZnkvcGx1Z2luLXR5cGVzJztcblxuaW1wb3J0IHsgR2V0RnVuY3Rpb25Db21tYW5kLCBMYW1iZGFDbGllbnQgfSBmcm9tICdAYXdzLXNkay9jbGllbnQtbGFtYmRhJztcbmltcG9ydCB7IENsb3VkV2F0Y2hMb2dFdmVudE1vbml0b3IgfSBmcm9tICcuL2Nsb3Vkd2F0Y2hfbG9nc19tb25pdG9yLmpzJztcbmltcG9ydCB7IFNhbmRib3hGdW5jdGlvblN0cmVhbWluZ09wdGlvbnMgfSBmcm9tICcuL3NhbmRib3guanMnO1xuXG4vKipcbiAqIExvZ3Mgc3RyZWFtZXIgZm9yIGN1c3RvbWVyIGRlZmluZWQgbGFtYmRhIGZ1bmN0aW9ucyBpbiBhIHNhbmRib3guXG4gKi9cbmV4cG9ydCBjbGFzcyBMYW1iZGFGdW5jdGlvbkxvZ1N0cmVhbWVyIHtcbiAgcHJpdmF0ZSBlbmFibGVkOiBib29sZWFuID0gZmFsc2U7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIExhbWJkYUZ1bmN0aW9uTG9nU3RyZWFtZXJcbiAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgbGFtYmRhOiBMYW1iZGFDbGllbnQsXG4gICAgcHJpdmF0ZSByZWFkb25seSBsb2dzTW9uaXRvcjogQ2xvdWRXYXRjaExvZ0V2ZW50TW9uaXRvcixcbiAgICBwcml2YXRlIHJlYWRvbmx5IGJhY2tlbmRPdXRwdXRDbGllbnQ6IEJhY2tlbmRPdXRwdXRDbGllbnQsXG4gICAgcHJpdmF0ZSByZWFkb25seSBwcmludGVyOiBQcmludGVyXG4gICkge31cblxuICAvKipcbiAgICogU3RhcnRzIHN0cmVhbWluZyBsb2dzIGluIHRoZSBnaXZlbiBzYW5kYm94LlxuICAgKiBAcGFyYW0gc2FuZGJveEJhY2tlbmRJZCBUaGUgc2FuZGJveCBiYWNrZW5kIGlkZW50aWZpZXIuXG4gICAqIEBwYXJhbSBzdHJlYW1pbmdPcHRpb25zIE9wdGlvbnMgdG8gY29uZmlndXJlIHRoZSBsb2cgc3RyZWFtaW5nLlxuICAgKi9cbiAgc3RhcnRTdHJlYW1pbmdMb2dzID0gYXN5bmMgKFxuICAgIHNhbmRib3hCYWNrZW5kSWQ6IEJhY2tlbmRJZGVudGlmaWVyLFxuICAgIHN0cmVhbWluZ09wdGlvbnM/OiBTYW5kYm94RnVuY3Rpb25TdHJlYW1pbmdPcHRpb25zXG4gICkgPT4ge1xuICAgIGlmIChzdHJlYW1pbmdPcHRpb25zPy5lbmFibGVkKSB7XG4gICAgICB0aGlzLmVuYWJsZWQgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYmFja2VuZE91dHB1dDogQmFja2VuZE91dHB1dCA9XG4gICAgICBhd2FpdCB0aGlzLmJhY2tlbmRPdXRwdXRDbGllbnQuZ2V0T3V0cHV0KHNhbmRib3hCYWNrZW5kSWQpO1xuXG4gICAgY29uc3QgZGVmaW5lZEZ1bmN0aW9uc1BheWxvYWQgPVxuICAgICAgYmFja2VuZE91dHB1dFsnQVdTOjpBbXBsaWZ5OjpGdW5jdGlvbiddPy5wYXlsb2FkLmRlZmluZWRGdW5jdGlvbnM7XG4gICAgY29uc3QgZGVmaW5lZENvbnZlcnNhdGlvbkhhbmRsZXJzUGF5bG9hZCA9XG4gICAgICBiYWNrZW5kT3V0cHV0WydBV1M6OkFtcGxpZnk6OkFJOjpDb252ZXJzYXRpb24nXT8ucGF5bG9hZFxuICAgICAgICAuZGVmaW5lZENvbnZlcnNhdGlvbkhhbmRsZXJzO1xuICAgIGNvbnN0IGRlcGxveWVkRnVuY3Rpb25OYW1lcyA9IGRlZmluZWRGdW5jdGlvbnNQYXlsb2FkXG4gICAgICA/IChKU09OLnBhcnNlKGRlZmluZWRGdW5jdGlvbnNQYXlsb2FkKSBhcyBzdHJpbmdbXSlcbiAgICAgIDogW107XG4gICAgZGVwbG95ZWRGdW5jdGlvbk5hbWVzLnB1c2goXG4gICAgICAuLi4oZGVmaW5lZENvbnZlcnNhdGlvbkhhbmRsZXJzUGF5bG9hZFxuICAgICAgICA/IChKU09OLnBhcnNlKGRlZmluZWRDb252ZXJzYXRpb25IYW5kbGVyc1BheWxvYWQpIGFzIHN0cmluZ1tdKVxuICAgICAgICA6IFtdKVxuICAgICk7XG5cbiAgICBmb3IgKGNvbnN0IGZ1bmN0aW9uTmFtZSBvZiBkZXBsb3llZEZ1bmN0aW9uTmFtZXMpIHtcbiAgICAgIGNvbnN0IGdldEZ1bmN0aW9uUmVzcG9uc2UgPSBhd2FpdCB0aGlzLmxhbWJkYS5zZW5kKFxuICAgICAgICBuZXcgR2V0RnVuY3Rpb25Db21tYW5kKHtcbiAgICAgICAgICBGdW5jdGlvbk5hbWU6IGZ1bmN0aW9uTmFtZSxcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICBjb25zdCBsb2dHcm91cE5hbWUgPVxuICAgICAgICBnZXRGdW5jdGlvblJlc3BvbnNlLkNvbmZpZ3VyYXRpb24/LkxvZ2dpbmdDb25maWc/LkxvZ0dyb3VwO1xuICAgICAgaWYgKCFsb2dHcm91cE5hbWUpIHtcbiAgICAgICAgdGhpcy5wcmludGVyLmxvZyhcbiAgICAgICAgICBgW1NhbmRib3hdIENvdWxkIG5vdCBmaW5kIGxvZ0dyb3VwIGZvciBsYW1iZGEgZnVuY3Rpb24gJHtmdW5jdGlvbk5hbWV9LiBMb2dzIHdpbGwgbm90IGJlIHN0cmVhbWVkIGZvciB0aGlzIGZ1bmN0aW9uLmAsXG4gICAgICAgICAgTG9nTGV2ZWwuREVCVUdcbiAgICAgICAgKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBmcmllbmRseUZ1bmN0aW9uTmFtZSA9XG4gICAgICAgIGdldEZ1bmN0aW9uUmVzcG9uc2UuVGFncz8uW1RhZ05hbWUuRlJJRU5ETFlfTkFNRV07XG4gICAgICBpZiAoIWZyaWVuZGx5RnVuY3Rpb25OYW1lKSB7XG4gICAgICAgIHRoaXMucHJpbnRlci5sb2coXG4gICAgICAgICAgYFtTYW5kYm94XSBDb3VsZCBub3QgZmluZCB1c2VyIGRlZmluZWQgbmFtZSBmb3IgbGFtYmRhIGZ1bmN0aW9uICR7ZnVuY3Rpb25OYW1lfS4gTG9ncyB3aWxsIG5vdCBiZSBzdHJlYW1lZCBmb3IgdGhpcyBmdW5jdGlvbi5gLFxuICAgICAgICAgIExvZ0xldmVsLkRFQlVHXG4gICAgICAgICk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBsZXQgc2hvdWxkU3RyZWFtTG9ncyA9IGZhbHNlO1xuICAgICAgaWYgKHN0cmVhbWluZ09wdGlvbnMubG9nc0ZpbHRlcnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBmaWx0ZXIgb2Ygc3RyZWFtaW5nT3B0aW9ucy5sb2dzRmlsdGVycykge1xuICAgICAgICAgIGNvbnN0IHBhdHRlcm4gPSBuZXcgUmVnRXhwKGZpbHRlcik7XG4gICAgICAgICAgaWYgKHBhdHRlcm4udGVzdChmcmllbmRseUZ1bmN0aW9uTmFtZSkpIHtcbiAgICAgICAgICAgIHNob3VsZFN0cmVhbUxvZ3MgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5wcmludGVyLmxvZyhcbiAgICAgICAgICAgICAgYFtTYW5kYm94XSBMb2dzIGZvciBmdW5jdGlvbiAke2ZyaWVuZGx5RnVuY3Rpb25OYW1lfSB3aWxsIGJlIHN0cmVhbWVkIGFzIGl0IG1hdGNoZWQgZmlsdGVyICcke2ZpbHRlcn0nYCxcbiAgICAgICAgICAgICAgTG9nTGV2ZWwuREVCVUdcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vIGxvZ3MgZmlsdGVyLCBtZWFucyB3ZSBzdHJlYW0gYWxsIGxvZ3NcbiAgICAgICAgdGhpcy5wcmludGVyLmxvZyhcbiAgICAgICAgICBgW1NhbmRib3hdIExvZ3MgZm9yIGZ1bmN0aW9uICR7ZnJpZW5kbHlGdW5jdGlvbk5hbWV9IHdpbGwgYmUgc3RyZWFtZWQuYCxcbiAgICAgICAgICBMb2dMZXZlbC5ERUJVR1xuICAgICAgICApO1xuICAgICAgICBzaG91bGRTdHJlYW1Mb2dzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNob3VsZFN0cmVhbUxvZ3MpIHtcbiAgICAgICAgdGhpcy5sb2dzTW9uaXRvcj8uYWRkTG9nR3JvdXBzKGZyaWVuZGx5RnVuY3Rpb25OYW1lLCBsb2dHcm91cE5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wcmludGVyLmxvZyhcbiAgICAgICAgICBgW1NhbmRib3hdIFNraXBwaW5nIGxvZ3Mgc3RyZWFtaW5nIGZvciBmdW5jdGlvbiAke2ZyaWVuZGx5RnVuY3Rpb25OYW1lfSBzaW5jZSBpdCBkaWQgbm90IG1hdGNoIGFueSBmaWx0ZXJzLiBUbyBzdHJlYW0gbG9ncyBmb3IgdGhpcyBmdW5jdGlvbiwgZW5zdXJlIGF0IGxlYXN0IG9uZSBvZiB5b3VyIGxvZ3MtZmlsdGVycyBtYXRjaCB0aGlzIGZ1bmN0aW9uIG5hbWUuYCxcbiAgICAgICAgICBMb2dMZXZlbC5ERUJVR1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGZpbmFsbHkgc3RhcnQgbGlzdGVuaW5nXG4gICAgdGhpcy5sb2dzTW9uaXRvcj8uYWN0aXZhdGUoc3RyZWFtaW5nT3B0aW9ucy5sb2dzT3V0RmlsZSk7XG4gIH07XG5cbiAgc3RvcFN0cmVhbWluZ0xvZ3MgPSAoKSA9PiB7XG4gICAgaWYgKCF0aGlzLmVuYWJsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wcmludGVyLmxvZyhcbiAgICAgIGBbU2FuZGJveF0gU3RyZWFtaW5nIGZ1bmN0aW9uIGxvZ3Mgd2lsbCBiZSBwYXVzZWQgZHVyaW5nIHRoZSBkZXBsb3ltZW50IGFuZCB3aWxsIGJlIHJlc3VtZWQgYWZ0ZXIgdGhlIGRlcGxveW1lbnQgaXMgY29tcGxldGVkLmAsXG4gICAgICBMb2dMZXZlbC5ERUJVR1xuICAgICk7XG4gICAgdGhpcy5sb2dzTW9uaXRvcj8ucGF1c2UoKTtcbiAgfTtcbn1cbiJdfQ==