import { LogLevel, Printer, colorNames, format, printer, } from '@aws-amplify/cli-core';
import { FilterLogEventsCommand, ResourceNotFoundException, } from '@aws-sdk/client-cloudwatch-logs';
import fs from 'fs';
import path from 'path';
/**
 * After reading events from all CloudWatch log groups how long should we wait to read more events.
 *
 * If there is some error with reading events (i.e. Throttle) then this is also how long we wait until we try again
 */
const SLEEP_MS = 2000;
/**
 * Monitors CloudWatch logs and stream it to stdout or a user provided file location
 * Consumers can activate and deactivate the monitor. The monitor on reactivation, starts
 * streaming from the last time it was deactivated to avoid missing any logs while the monitor
 * was deactivated.
 */
export class CloudWatchLogEventMonitor {
    cloudWatchLogsClient;
    /**
     * Determines from what time the logs should be streamed
     */
    startTime;
    /**
     * Collection of all LogGroups that need to be streamed
     */
    allLogGroups = [];
    logGroupEventDisplay = {};
    active = false;
    printer = printer; // default stdout
    enableColors = true; // show colors on console but not while writing to files
    /**
     * Initializes the start time to be `now`
     */
    constructor(cloudWatchLogsClient) {
        this.cloudWatchLogsClient = cloudWatchLogsClient;
        this.startTime = Date.now();
    }
    /**
     * resume writing/printing events
     * If output location file is specified, the logs will be appended to that file.
     * If the file doesn't exist it will be created.
     * @param outputLocation file location
     */
    activate = (outputLocation) => {
        if (outputLocation) {
            const targetPath = path.isAbsolute(outputLocation)
                ? outputLocation
                : path.resolve(process.cwd(), outputLocation);
            this.printer = new Printer(LogLevel.INFO, fs.createWriteStream(targetPath, { flags: 'a', autoClose: true }));
            this.enableColors = false;
        }
        this.active = true;
        this.scheduleNextTick(0);
    };
    /**
     * Pause the monitor so no new events are read
     * use case for this is when we are in the middle of performing a deployment
     * and don't want to interweave all the logs together with the CFN
     * deployment logs
     *
     * Also resets the start time to be when the new deployment was triggered so that we
     * start streaming the logs from when it was deactivated.
     * and clears the list of tracked log groups
     */
    pause = () => {
        this.active = false;
        this.startTime = Date.now();
        this.allLogGroups.splice(0, this.allLogGroups.length);
    };
    /**
     * Adds CloudWatch log groups to read log events from.
     * Since we could be watching multiple logs groups we need a friendly
     * name for to associate the log group to make it easier
     * for the user to identify which log groups are being monitored
     * @param friendlyResourceName The friendly name of the resource that is being monitored
     * @param logGroupName The log group to read events from
     */
    addLogGroups = (friendlyResourceName, logGroupName) => {
        this.allLogGroups.push({
            logGroupName,
            startTime: this.startTime,
        });
        this.logGroupEventDisplay[logGroupName] = {
            friendlyName: friendlyResourceName,
            color: this.getNextColorForLogGroup(),
        };
    };
    /**
     * Pick the next color in the object `colors` in round robin fashion
     */
    getNextColorForLogGroup = () => {
        return colorNames[this.allLogGroups.length % colorNames.length];
    };
    scheduleNextTick = (sleep) => {
        setTimeout(() => void this.tick(), sleep);
    };
    tick = async () => {
        if (!this.active) {
            return;
        }
        try {
            const events = await this.readNewEvents();
            events.forEach((event) => {
                this.print(event);
            });
        }
        catch (error) {
            printer.log(`${format.error('Error streaming logs from CloudWatch.')} ${format.error(error)}`, LogLevel.ERROR);
            printer.log('Logs streaming has been paused.');
            this.pause();
        }
        this.scheduleNextTick(SLEEP_MS);
    };
    /**
     * Reads all new log events from a set of CloudWatch Log Groups in parallel
     */
    readNewEvents = async () => {
        const promises = [];
        for (const logGroup of this.allLogGroups) {
            promises.push(this.readEventsFromLogGroup(logGroup));
        }
        return (await Promise.all(promises)).flat();
    };
    /**
     * Print out one CloudWatch event using the local printer.
     */
    print = (event) => {
        const cloudWatchEventDisplay = this.logGroupEventDisplay[event.logGroupName];
        if (!cloudWatchEventDisplay) {
            return;
        }
        if (this.enableColors) {
            this.printer.print(`[${format.color(cloudWatchEventDisplay.friendlyName, cloudWatchEventDisplay.color)}] ${format.note(event.timestamp.toLocaleTimeString())} ${event.message.trim()}`);
        }
        else {
            this.printer.print(`[${cloudWatchEventDisplay.friendlyName}] ${event.timestamp.toLocaleTimeString()} ${event.message.trim()}`);
        }
    };
    /**
     * Reads all new log events from a CloudWatch Log Group
     * starting at either the time the last deployment was triggered or
     * when the last event was read on the previous tick
     */
    readEventsFromLogGroup = async (cloudWatchLogsToMonitor) => {
        const events = [];
        // log events from some service are ingested faster than others
        // so we need to track the start/end time for each log group individually
        // to make sure that we process all events from each log group.
        // endTime tracks the latest event received
        const startTime = cloudWatchLogsToMonitor.startTime ?? this.startTime;
        let endTime = startTime;
        try {
            const response = await this.cloudWatchLogsClient.send(new FilterLogEventsCommand({
                logGroupName: cloudWatchLogsToMonitor.logGroupName,
                limit: 100,
                startTime,
            }));
            const filteredEvents = response.events ?? [];
            for (const event of filteredEvents) {
                if (event.message) {
                    events.push({
                        message: event.message,
                        logGroupName: cloudWatchLogsToMonitor.logGroupName,
                        timestamp: event.timestamp ? new Date(event.timestamp) : new Date(),
                    });
                    if (event.timestamp && endTime < event.timestamp) {
                        endTime = event.timestamp;
                    }
                }
            }
            // As long as there are _any_ events in the log group `filterLogEvents` will return a nextToken.
            // This is true even if these events are before `startTime`. So if we have 100 events and a nextToken
            // then assume that we have hit the limit and let the user know some messages have been suppressed.
            // We are essentially showing them a sampling (10000 events printed out is not very useful)
            if (filteredEvents.length === 100 && response.nextToken) {
                events.push({
                    message: '>>> `sandbox` shows only the first 100 log messages - the rest have been truncated...',
                    logGroupName: cloudWatchLogsToMonitor.logGroupName,
                    timestamp: new Date(endTime),
                });
            }
        }
        catch (e) {
            // with Lambda functions the Log Group is not created
            // until something is logged, so just keep polling until
            // there is something to find
            if (e && e instanceof ResourceNotFoundException) {
                return [];
            }
            throw e;
        }
        cloudWatchLogsToMonitor.startTime = endTime + 1;
        return events;
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xvdWR3YXRjaF9sb2dzX21vbml0b3IuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvY2xvdWR3YXRjaF9sb2dzX21vbml0b3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUVMLFFBQVEsRUFDUixPQUFPLEVBQ1AsVUFBVSxFQUNWLE1BQU0sRUFDTixPQUFPLEdBQ1IsTUFBTSx1QkFBdUIsQ0FBQztBQUMvQixPQUFPLEVBRUwsc0JBQXNCLEVBQ3RCLHlCQUF5QixHQUMxQixNQUFNLGlDQUFpQyxDQUFDO0FBQ3pDLE9BQU8sRUFBRSxNQUFNLElBQUksQ0FBQztBQUNwQixPQUFPLElBQUksTUFBTSxNQUFNLENBQUM7QUFFeEI7Ozs7R0FJRztBQUNILE1BQU0sUUFBUSxHQUFHLElBQUssQ0FBQztBQTJDdkI7Ozs7O0dBS0c7QUFDSCxNQUFNLE9BQU8seUJBQXlCO0lBdUJmO0lBdEJyQjs7T0FFRztJQUNLLFNBQVMsQ0FBUztJQUUxQjs7T0FFRztJQUNjLFlBQVksR0FBOEIsRUFBRSxDQUFDO0lBRTdDLG9CQUFvQixHQUNuQyxFQUFFLENBQUM7SUFFRyxNQUFNLEdBQUcsS0FBSyxDQUFDO0lBRWYsT0FBTyxHQUFHLE9BQU8sQ0FBQyxDQUFDLGlCQUFpQjtJQUVwQyxZQUFZLEdBQUcsSUFBSSxDQUFDLENBQUMsd0RBQXdEO0lBRXJGOztPQUVHO0lBQ0gsWUFBcUIsb0JBQTBDO1FBQTFDLHlCQUFvQixHQUFwQixvQkFBb0IsQ0FBc0I7UUFDN0QsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7SUFDOUIsQ0FBQztJQUVEOzs7OztPQUtHO0lBQ0gsUUFBUSxHQUFHLENBQUMsY0FBdUIsRUFBUSxFQUFFO1FBQzNDLElBQUksY0FBYyxFQUFFO1lBQ2xCLE1BQU0sVUFBVSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsY0FBYyxDQUFDO2dCQUNoRCxDQUFDLENBQUMsY0FBYztnQkFDaEIsQ0FB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QXVCLENBQUMsWUFBWTtvQkFDbEQsU0FBUyxFQUFFLElBQUksSUFBSSxDQUFDLE9BQU8sQ0FBQztpQkFDN0IsQ0FBQyxDQUFDO2FBQ0o7U0FDRjtRQUFDLE9BQU8sQ0FBQyxFQUFFO1lBQ1YscURBQXFEO1lBQ3JELHdEQUF3RDtZQUN4RCw2QkFBNkI7WUFDN0IsSUFBSSxDQUFDLElBQUksQ0FBQyxZQUFZLHlCQUF5QixFQUFFO2dCQUMvQyxPQUFPLEVBQUUsQ0FBQzthQUNYO1lBQ0QsTUFBTSxDQUFDLENBQUM7U0FDVDtRQUNELHVCQUF1QixDQUFDLFNBQVMsR0FBRyxPQUFPLEdBQUcsQ0FBQyxDQUFDO1FBQ2hELE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUMsQ0FBQztDQUNIIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgQ29sb3JOYW1lLFxuICBMb2dMZXZlbCxcbiAgUHJpbnRlcixcbiAgY29sb3JOYW1lcyxcbiAgZm9ybWF0LFxuICBwcmludGVyLFxufSBmcm9tICdAYXdzLWFtcGxpZnkvY2xpLWNvcmUnO1xuaW1wb3J0IHtcbiAgQ2xvdWRXYXRjaExvZ3NDbGllbnQsXG4gIEZpbHRlckxvZ0V2ZW50c0NvbW1hbmQsXG4gIFJlc291cmNlTm90Rm91bmRFeGNlcHRpb24sXG59IGZyb20gJ0Bhd3Mtc2RrL2NsaWVudC1jbG91ZHdhdGNoLWxvZ3MnO1xuaW1wb3J0IGZzIGZyb20gJ2ZzJztcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuXG4vKipcbiAqIEFmdGVyIHJlYWRpbmcgZXZlbnRzIGZyb20gYWxsIENsb3VkV2F0Y2ggbG9nIGdyb3VwcyBob3cgbG9uZyBzaG91bGQgd2Ugd2FpdCB0byByZWFkIG1vcmUgZXZlbnRzLlxuICpcbiAqIElmIHRoZXJlIGlzIHNvbWUgZXJyb3Igd2l0aCByZWFkaW5nIGV2ZW50cyAoaS5lLiBUaHJvdHRsZSkgdGhlbiB0aGlzIGlzIGFsc28gaG93IGxvbmcgd2Ugd2FpdCB1bnRpbCB3ZSB0cnkgYWdhaW5cbiAqL1xuY29uc3QgU0xFRVBfTVMgPSAyXzAwMDtcblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgQ2xvdWRXYXRjaCBMb2cgRXZlbnQgdGhhdCB3aWxsIGJlIHByaW50ZWQgdG8gdGhlIHRlcm1pbmFsXG4gKi9cbnR5cGUgQ2xvdWRXYXRjaExvZ0V2ZW50ID0ge1xuICAvKipcbiAgICogVGhlIGxvZyBldmVudCBtZXNzYWdlXG4gICAqL1xuICByZWFkb25seSBtZXNzYWdlOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBsb2cgZ3JvdXBcbiAgICovXG4gIHJlYWRvbmx5IGxvZ0dyb3VwTmFtZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgdGltZSBhdCB3aGljaCB0aGUgZXZlbnQgb2NjdXJyZWRcbiAgICovXG4gIHJlYWRvbmx5IHRpbWVzdGFtcDogRGF0ZTtcbn07XG5cbi8qKlxuICogUmVwcmVzZW50cyBob3cgYW4gZXZlbnQgZnJvbSBhIENsb3VkV2F0Y2ggTG9nIEdyb3VwIHdpbGwgYmUgZGlzcGxheWVkXG4gKiBJbmRleGVkIG9mZiBvZiBsb2dHcm91cE5hbWUgZm9yIGVhc3kgcmV0cmlldmFsIGR1cmluZyBsb2dzIGV2ZW4gcG9sbGluZ1xuICovXG50eXBlIExvZ0dyb3VwRXZlbnREaXNwbGF5ID0ge1xuICBmcmllbmRseU5hbWU6IHN0cmluZztcbiAgY29sb3I6IENvbG9yTmFtZTtcbn07XG5cbnR5cGUgTG9nR3JvdXBTdHJlYW1pbmdDdXJzb3IgPSB7XG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgbG9nIGdyb3VwXG4gICAqL1xuICByZWFkb25seSBsb2dHcm91cE5hbWU6IHN0cmluZztcblxuICAvKipcbiAgICogU3RhcnQgdGltZVxuICAgKi9cbiAgc3RhcnRUaW1lOiBudW1iZXI7XG59O1xuXG4vKipcbiAqIE1vbml0b3JzIENsb3VkV2F0Y2ggbG9ncyBhbmQgc3RyZWFtIGl0IHRvIHN0ZG91dCBvciBhIHVzZXIgcHJvdmlkZWQgZmlsZSBsb2NhdGlvblxuICogQ29uc3VtZXJzIGNhbiBhY3RpdmF0ZSBhbmQgZGVhY3RpdmF0ZSB0aGUgbW9uaXRvci4gVGhlIG1vbml0b3Igb24gcmVhY3RpdmF0aW9uLCBzdGFydHNcbiAqIHN0cmVhbWluZyBmcm9tIHRoZSBsYXN0IHRpbWUgaXQgd2FzIGRlYWN0aXZhdGVkIHRvIGF2b2lkIG1pc3NpbmcgYW55IGxvZ3Mgd2hpbGUgdGhlIG1vbml0b3JcbiAqIHdhcyBkZWFjdGl2YXRlZC5cbiAqL1xuZXhwb3J0IGNsYXNzIENsb3VkV2F0Y2hMb2dFdmVudE1vbml0b3Ige1xuICAvKipcbiAgICogRGV0ZXJtaW5lcyBmcm9tIHdoYXQgdGltZSB0aGUgbG9ncyBzaG91bGQgYmUgc3RyZWFtZWRcbiAgICovXG4gIHByaXZhdGUgc3RhcnRUaW1lOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIENvbGxlY3Rpb24gb2YgYWxsIExvZ0dyb3VwcyB0aGF0IG5lZWQgdG8gYmUgc3RyZWFtZWRcbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgYWxsTG9nR3JvdXBzOiBMb2dHcm91cFN0cmVhbWluZ0N1cnNvcltdID0gW107XG5cbiAgcHJpdmF0ZSByZWFkb25seSBsb2dHcm91cEV2ZW50RGlzcGxheTogUmVjb3JkPHN0cmluZywgTG9nR3JvdXBFdmVudERpc3BsYXk+ID1cbiAgICB7fTtcblxuICBwcml2YXRlIGFjdGl2ZSA9IGZhbHNlO1xuXG4gIHByaXZhdGUgcHJpbnRlciA9IHByaW50ZXI7IC8vIGRlZmF1bHQgc3Rkb3V0XG5cbiAgcHJpdmF0ZSBlbmFibGVDb2xvcnMgPSB0cnVlOyAvLyBzaG93IGNvbG9ycyBvbiBjb25zb2xlIGJ1dCBub3Qgd2hpbGUgd3JpdGluZyB0byBmaWxlc1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgc3RhcnQgdGltZSB0byBiZSBgbm93YFxuICAgKi9cbiAgY29uc3RydWN0b3IocmVhZG9ubHkgY2xvdWRXYXRjaExvZ3NDbGllbnQ6IENsb3VkV2F0Y2hMb2dzQ2xpZW50KSB7XG4gICAgdGhpcy5zdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICB9XG5cbiAgLyoqXG4gICAqIHJlc3VtZSB3cml0aW5nL3ByaW50aW5nIGV2ZW50c1xuICAgKiBJZiBvdXRwdXQgbG9jYXRpb24gZmlsZSBpcyBzcGVjaWZpZWQsIHRoZSBsb2dzIHdpbGwgYmUgYXBwZW5kZWQgdG8gdGhhdCBmaWxlLlxuICAgKiBJZiB0aGUgZmlsZSBkb2Vzbid0IGV4aXN0IGl0IHdpbGwgYmUgY3JlYXRlZC5cbiAgICogQHBhcmFtIG91dHB1dExvY2F0aW9uIGZpbGUgbG9jYXRpb25cbiAgICovXG4gIGFjdGl2YXRlID0gKG91dHB1dExvY2F0aW9uPzogc3RyaW5nKTogdm9pZCA9PiB7XG4gICAgaWYgKG91dHB1dExvY2F0aW9uKSB7XG4gICAgICBjb25zdCB0YXJnZXRQYXRoID0gcGF0aC5pc0Fic29sdXRlKG91dHB1dExvY2F0aW9uKVxuICAgICAgICA/IG91dHB1dExvY2F0aW9uXG4gICAgICAgIDogcGF0aC5yZXNvbHZlKHByb2Nlc3MuY3dkKCksIG91dHB1dExvY2F0aW9uKTtcbiAgICAgIHRoaXMucHJpbnRlciA9IG5ldyBQcmludGVyKFxuICAgICAgICBMb2dMZXZlbC5JTkZPLFxuICAgICAgICBmcy5jcmVhdGVXcml0ZVN0cmVhbSh0YXJnZXRQYXRoLCB7IGZsYWdzOiAnYScsIGF1dG9DbG9zZTogdHJ1ZSB9KVxuICAgICAgKTtcbiAgICAgIHRoaXMuZW5hYmxlQ29sb3JzID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICAgIHRoaXMuc2NoZWR1bGVOZXh0VGljaygwKTtcbiAgfTtcblxuICAvKipcbiAgICogUGF1c2UgdGhlIG1vbml0b3Igc28gbm8gbmV3IGV2ZW50cyBhcmUgcmVhZFxuICAgKiB1c2UgY2FzZSBmb3IgdGhpcyBpcyB3aGVuIHdlIGFyZSBpbiB0aGUgbWlkZGxlIG9mIHBlcmZvcm1pbmcgYSBkZXBsb3ltZW50XG4gICAqIGFuZCBkb24ndCB3YW50IHRvIGludGVyd2VhdmUgYWxsIHRoZSBsb2dzIHRvZ2V0aGVyIHdpdGggdGhlIENGTlxuICAgKiBkZXBsb3ltZW50IGxvZ3NcbiAgICpcbiAgICogQWxzbyByZXNldHMgdGhlIHN0YXJ0IHRpbWUgdG8gYmUgd2hlbiB0aGUgbmV3IGRlcGxveW1lbnQgd2FzIHRyaWdnZXJlZCBzbyB0aGF0IHdlXG4gICAqIHN0YXJ0IHN0cmVhbWluZyB0aGUgbG9ncyBmcm9tIHdoZW4gaXQgd2FzIGRlYWN0aXZhdGVkLlxuICAgKiBhbmQgY2xlYXJzIHRoZSBsaXN0IG9mIHRyYWNrZWQgbG9nIGdyb3Vwc1xuICAgKi9cbiAgcGF1c2UgPSAoKTogdm9pZCA9PiB7XG4gICAgdGhpcy5hY3RpdmUgPSBmYWxzZTtcbiAgICB0aGlzLnN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgdGhpcy5hbGxMb2dHcm91cHMuc3BsaWNlKDAsIHRoaXMuYWxsTG9nR3JvdXBzLmxlbmd0aCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFkZHMgQ2xvdWRXYXRjaCBsb2cgZ3JvdXBzIHRvIHJlYWQgbG9nIGV2ZW50cyBmcm9tLlxuICAgKiBTaW5jZSB3ZSBjb3VsZCBiZSB3YXRjaGluZyBtdWx0aXBsZSBsb2dzIGdyb3VwcyB3ZSBuZWVkIGEgZnJpZW5kbHlcbiAgICogbmFtZSBmb3IgdG8gYXNzb2NpYXRlIHRoZSBsb2cgZ3JvdXAgdG8gbWFrZSBpdCBlYXNpZXJcbiAgICogZm9yIHRoZSB1c2VyIHRvIGlkZW50aWZ5IHdoaWNoIGxvZyBncm91cHMgYXJlIGJlaW5nIG1vbml0b3JlZFxuICAgKiBAcGFyYW0gZnJpZW5kbHlSZXNvdXJjZU5hbWUgVGhlIGZyaWVuZGx5IG5hbWUgb2YgdGhlIHJlc291cmNlIHRoYXQgaXMgYmVpbmcgbW9uaXRvcmVkXG4gICAqIEBwYXJhbSBsb2dHcm91cE5hbWUgVGhlIGxvZyBncm91cCB0byByZWFkIGV2ZW50cyBmcm9tXG4gICAqL1xuICBhZGRMb2dHcm91cHMgPSAoZnJpZW5kbHlSZXNvdXJjZU5hbWU6IHN0cmluZywgbG9nR3JvdXBOYW1lOiBzdHJpbmcpOiB2b2lkID0+IHtcbiAgICB0aGlzLmFsbExvZ0dyb3Vwcy5wdXNoKHtcbiAgICAgIGxvZ0dyb3VwTmFtZSxcbiAgICAgIHN0YXJ0VGltZTogdGhpcy5zdGFydFRpbWUsXG4gICAgfSk7XG4gICAgdGhpcy5sb2dHcm91cEV2ZW50RGlzcGxheVtsb2dHcm91cE5hbWVdID0ge1xuICAgICAgZnJpZW5kbHlOYW1lOiBmcmllbmRseVJlc291cmNlTmFtZSxcbiAgICAgIGNvbG9yOiB0aGlzLmdldE5leHRDb2xvckZvckxvZ0dyb3VwKCksXG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgICogUGljayB0aGUgbmV4dCBjb2xvciBpbiB0aGUgb2JqZWN0IGBjb2xvcnNgIGluIHJvdW5kIHJvYmluIGZhc2hpb25cbiAgICovXG4gIHByaXZhdGUgZ2V0TmV4dENvbG9yRm9yTG9nR3JvdXAgPSAoKSA9PiB7XG4gICAgcmV0dXJuIGNvbG9yTmFtZXNbXG4gICAgICB0aGlzLmFsbExvZ0dyb3Vwcy5sZW5ndGggJSBjb2xvck5hbWVzLmxlbmd0aFxuICAgIF0gYXMgQ29sb3JOYW1lO1xuICB9O1xuXG4gIHByaXZhdGUgc2NoZWR1bGVOZXh0VGljayA9IChzbGVlcDogbnVtYmVyKTogdm9pZCA9PiB7XG4gICAgc2V0VGltZW91dCgoKSA9PiB2b2lkIHRoaXMudGljaygpLCBzbGVlcCk7XG4gIH07XG5cbiAgcHJpdmF0ZSB0aWNrID0gYXN5bmMgKCk6IFByb21pc2U8dm9pZD4gPT4ge1xuICAgIGlmICghdGhpcy5hY3RpdmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGV2ZW50cyA9IGF3YWl0IHRoaXMucmVhZE5ld0V2ZW50cygpO1xuICAgICAgZXZlbnRzLmZvckVhY2goKGV2ZW50OiBDbG91ZFdhdGNoTG9nRXZlbnQpID0+IHtcbiAgICAgICAgdGhpcy5wcmludChldmVudCk7XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgcHJpbnRlci5sb2coXG4gICAgICAgIGAke2Zvcm1hdC5lcnJvcihcbiAgICAgICAgICAnRXJyb3Igc3RyZWFtaW5nIGxvZ3MgZnJvbSBDbG91ZFdhdGNoLidcbiAgICAgICAgKX0gJHtmb3JtYXQuZXJyb3IoZXJyb3IpfWAsXG4gICAgICAgIExvZ0xldmVsLkVSUk9SXG4gICAgICApO1xuICAgICAgcHJpbnRlci5sb2coJ0xvZ3Mgc3RyZWFtaW5nIGhhcyBiZWVuIHBhdXNlZC4nKTtcbiAgICAgIHRoaXMucGF1c2UoKTtcbiAgICB9XG5cbiAgICB0aGlzLnNjaGVkdWxlTmV4dFRpY2soU0xFRVBfTVMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZWFkcyBhbGwgbmV3IGxvZyBldmVudHMgZnJvbSBhIHNldCBvZiBDbG91ZFdhdGNoIExvZyBHcm91cHMgaW4gcGFyYWxsZWxcbiAgICovXG4gIHByaXZhdGUgcmVhZE5ld0V2ZW50cyA9IGFzeW5jICgpOiBQcm9taXNlPEFycmF5PENsb3VkV2F0Y2hMb2dFdmVudD4+ID0+IHtcbiAgICBjb25zdCBwcm9taXNlczogQXJyYXk8UHJvbWlzZTxBcnJheTxDbG91ZFdhdGNoTG9nRXZlbnQ+Pj4gPSBbXTtcbiAgICBmb3IgKGNvbnN0IGxvZ0dyb3VwIG9mIHRoaXMuYWxsTG9nR3JvdXBzKSB7XG4gICAgICBwcm9taXNlcy5wdXNoKHRoaXMucmVhZEV2ZW50c0Zyb21Mb2dHcm91cChsb2dHcm91cCkpO1xuICAgIH1cbiAgICByZXR1cm4gKGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKSkuZmxhdCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBQcmludCBvdXQgb25lIENsb3VkV2F0Y2ggZXZlbnQgdXNpbmcgdGhlIGxvY2FsIHByaW50ZXIuXG4gICAqL1xuICBwcml2YXRlIHByaW50ID0gKGV2ZW50OiBDbG91ZFdhdGNoTG9nRXZlbnQpOiB2b2lkID0+IHtcbiAgICBjb25zdCBjbG91ZFdhdGNoRXZlbnREaXNwbGF5ID1cbiAgICAgIHRoaXMubG9nR3JvdXBFdmVudERpc3BsYXlbZXZlbnQubG9nR3JvdXBOYW1lXTtcbiAgICBpZiAoIWNsb3VkV2F0Y2hFdmVudERpc3BsYXkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5lbmFibGVDb2xvcnMpIHtcbiAgICAgIHRoaXMucHJpbnRlci5wcmludChcbiAgICAgICAgYFske2Zvcm1hdC5jb2xvcihcbiAgICAgICAgICBjbG91ZFdhdGNoRXZlbnREaXNwbGF5LmZyaWVuZGx5TmFtZSxcbiAgICAgICAgICBjbG91ZFdhdGNoRXZlbnREaXNwbGF5LmNvbG9yXG4gICAgICAgICl9XSAke2Zvcm1hdC5ub3RlKFxuICAgICAgICAgIGV2ZW50LnRpbWVzdGFtcC50b0xvY2FsZVRpbWVTdHJpbmcoKVxuICAgICAgICApfSAke2V2ZW50Lm1lc3NhZ2UudHJpbSgpfWBcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucHJpbnRlci5wcmludChcbiAgICAgICAgYFske1xuICAgICAgICAgIGNsb3VkV2F0Y2hFdmVudERpc3BsYXkuZnJpZW5kbHlOYW1lXG4gICAgICAgIH1dICR7ZXZlbnQudGltZXN0YW1wLnRvTG9jYWxlVGltZVN0cmluZygpfSAke2V2ZW50Lm1lc3NhZ2UudHJpbSgpfWBcbiAgICAgICk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZWFkcyBhbGwgbmV3IGxvZyBldmVudHMgZnJvbSBhIENsb3VkV2F0Y2ggTG9nIEdyb3VwXG4gICAqIHN0YXJ0aW5nIGF0IGVpdGhlciB0aGUgdGltZSB0aGUgbGFzdCBkZXBsb3ltZW50IHdhcyB0cmlnZ2VyZWQgb3JcbiAgICogd2hlbiB0aGUgbGFzdCBldmVudCB3YXMgcmVhZCBvbiB0aGUgcHJldmlvdXMgdGlja1xuICAgKi9cbiAgcHJpdmF0ZSByZWFkRXZlbnRzRnJvbUxvZ0dyb3VwID0gYXN5bmMgKFxuICAgIGNsb3VkV2F0Y2hMb2dzVG9Nb25pdG9yOiBMb2dHcm91cFN0cmVhbWluZ0N1cnNvclxuICApOiBQcm9taXNlPEFycmF5PENsb3VkV2F0Y2hMb2dFdmVudD4+ID0+IHtcbiAgICBjb25zdCBldmVudHM6IENsb3VkV2F0Y2hMb2dFdmVudFtdID0gW107XG5cbiAgICAvLyBsb2cgZXZlbnRzIGZyb20gc29tZSBzZXJ2aWNlIGFyZSBpbmdlc3RlZCBmYXN0ZXIgdGhhbiBvdGhlcnNcbiAgICAvLyBzbyB3ZSBuZWVkIHRvIHRyYWNrIHRoZSBzdGFydC9lbmQgdGltZSBmb3IgZWFjaCBsb2cgZ3JvdXAgaW5kaXZpZHVhbGx5XG4gICAgLy8gdG8gbWFrZSBzdXJlIHRoYXQgd2UgcHJvY2VzcyBhbGwgZXZlbnRzIGZyb20gZWFjaCBsb2cgZ3JvdXAuXG4gICAgLy8gZW5kVGltZSB0cmFja3MgdGhlIGxhdGVzdCBldmVudCByZWNlaXZlZFxuICAgIGNvbnN0IHN0YXJ0VGltZSA9IGNsb3VkV2F0Y2hMb2dzVG9Nb25pdG9yLnN0YXJ0VGltZSA/PyB0aGlzLnN0YXJ0VGltZTtcbiAgICBsZXQgZW5kVGltZSA9IHN0YXJ0VGltZTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmNsb3VkV2F0Y2hMb2dzQ2xpZW50LnNlbmQoXG4gICAgICAgIG5ldyBGaWx0ZXJMb2dFdmVudHNDb21tYW5kKHtcbiAgICAgICAgICBsb2dHcm91cE5hbWU6IGNsb3VkV2F0Y2hMb2dzVG9Nb25pdG9yLmxvZ0dyb3VwTmFtZSxcbiAgICAgICAgICBsaW1pdDogMTAwLFxuICAgICAgICAgIHN0YXJ0VGltZSxcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICBjb25zdCBmaWx0ZXJlZEV2ZW50cyA9IHJlc3BvbnNlLmV2ZW50cyA/PyBbXTtcblxuICAgICAgZm9yIChjb25zdCBldmVudCBvZiBmaWx0ZXJlZEV2ZW50cykge1xuICAgICAgICBpZiAoZXZlbnQubWVzc2FnZSkge1xuICAgICAgICAgIGV2ZW50cy5wdXNoKHtcbiAgICAgICAgICAgIG1lc3NhZ2U6IGV2ZW50Lm1lc3NhZ2UsXG4gICAgICAgICAgICBsb2dHcm91cE5hbWU6IGNsb3VkV2F0Y2hMb2dzVG9Nb25pdG9yLmxvZ0dyb3VwTmFtZSxcbiAgICAgICAgICAgIHRpbWVzdGFtcDogZXZlbnQudGltZXN0YW1wID8gbmV3IERhdGUoZXZlbnQudGltZXN0YW1wKSA6IG5ldyBEYXRlKCksXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBpZiAoZXZlbnQudGltZXN0YW1wICYmIGVuZFRpbWUgPCBldmVudC50aW1lc3RhbXApIHtcbiAgICAgICAgICAgIGVuZFRpbWUgPSBldmVudC50aW1lc3RhbXA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBBcyBsb25nIGFzIHRoZXJlIGFyZSBfYW55XyBldmVudHMgaW4gdGhlIGxvZyBncm91cCBgZmlsdGVyTG9nRXZlbnRzYCB3aWxsIHJldHVybiBhIG5leHRUb2tlbi5cbiAgICAgIC8vIFRoaXMgaXMgdHJ1ZSBldmVuIGlmIHRoZXNlIGV2ZW50cyBhcmUgYmVmb3JlIGBzdGFydFRpbWVgLiBTbyBpZiB3ZSBoYXZlIDEwMCBldmVudHMgYW5kIGEgbmV4dFRva2VuXG4gICAgICAvLyB0aGVuIGFzc3VtZSB0aGF0IHdlIGhhdmUgaGl0IHRoZSBsaW1pdCBhbmQgbGV0IHRoZSB1c2VyIGtub3cgc29tZSBtZXNzYWdlcyBoYXZlIGJlZW4gc3VwcHJlc3NlZC5cbiAgICAgIC8vIFdlIGFyZSBlc3NlbnRpYWxseSBzaG93aW5nIHRoZW0gYSBzYW1wbGluZyAoMTAwMDAgZXZlbnRzIHByaW50ZWQgb3V0IGlzIG5vdCB2ZXJ5IHVzZWZ1bClcbiAgICAgIGlmIChmaWx0ZXJlZEV2ZW50cy5sZW5ndGggPT09IDEwMCAmJiByZXNwb25zZS5uZXh0VG9rZW4pIHtcbiAgICAgICAgZXZlbnRzLnB1c2goe1xuICAgICAgICAgIG1lc3NhZ2U6XG4gICAgICAgICAgICAnPj4+IGBzYW5kYm94YCBzaG93cyBvbmx5IHRoZSBmaXJzdCAxMDAgbG9nIG1lc3NhZ2VzIC0gdGhlIHJlc3QgaGF2ZSBiZWVuIHRydW5jYXRlZC4uLicsXG4gICAgICAgICAgbG9nR3JvdXBOYW1lOiBjbG91ZFdhdGNoTG9nc1RvTW9uaXRvci5sb2dHcm91cE5hbWUsXG4gICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZShlbmRUaW1lKSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gd2l0aCBMYW1iZGEgZnVuY3Rpb25zIHRoZSBMb2cgR3JvdXAgaXMgbm90IGNyZWF0ZWRcbiAgICAgIC8vIHVudGlsIHNvbWV0aGluZyBpcyBsb2dnZWQsIHNvIGp1c3Qga2VlcCBwb2xsaW5nIHVudGlsXG4gICAgICAvLyB0aGVyZSBpcyBzb21ldGhpbmcgdG8gZmluZFxuICAgICAgaWYgKGUgJiYgZSBpbnN0YW5jZW9mIFJlc291cmNlTm90Rm91bmRFeGNlcHRpb24pIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgY2xvdWRXYXRjaExvZ3NUb01vbml0b3Iuc3RhcnRUaW1lID0gZW5kVGltZSArIDE7XG4gICAgcmV0dXJuIGV2ZW50cztcbiAgfTtcbn1cbiJdfQ==