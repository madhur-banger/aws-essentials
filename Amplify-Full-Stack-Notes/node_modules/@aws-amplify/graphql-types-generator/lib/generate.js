"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateForTarget = exports.generateFromString = void 0;
const graphql_1 = require("graphql");
const fs = require("fs-extra");
const path = require("path");
const rimraf = require("rimraf");
const loading_1 = require("./loading");
const validation_1 = require("./validation");
const compiler_1 = require("./compiler");
const legacyIR_1 = require("./compiler/legacyIR");
const serializeToJSON_1 = require("./serializeToJSON");
const CodeGenerator_1 = require("./utilities/CodeGenerator");
const swift_1 = require("./swift");
const typescript_1 = require("./typescript");
const flow_1 = require("./flow");
const flow_modern_1 = require("./flow-modern");
const scala_1 = require("./scala");
const angular_1 = require("./angular");
const complextypes_1 = require("./utilities/complextypes");
const getOutputFileName_1 = require("./utilities/getOutputFileName");
function generate(inputPaths, schemaPath, outputPath, only, target, tagName, options) {
    generateFromFile(inputPaths, schemaPath, outputPath, only, target, tagName, options);
}
exports.default = generate;
function generateFromFile(inputPaths, schemaPath, outputPath, only, target, tagName, options) {
    const schema = (0, loading_1.loadSchema)(schemaPath);
    const document = (0, loading_1.loadAndMergeQueryDocuments)(inputPaths, tagName);
    (0, validation_1.validateQueryDocument)(schema, document);
    const multipleFiles = fs.existsSync(outputPath) && fs.statSync(outputPath).isDirectory();
    const output = generateForTarget(schema, document, only, target, multipleFiles, options);
    if (outputPath) {
        if (target === 'flow-modern') {
            const filesByOutputDirectory = {};
            Object.entries(output).forEach(([filePath, file]) => {
                const outputDirectory = path.dirname(filePath);
                if (!filesByOutputDirectory[outputDirectory]) {
                    filesByOutputDirectory[outputDirectory] = {
                        [path.basename(filePath)]: file,
                    };
                }
                else {
                    filesByOutputDirectory[outputDirectory][path.basename(filePath)] = file;
                }
            });
            Object.keys(filesByOutputDirectory).forEach(outputDirectory => {
                writeGeneratedFiles(filesByOutputDirectory[outputDirectory], outputDirectory);
            });
        }
        else if ((0, CodeGenerator_1.isBasicGeneratedFileMap)(output)) {
            writeGeneratedFiles(output, outputPath);
        }
        else {
            fs.outputFileSync(outputPath, output);
        }
    }
    else {
        console.log(output);
    }
}
function generateFromString(schema, introspection, queryDocuments, target, multipleSwiftFiles, options) {
    if (typeof queryDocuments === 'string' && multipleSwiftFiles) {
        throw new Error('Query documents must be of type Source[] when generating multiple Swift files.');
    }
    const graphqlSchema = (0, loading_1.parseSchema)(schema, introspection);
    const queryDocumentSources = typeof queryDocuments === 'string' ? [new graphql_1.Source(queryDocuments)] : queryDocuments;
    const document = (0, loading_1.parseAndMergeQueryDocuments)(queryDocumentSources);
    (0, validation_1.validateQueryDocument)(graphqlSchema, document);
    const output = generateForTarget(graphqlSchema, document, '', target, multipleSwiftFiles, options);
    if ((0, CodeGenerator_1.isBasicGeneratedFileMap)(output)) {
        return Object.entries(output)
            .map(([filepath, file]) => [filepath, file.output])
            .reduce((acc, [filepath, fileOutput]) => (Object.assign(Object.assign({}, acc), { [filepath]: fileOutput })), {});
    }
    const filename = (0, getOutputFileName_1.getOutputFileName)('', target);
    return { [filename]: output };
}
exports.generateFromString = generateFromString;
function generateForTarget(schema, document, only, target, multipleFiles, options) {
    if (target === 'swift') {
        return generateTypesSwift(schema, document, only, multipleFiles, options);
    }
    if (target === 'flow-modern') {
        return generateTypesFlowModern(schema, document, options);
    }
    const context = (0, legacyIR_1.compileToLegacyIR)(schema, document, options);
    switch (target) {
        case 'json':
            return (0, serializeToJSON_1.default)(context);
        case 'ts':
        case 'typescript':
            return (0, typescript_1.generateSource)(context);
        case 'flow':
            return (0, flow_1.generateSource)(context);
        case 'scala':
            return (0, scala_1.generateSource)(context, options);
        case 'angular':
            return (0, angular_1.generateSource)(context, { isAngularV6: options.amplifyJsLibraryVersion === 6 });
        default:
            throw new Error(`${target} is not supported.`);
    }
}
exports.generateForTarget = generateForTarget;
function generateTypesSwift(schema, document, only, multipleFiles, options) {
    options.addTypename = true;
    const context = (0, compiler_1.compileToIR)(schema, document, options);
    if (options.complexObjectSupport === 'auto') {
        options.addS3Wrapper = context.typesUsed.some(typesUsed => (0, complextypes_1.hasS3Fields)(typesUsed));
    }
    else if (options.complexObjectSupport === 'yes') {
        options.addS3Wrapper = true;
    }
    else {
        options.addS3Wrapper = false;
    }
    const generator = (0, swift_1.generateSource)(context, multipleFiles, only);
    if (multipleFiles) {
        return generator.generatedFiles;
    }
    return generator.output;
}
function generateTypesFlowModern(schema, document, options) {
    const context = (0, compiler_1.compileToIR)(schema, document, options);
    const generatedFiles = (0, flow_modern_1.generateSource)(context);
    return generatedFiles;
}
function writeGeneratedFiles(generatedFiles, outputDirectory) {
    rimraf.sync(outputDirectory);
    fs.mkdirSync(outputDirectory);
    for (const [fileName, generatedFile] of Object.entries(generatedFiles)) {
        fs.writeFileSync(path.join(outputDirectory, fileName), generatedFile.output);
    }
}
//# sourceMappingURL=generate.js.map