"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseAndMergeQueryDocuments = exports.loadAndMergeQueryDocuments = exports.extractDocumentFromJavascript = exports.parseSchema = exports.loadSchema = void 0;
const fs = require("fs");
const graphql_1 = require("graphql");
const errors_1 = require("./errors");
const path_1 = require("path");
function loadSchema(schemaPath) {
    if ((0, path_1.extname)(schemaPath) === '.json') {
        return loadIntrospectionSchema(schemaPath);
    }
    return loadSDLSchema(schemaPath);
}
exports.loadSchema = loadSchema;
function parseSchema(schema, introspection = false) {
    if (introspection) {
        return parseIntrospectionSchema(schema);
    }
    return parseSDLSchema(schema);
}
exports.parseSchema = parseSchema;
function loadIntrospectionSchema(schemaPath) {
    if (!fs.existsSync(schemaPath)) {
        throw new errors_1.ToolError(`Cannot find GraphQL schema file: ${schemaPath}`);
    }
    let schemaData;
    try {
        schemaData = require(schemaPath);
    }
    catch (_a) {
        schemaData = JSON.parse(fs.readFileSync(schemaPath, 'utf8'));
    }
    return buildIntrospectionSchema(schemaData);
}
function parseIntrospectionSchema(schema) {
    return buildIntrospectionSchema(JSON.parse(schema));
}
function buildIntrospectionSchema(schemaData) {
    if (!schemaData.data && !schemaData.__schema) {
        throw new errors_1.ToolError('GraphQL schema file should contain a valid GraphQL introspection query result');
    }
    return (0, graphql_1.buildClientSchema)(schemaData.data ? schemaData.data : schemaData);
}
function loadSDLSchema(schemaPath) {
    const authDirectivePath = (0, path_1.normalize)((0, path_1.join)(__dirname, '..', 'awsAppSyncDirectives.graphql'));
    const doc = loadAndMergeQueryDocuments([authDirectivePath, schemaPath]);
    return (0, graphql_1.buildASTSchema)(doc);
}
function parseSDLSchema(schema) {
    const authDirectivePath = (0, path_1.normalize)((0, path_1.join)(__dirname, '..', 'awsAppSyncDirectives.graphql'));
    const authDirective = fs.readFileSync(authDirectivePath, 'utf8');
    const doc = parseAndMergeQueryDocuments([new graphql_1.Source(authDirective, authDirectivePath), new graphql_1.Source(schema)]);
    return (0, graphql_1.buildASTSchema)(doc);
}
function extractDocumentFromJavascript(content, tagName = 'gql') {
    const re = new RegExp(tagName + '\\s*`([^`/]*)`', 'g');
    let match;
    const matches = [];
    while ((match = re.exec(content))) {
        const doc = match[1].replace(/\${[^}]*}/g, '');
        matches.push(doc);
    }
    const doc = matches.join('\n');
    return doc.length ? doc : null;
}
exports.extractDocumentFromJavascript = extractDocumentFromJavascript;
function loadAndMergeQueryDocuments(inputPaths, tagName = 'gql') {
    const sources = inputPaths
        .map(inputPath => {
        const body = fs.readFileSync(inputPath, 'utf8');
        if (!body) {
            return null;
        }
        if (inputPath.endsWith('.jsx') || inputPath.endsWith('.js') || inputPath.endsWith('.tsx') || inputPath.endsWith('.ts')) {
            const doc = extractDocumentFromJavascript(body.toString(), tagName);
            return doc ? new graphql_1.Source(doc, inputPath) : null;
        }
        return new graphql_1.Source(body, inputPath);
    })
        .filter((source) => Boolean(source));
    return parseAndMergeQueryDocuments(sources);
}
exports.loadAndMergeQueryDocuments = loadAndMergeQueryDocuments;
function parseAndMergeQueryDocuments(sources) {
    const parsedSources = sources.map(source => {
        try {
            return (0, graphql_1.parse)(source);
        }
        catch (err) {
            if ('name' in source) {
                const relativePathToInput = (0, path_1.relative)(process.cwd(), source.name);
                throw new errors_1.ToolError(`Could not parse graphql operations in ${relativePathToInput}\n  Failed on : ${source.body}`);
            }
            throw new errors_1.ToolError(`Could not parse graphql operations. Failed on : ${source}`);
        }
    });
    return (0, graphql_1.concatAST)(parsedSources);
}
exports.parseAndMergeQueryDocuments = parseAndMergeQueryDocuments;
//# sourceMappingURL=loading.js.map