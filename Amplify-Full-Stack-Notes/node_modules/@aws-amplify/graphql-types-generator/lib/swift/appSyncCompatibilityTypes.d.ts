export declare const appSyncCompatibilityTypesCode = "\nimport Foundation\n\npublic protocol GraphQLInputValue {\n}\n\npublic struct GraphQLVariable {\n  let name: String\n  \n  public init(_ name: String) {\n    self.name = name\n  }\n}\n\nextension GraphQLVariable: GraphQLInputValue {\n}\n\nextension JSONEncodable {\n  public func evaluate(with variables: [String: JSONEncodable]?) throws -> Any {\n    return jsonValue\n  }\n}\n\npublic typealias GraphQLMap = [String: JSONEncodable?]\n\nextension Dictionary where Key == String, Value == JSONEncodable? {\n  public var withNilValuesRemoved: Dictionary<String, JSONEncodable> {\n    var filtered = Dictionary<String, JSONEncodable>(minimumCapacity: count)\n    for (key, value) in self {\n      if value != nil {\n        filtered[key] = value\n      }\n    }\n    return filtered\n  }\n}\n\npublic protocol GraphQLMapConvertible: JSONEncodable {\n  var graphQLMap: GraphQLMap { get }\n}\n\npublic extension GraphQLMapConvertible {\n  var jsonValue: Any {\n    return graphQLMap.withNilValuesRemoved.jsonValue\n  }\n}\n\npublic typealias GraphQLID = String\n\npublic protocol APISwiftGraphQLOperation: AnyObject {\n  \n  static var operationString: String { get }\n  static var requestString: String { get }\n  static var operationIdentifier: String? { get }\n  \n  var variables: GraphQLMap? { get }\n  \n  associatedtype Data: GraphQLSelectionSet\n}\n\npublic extension APISwiftGraphQLOperation {\n  static var requestString: String {\n    return operationString\n  }\n\n  static var operationIdentifier: String? {\n    return nil\n  }\n\n  var variables: GraphQLMap? {\n    return nil\n  }\n}\n\npublic protocol GraphQLQuery: APISwiftGraphQLOperation {}\n\npublic protocol GraphQLMutation: APISwiftGraphQLOperation {}\n\npublic protocol GraphQLSubscription: APISwiftGraphQLOperation {}\n\npublic protocol GraphQLFragment: GraphQLSelectionSet {\n  static var possibleTypes: [String] { get }\n}\n\npublic typealias Snapshot = [String: Any?]\n\npublic protocol GraphQLSelectionSet: Decodable {\n  static var selections: [GraphQLSelection] { get }\n  \n  var snapshot: Snapshot { get }\n  init(snapshot: Snapshot)\n}\n\nextension GraphQLSelectionSet {\n    public init(from decoder: Decoder) throws {\n        if let jsonObject = try? APISwiftJSONValue(from: decoder) {\n            let encoder = JSONEncoder()\n            let jsonData = try encoder.encode(jsonObject)\n            let decodedDictionary = try JSONSerialization.jsonObject(with: jsonData, options: []) as! [String: Any]\n            let optionalDictionary = decodedDictionary.mapValues { $0 as Any? }\n\n            self.init(snapshot: optionalDictionary)\n        } else {\n            self.init(snapshot: [:])\n        }\n    }\n}\n\nenum APISwiftJSONValue: Codable {\n    case array([APISwiftJSONValue])\n    case boolean(Bool)\n    case number(Double)\n    case object([String: APISwiftJSONValue])\n    case string(String)\n    case null\n    \n    init(from decoder: Decoder) throws {\n        let container = try decoder.singleValueContainer()\n        \n        if let value = try? container.decode([String: APISwiftJSONValue].self) {\n            self = .object(value)\n        } else if let value = try? container.decode([APISwiftJSONValue].self) {\n            self = .array(value)\n        } else if let value = try? container.decode(Double.self) {\n            self = .number(value)\n        } else if let value = try? container.decode(Bool.self) {\n            self = .boolean(value)\n        } else if let value = try? container.decode(String.self) {\n            self = .string(value)\n        } else {\n            self = .null\n        }\n    }\n    \n    func encode(to encoder: Encoder) throws {\n        var container = encoder.singleValueContainer()\n        \n        switch self {\n        case .array(let value):\n            try container.encode(value)\n        case .boolean(let value):\n            try container.encode(value)\n        case .number(let value):\n            try container.encode(value)\n        case .object(let value):\n            try container.encode(value)\n        case .string(let value):\n            try container.encode(value)\n        case .null:\n            try container.encodeNil()\n        }\n    }\n}\n\npublic protocol GraphQLSelection {\n}\n\npublic struct GraphQLField: GraphQLSelection {\n  let name: String\n  let alias: String?\n  let arguments: [String: GraphQLInputValue]?\n  \n  var responseKey: String {\n    return alias ?? name\n  }\n  \n  let type: GraphQLOutputType\n  \n  public init(_ name: String, alias: String? = nil, arguments: [String: GraphQLInputValue]? = nil, type: GraphQLOutputType) {\n    self.name = name\n    self.alias = alias\n    \n    self.arguments = arguments\n    \n    self.type = type\n  }\n}\n\npublic indirect enum GraphQLOutputType {\n  case scalar(JSONDecodable.Type)\n  case object([GraphQLSelection])\n  case nonNull(GraphQLOutputType)\n  case list(GraphQLOutputType)\n  \n  var namedType: GraphQLOutputType {\n    switch self {\n    case .nonNull(let innerType), .list(let innerType):\n      return innerType.namedType\n    case .scalar, .object:\n      return self\n    }\n  }\n}\n\npublic struct GraphQLBooleanCondition: GraphQLSelection {\n  let variableName: String\n  let inverted: Bool\n  let selections: [GraphQLSelection]\n  \n  public init(variableName: String, inverted: Bool, selections: [GraphQLSelection]) {\n    self.variableName = variableName\n    self.inverted = inverted;\n    self.selections = selections;\n  }\n}\n\npublic struct GraphQLTypeCondition: GraphQLSelection {\n  let possibleTypes: [String]\n  let selections: [GraphQLSelection]\n  \n  public init(possibleTypes: [String], selections: [GraphQLSelection]) {\n    self.possibleTypes = possibleTypes\n    self.selections = selections;\n  }\n}\n\npublic struct GraphQLFragmentSpread: GraphQLSelection {\n  let fragment: GraphQLFragment.Type\n  \n  public init(_ fragment: GraphQLFragment.Type) {\n    self.fragment = fragment\n  }\n}\n\npublic struct GraphQLTypeCase: GraphQLSelection {\n  let variants: [String: [GraphQLSelection]]\n  let `default`: [GraphQLSelection]\n  \n  public init(variants: [String: [GraphQLSelection]], default: [GraphQLSelection]) {\n    self.variants = variants\n    self.default = `default`;\n  }\n}\n\npublic typealias JSONObject = [String: Any]\n\npublic protocol JSONDecodable {\n  init(jsonValue value: Any) throws\n}\n\npublic protocol JSONEncodable: GraphQLInputValue {\n  var jsonValue: Any { get }\n}\n\npublic enum JSONDecodingError: Error, LocalizedError {\n  case missingValue\n  case nullValue\n  case wrongType\n  case couldNotConvert(value: Any, to: Any.Type)\n  \n  public var errorDescription: String? {\n    switch self {\n    case .missingValue:\n      return \"Missing value\"\n    case .nullValue:\n      return \"Unexpected null value\"\n    case .wrongType:\n      return \"Wrong type\"\n    case .couldNotConvert(let value, let expectedType):\n      return \"Could not convert \\\"\\(value)\\\" to \\(expectedType)\"\n    }\n  }\n}\n\nextension String: JSONDecodable, JSONEncodable {\n  public init(jsonValue value: Any) throws {\n    guard let string = value as? String else {\n      throw JSONDecodingError.couldNotConvert(value: value, to: String.self)\n    }\n    self = string\n  }\n\n  public var jsonValue: Any {\n    return self\n  }\n}\n\nextension Int: JSONDecodable, JSONEncodable {\n  public init(jsonValue value: Any) throws {\n    guard let number = value as? NSNumber else {\n      throw JSONDecodingError.couldNotConvert(value: value, to: Int.self)\n    }\n    self = number.intValue\n  }\n\n  public var jsonValue: Any {\n    return self\n  }\n}\n\nextension Float: JSONDecodable, JSONEncodable {\n  public init(jsonValue value: Any) throws {\n    guard let number = value as? NSNumber else {\n      throw JSONDecodingError.couldNotConvert(value: value, to: Float.self)\n    }\n    self = number.floatValue\n  }\n\n  public var jsonValue: Any {\n    return self\n  }\n}\n\nextension Double: JSONDecodable, JSONEncodable {\n  public init(jsonValue value: Any) throws {\n    guard let number = value as? NSNumber else {\n      throw JSONDecodingError.couldNotConvert(value: value, to: Double.self)\n    }\n    self = number.doubleValue\n  }\n\n  public var jsonValue: Any {\n    return self\n  }\n}\n\nextension Bool: JSONDecodable, JSONEncodable {\n  public init(jsonValue value: Any) throws {\n    guard let bool = value as? Bool else {\n        throw JSONDecodingError.couldNotConvert(value: value, to: Bool.self)\n    }\n    self = bool\n  }\n\n  public var jsonValue: Any {\n    return self\n  }\n}\n\nextension RawRepresentable where RawValue: JSONDecodable {\n  public init(jsonValue value: Any) throws {\n    let rawValue = try RawValue(jsonValue: value)\n    if let tempSelf = Self(rawValue: rawValue) {\n      self = tempSelf\n    } else {\n      throw JSONDecodingError.couldNotConvert(value: value, to: Self.self)\n    }\n  }\n}\n\nextension RawRepresentable where RawValue: JSONEncodable {\n  public var jsonValue: Any {\n    return rawValue.jsonValue\n  }\n}\n\nextension Optional where Wrapped: JSONDecodable {\n  public init(jsonValue value: Any) throws {\n    if value is NSNull {\n      self = .none\n    } else {\n      self = .some(try Wrapped(jsonValue: value))\n    }\n  }\n}\n\nextension Optional: JSONEncodable {\n  public var jsonValue: Any {\n    switch self {\n    case .none:\n      return NSNull()\n    case .some(let wrapped as JSONEncodable):\n      return wrapped.jsonValue\n    default:\n      fatalError(\"Optional is only JSONEncodable if Wrapped is\")\n    }\n  }\n}\n\nextension Dictionary: JSONEncodable {\n  public var jsonValue: Any {\n    return jsonObject\n  }\n  \n  public var jsonObject: JSONObject {\n    var jsonObject = JSONObject(minimumCapacity: count)\n    for (key, value) in self {\n      if case let (key as String, value as JSONEncodable) = (key, value) {\n        jsonObject[key] = value.jsonValue\n      } else {\n        fatalError(\"Dictionary is only JSONEncodable if Value is (and if Key is String)\")\n      }\n    }\n    return jsonObject\n  }\n}\n\nextension Array: JSONEncodable {\n  public var jsonValue: Any {\n    return map() { element -> (Any) in\n      if case let element as JSONEncodable = element {\n        return element.jsonValue\n      } else {\n        fatalError(\"Array is only JSONEncodable if Element is\")\n      }\n    }\n  }\n}\n\nextension URL: JSONDecodable, JSONEncodable {\n  public init(jsonValue value: Any) throws {\n    guard let string = value as? String else {\n      throw JSONDecodingError.couldNotConvert(value: value, to: URL.self)\n    }\n    self.init(string: string)!\n  }\n\n  public var jsonValue: Any {\n    return self.absoluteString\n  }\n}\n\nextension Dictionary {\n  static func += (lhs: inout Dictionary, rhs: Dictionary) {\n    lhs.merge(rhs) { (_, new) in new }\n  }\n}\n";
