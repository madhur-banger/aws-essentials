"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const aws_lambda_1 = require("aws-cdk-lib/aws-lambda");
const setup = require("./hotswap-test-setup");
const common_1 = require("../../../lib/api/hotswap/common");
const silent_1 = require("../../util/silent");
let mockUpdateLambdaCode;
let mockTagResource;
let mockUntagResource;
let hotswapMockSdkProvider;
beforeEach(() => {
    hotswapMockSdkProvider = setup.setupHotswapTests();
    mockUpdateLambdaCode = jest.fn().mockReturnValue({});
    mockTagResource = jest.fn();
    mockUntagResource = jest.fn();
    hotswapMockSdkProvider.stubLambda({
        updateFunctionCode: mockUpdateLambdaCode,
        tagResource: mockTagResource,
        untagResource: mockUntagResource,
    });
});
describe.each([common_1.HotswapMode.FALL_BACK, common_1.HotswapMode.HOTSWAP_ONLY])('these tests do not depend on the hotswap type', (hotswapMode) => {
    (0, silent_1.silentTest)('calls the updateLambdaCode() API when it receives only a code difference in a Lambda function (Inline Node.js code)', async () => {
        // GIVEN
        setup.setCurrentCfnStackTemplate({
            Resources: {
                Func: {
                    Type: 'AWS::Lambda::Function',
                    Properties: {
                        Code: {
                            ZipFile: 'exports.handler = () => {return true}',
                        },
                        Runtime: aws_lambda_1.Runtime.NODEJS_LATEST.name,
                        FunctionName: 'my-function',
                    },
                },
            },
        });
        const newCode = 'exports.handler = () => {return false}';
        const cdkStackArtifact = setup.cdkStackArtifactOf({
            template: {
                Resources: {
                    Func: {
                        Type: 'AWS::Lambda::Function',
                        Properties: {
                            Code: {
                                ZipFile: newCode,
                            },
                            Runtime: aws_lambda_1.Runtime.NODEJS_LATEST.name,
                            FunctionName: 'my-function',
                        },
                    },
                },
            },
        });
        // WHEN
        const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);
        // THEN
        expect(deployStackResult).not.toBeUndefined();
        expect(mockUpdateLambdaCode).toHaveBeenCalledWith({
            FunctionName: 'my-function',
            ZipFile: expect.any(Buffer),
        });
    });
    (0, silent_1.silentTest)('calls the updateLambdaCode() API when it receives only a code difference in a Lambda function (Inline Python code)', async () => {
        // GIVEN
        setup.setCurrentCfnStackTemplate({
            Resources: {
                Func: {
                    Type: 'AWS::Lambda::Function',
                    Properties: {
                        Code: {
                            ZipFile: 'def handler(event, context):\n  return True',
                        },
                        Runtime: 'python3.9',
                        FunctionName: 'my-function',
                    },
                },
            },
        });
        const cdkStackArtifact = setup.cdkStackArtifactOf({
            template: {
                Resources: {
                    Func: {
                        Type: 'AWS::Lambda::Function',
                        Properties: {
                            Code: {
                                ZipFile: 'def handler(event, context):\n  return False',
                            },
                            Runtime: 'python3.9',
                            FunctionName: 'my-function',
                        },
                    },
                },
            },
        });
        // WHEN
        const deployStackResult = await hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);
        // THEN
        expect(deployStackResult).not.toBeUndefined();
        expect(mockUpdateLambdaCode).toHaveBeenCalledWith({
            FunctionName: 'my-function',
            ZipFile: expect.any(Buffer),
        });
    });
    (0, silent_1.silentTest)('throw a CfnEvaluationException when it receives an unsupported function runtime', async () => {
        // GIVEN
        setup.setCurrentCfnStackTemplate({
            Resources: {
                Func: {
                    Type: 'AWS::Lambda::Function',
                    Properties: {
                        Code: {
                            ZipFile: 'def handler(event:, context:) true end',
                        },
                        Runtime: 'ruby2.7',
                        FunctionName: 'my-function',
                    },
                },
            },
        });
        const cdkStackArtifact = setup.cdkStackArtifactOf({
            template: {
                Resources: {
                    Func: {
                        Type: 'AWS::Lambda::Function',
                        Properties: {
                            Code: {
                                ZipFile: 'def handler(event:, context:) false end',
                            },
                            Runtime: 'ruby2.7',
                            FunctionName: 'my-function',
                        },
                    },
                },
            },
        });
        // WHEN
        const tryHotswap = hotswapMockSdkProvider.tryHotswapDeployment(hotswapMode, cdkStackArtifact);
        // THEN
        await expect(tryHotswap).rejects.toThrow('runtime ruby2.7 is unsupported, only node.js and python runtimes are currently supported.');
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGFtYmRhLWZ1bmN0aW9ucy1pbmxpbmUtaG90c3dhcC1kZXBsb3ltZW50cy50ZXN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsibGFtYmRhLWZ1bmN0aW9ucy1pbmxpbmUtaG90c3dhcC1kZXBsb3ltZW50cy50ZXN0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsdURBQWlEO0FBRWpELDhDQUE4QztBQUM5Qyw0REFBOEQ7QUFDOUQsOENBQStDO0FBRS9DLElBQUksb0JBQTRHLENBQUM7QUFDakgsSUFBSSxlQUFnRSxDQUFDO0FBQ3JFLElBQUksaUJBQW9FLENBQUM7QUFDekUsSUFBSSxzQkFBb0QsQ0FBQztBQUV6RCxVQUFVLENBQUMsR0FBRyxFQUFFO0lBQ2Qsc0JBQXNCLEdBQUcsS0FBSyxDQUFDLGlCQUFpQixFQUFFLENBQUM7SUFDbkQsb0JBQW9CLEdBQUcsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDLGVBQWUsQ0FBQyxFQUFFLENBQUMsQ0FBQztJQUNyRCxlQUFlLEdBQUcsSUFBSSxDQUFDLEVBQUUsRUFBRSxDQUFDO0lBQzVCLGlCQUFpQixHQUFHLElBQUksQ0FBQyxFQUFFLEVBQUUsQ0FBQztJQUM5QixzQkFBc0IsQ0FBQyxVQUFVLENBQUM7UUFDaEMsa0JBQWtCLEVBQUUsb0JBQW9CO1FBQ3hDLFdBQVcsRUFBRSxlQUFlO1FBQzVCLGFBQWEsRUFBRSxpQkFBaUI7S0FDakMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUM7QUFFSCxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsb0JBQVcsQ0FBQyxTQUFTLEVBQUUsb0JBQVcsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDLCtDQUErQyxFQUFFLENBQUMsV0FBVyxFQUFFLEVBQUU7SUFDaEksSUFBQSxtQkFBVSxFQUFDLHFIQUFxSCxFQUFFLEtBQUssSUFBSSxFQUFFO1FBQzNJLFFBQVE7UUFDUixLQUFLLENBQUMsMEJBQTBCLENBQUM7WUFDL0IsU0FBUyxFQUFFO2dCQUNU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QixVQUFVLEVBQUU7d0JBQ1YsSUFBSSxFQUFFOzRCQUNKLE9BQU8sRUFBRSx3Q0FBd0M7eUJBQ2xEO3dCQUNELE9BQU8sRUFBRSxTQUFTO3dCQUNsQixZQUFZLEVBQUUsYUFBYTtxQkFDNUI7aUJBQ0Y7YUFDRjtTQUNGLENBQUMsQ0FBQztRQUNILE1BQU0sZ0JBQWdCLEdBQUcsS0FBSyxDQUFDLGtCQUFrQixDQUFDO1lBQ2hELFFBQVEsRUFBRTtnQkFDUixTQUFTLEVBQUU7b0JBQ1QsSUFBSSxFQUFFO3dCQUNKLElBQUksRUFBRSx1QkFBdUI7d0JBQzdCLFVBQVUsRUFBRTs0QkFDVixJQUFJLEVBQUU7Z0NBQ0osT0FBTyxFQUFFLHlDQUF5Qzs2QkFDbkQ7NEJBQ0QsT0FBTyxFQUFFLFNBQVM7NEJBQ2xCLFlBQVksRUFBRSxhQUFhO3lCQUM1QjtxQkFDRjtpQkFDRjthQUNGO1NBQ0YsQ0FBQyxDQUFDO1FBRUgsT0FBTztRQUNQLE1BQU0sVUFBVSxHQUFHLHNCQUFzQixDQUFDLG9CQUFvQixDQUFDLFdBQVcsRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDO1FBRTlGLE9BQU87UUFDUCxNQUFNLE1BQU0sQ0FBQyxVQUFVLENBQUMsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLDJGQUEyRixDQUFDLENBQUM7SUFDeEksQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFJ1bnRpbWUgfSBmcm9tICdhd3MtY2RrLWxpYi9hd3MtbGFtYmRhJztcbmltcG9ydCB7IExhbWJkYSB9IGZyb20gJ2F3cy1zZGsnO1xuaW1wb3J0ICogYXMgc2V0dXAgZnJvbSAnLi9ob3Rzd2FwLXRlc3Qtc2V0dXAnO1xuaW1wb3J0IHsgSG90c3dhcE1vZGUgfSBmcm9tICcuLi8uLi8uLi9saWIvYXBpL2hvdHN3YXAvY29tbW9uJztcbmltcG9ydCB7IHNpbGVudFRlc3QgfSBmcm9tICcuLi8uLi91dGlsL3NpbGVudCc7XG5cbmxldCBtb2NrVXBkYXRlTGFtYmRhQ29kZTogKHBhcmFtczogTGFtYmRhLlR5cGVzLlVwZGF0ZUZ1bmN0aW9uQ29kZVJlcXVlc3QpID0+IExhbWJkYS5UeXBlcy5GdW5jdGlvbkNvbmZpZ3VyYXRpb247XG5sZXQgbW9ja1RhZ1Jlc291cmNlOiAocGFyYW1zOiBMYW1iZGEuVHlwZXMuVGFnUmVzb3VyY2VSZXF1ZXN0KSA9PiB7fTtcbmxldCBtb2NrVW50YWdSZXNvdXJjZTogKHBhcmFtczogTGFtYmRhLlR5cGVzLlVudGFnUmVzb3VyY2VSZXF1ZXN0KSA9PiB7fTtcbmxldCBob3Rzd2FwTW9ja1Nka1Byb3ZpZGVyOiBzZXR1cC5Ib3Rzd2FwTW9ja1Nka1Byb3ZpZGVyO1xuXG5iZWZvcmVFYWNoKCgpID0+IHtcbiAgaG90c3dhcE1vY2tTZGtQcm92aWRlciA9IHNldHVwLnNldHVwSG90c3dhcFRlc3RzKCk7XG4gIG1vY2tVcGRhdGVMYW1iZGFDb2RlID0gamVzdC5mbigpLm1vY2tSZXR1cm5WYWx1ZSh7fSk7XG4gIG1vY2tUYWdSZXNvdXJjZSA9IGplc3QuZm4oKTtcbiAgbW9ja1VudGFnUmVzb3VyY2UgPSBqZXN0LmZuKCk7XG4gIGhvdHN3YXBNb2NrU2RrUHJvdmlkZXIuc3R1YkxhbWJkYSh7XG4gICAgdXBkYXRlRnVuY3Rpb25Db2RlOiBtb2NrVXBkYXRlTGFtYmRhQ29kZSxcbiAgICB0YWdSZXNvdXJjZTogbW9ja1RhZ1Jlc291cmNlLFxuICAgIHVudGFnUmVzb3VyY2U6IG1vY2tVbnRhZ1Jlc291cmNlLFxuICB9KTtcbn0pO1xuXG5kZXNjcmliZS5lYWNoKFtIb3Rzd2FwTW9kZS5GQUxMX0JBQ0ssIEhvdHN3YXBNb2RlLkhPVFNXQVBfT05MWV0pKCd0aGVzZSB0ZXN0cyBkbyBub3QgZGVwZW5kIG9uIHRoZSBob3Rzd2FwIHR5cGUnLCAoaG90c3dhcE1vZGUpID0+IHtcbiAgc2lsZW50VGVzdCgnY2FsbHMgdGhlIHVwZGF0ZUxhbWJkYUNvZGUoKSBBUEkgd2hlbiBpdCByZWNlaXZlcyBvbmx5IGEgY29kZSBkaWZmZXJlbmNlIGluIGEgTGFtYmRhIGZ1bmN0aW9uIChJbmxpbmUgTm9kZS5qcyBjb2RlKScsIGFzeW5jICgpID0+IHtcbiAgICAvLyBHSVZFTlxuICAgIHNldHVwLnNldEN1cnJlbnRDZm5TdGFja1RlbXBsYXRlKHtcbiAgICAgIFJlc291cmNlczoge1xuICAgICAgICBGdW5jOiB7XG4gICAgICAgICAgVHlwZTogJ0FXUzo6TGFtYmRhOjpGdW5jdGlvbicsXG4gICAgICAgICAgUHJvcGVydGllczoge1xuICAgICAgICAgICAgQ29kZToge1xuICAgICAgICAgICAgICBaaXBGaWxlOiAnZXhwb3J0cy5oYW5kbGVyID0gKCkgPT4ge3JldHVybiB0cnVlfScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgUnVudGltZTogUnVudGltZS5OT0RFSlNfTEFURVNULm5hbWUsXG4gICAgICAgICAgICBGdW5jdGlvbk5hbWU6ICdteS1mdW5jdGlvbicsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgY29uc3QgbmV3Q29kZSA9ICdleHBvcnRzLmhhbmRsZXIgPSAoKSA9PiB7cmV0dXJuIGZhbHNlfSc7XG4gICAgY29uc3QgY2RrU3RhY2tBcnRpZmFjdCA9IHNldHVwLmNka1N0YWNrQXJ0aWZhY3RPZih7XG4gICAgICB0ZW1wbGF0ZToge1xuICAgICAgICBSZXNvdXJjZXM6IHtcbiAgICAgICAgICBGdW5jOiB7XG4gICAgICAgICAgICBUeXBlOiAnQVdTOjpMYW1iZGE6OkZ1bmN0aW9uJyxcbiAgICAgICAgICAgIFByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgICAgQ29kZToge1xuICAgICAgICAgICAgICAgIFppcEZpbGU6IG5ld0NvZGUsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFJ1bnRpbWU6IFJ1bnRpbWUuTk9ERUpTX0xBVEVTVC5uYW1lLFxuICAgICAgICAgICAgICBGdW5jdGlvbk5hbWU6ICdteS1mdW5jdGlvbicsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgLy8gV0hFTlxuICAgIGNvbnN0IGRlcGxveVN0YWNrUmVzdWx0ID0gYXdhaXQgaG90c3dhcE1vY2tTZGtQcm92aWRlci50cnlIb3Rzd2FwRGVwbG95bWVudChob3Rzd2FwTW9kZSwgY2RrU3RhY2tBcnRpZmFjdCk7XG5cbiAgICAvLyBUSEVOXG4gICAgZXhwZWN0KGRlcGxveVN0YWNrUmVzdWx0KS5ub3QudG9CZVVuZGVmaW5lZCgpO1xuICAgIGV4cGVjdChtb2NrVXBkYXRlTGFtYmRhQ29kZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xuICAgICAgRnVuY3Rpb25OYW1lOiAnbXktZnVuY3Rpb24nLFxuICAgICAgWmlwRmlsZTogZXhwZWN0LmFueShCdWZmZXIpLFxuICAgIH0pO1xuICB9KTtcblxuICBzaWxlbnRUZXN0KCdjYWxscyB0aGUgdXBkYXRlTGFtYmRhQ29kZSgpIEFQSSB3aGVuIGl0IHJlY2VpdmVzIG9ubHkgYSBjb2RlIGRpZmZlcmVuY2UgaW4gYSBMYW1iZGEgZnVuY3Rpb24gKElubGluZSBQeXRob24gY29kZSknLCBhc3luYyAoKSA9PiB7XG4gICAgLy8gR0lWRU5cbiAgICBzZXR1cC5zZXRDdXJyZW50Q2ZuU3RhY2tUZW1wbGF0ZSh7XG4gICAgICBSZXNvdXJjZXM6IHtcbiAgICAgICAgRnVuYzoge1xuICAgICAgICAgIFR5cGU6ICdBV1M6OkxhbWJkYTo6RnVuY3Rpb24nLFxuICAgICAgICAgIFByb3BlcnRpZXM6IHtcbiAgICAgICAgICAgIENvZGU6IHtcbiAgICAgICAgICAgICAgWmlwRmlsZTogJ2RlZiBoYW5kbGVyKGV2ZW50LCBjb250ZXh0KTpcXG4gIHJldHVybiBUcnVlJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBSdW50aW1lOiAncHl0aG9uMy45JyxcbiAgICAgICAgICAgIEZ1bmN0aW9uTmFtZTogJ215LWZ1bmN0aW9uJyxcbiAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9KTtcbiAgICBjb25zdCBjZGtTdGFja0FydGlmYWN0ID0gc2V0dXAuY2RrU3RhY2tBcnRpZmFjdE9mKHtcbiAgICAgIHRlbXBsYXRlOiB7XG4gICAgICAgIFJlc291cmNlczoge1xuICAgICAgICAgIEZ1bmM6IHtcbiAgICAgICAgICAgIFR5cGU6ICdBV1M6OkxhbWJkYTo6RnVuY3Rpb24nLFxuICAgICAgICAgICAgUHJvcGVydGllczoge1xuICAgICAgICAgICAgICBDb2RlOiB7XG4gICAgICAgICAgICAgICAgWmlwRmlsZTogJ2RlZiBoYW5kbGVyKGV2ZW50LCBjb250ZXh0KTpcXG4gIHJldHVybiBGYWxzZScsXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFJ1bnRpbWU6ICdweXRob24zLjknLFxuICAgICAgICAgICAgICBGdW5jdGlvbk5hbWU6ICdteS1mdW5jdGlvbicsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgLy8gV0hFTlxuICAgIGNvbnN0IGRlcGxveVN0YWNrUmVzdWx0ID0gYXdhaXQgaG90c3dhcE1vY2tTZGtQcm92aWRlci50cnlIb3Rzd2FwRGVwbG95bWVudChob3Rzd2FwTW9kZSwgY2RrU3RhY2tBcnRpZmFjdCk7XG5cbiAgICAvLyBUSEVOXG4gICAgZXhwZWN0KGRlcGxveVN0YWNrUmVzdWx0KS5ub3QudG9CZVVuZGVmaW5lZCgpO1xuICAgIGV4cGVjdChtb2NrVXBkYXRlTGFtYmRhQ29kZSkudG9IYXZlQmVlbkNhbGxlZFdpdGgoe1xuICAgICAgRnVuY3Rpb25OYW1lOiAnbXktZnVuY3Rpb24nLFxuICAgICAgWmlwRmlsZTogZXhwZWN0LmFueShCdWZmZXIpLFxuICAgIH0pO1xuICB9KTtcblxuICBzaWxlbnRUZXN0KCd0aHJvdyBhIENmbkV2YWx1YXRpb25FeGNlcHRpb24gd2hlbiBpdCByZWNlaXZlcyBhbiB1bnN1cHBvcnRlZCBmdW5jdGlvbiBydW50aW1lJywgYXN5bmMgKCkgPT4ge1xuICAgIC8vIEdJVkVOXG4gICAgc2V0dXAuc2V0Q3VycmVudENmblN0YWNrVGVtcGxhdGUoe1xuICAgICAgUmVzb3VyY2VzOiB7XG4gICAgICAgIEZ1bmM6IHtcbiAgICAgICAgICBUeXBlOiAnQVdTOjpMYW1iZGE6OkZ1bmN0aW9uJyxcbiAgICAgICAgICBQcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICBDb2RlOiB7XG4gICAgICAgICAgICAgIFppcEZpbGU6ICdkZWYgaGFuZGxlcihldmVudDosIGNvbnRleHQ6KSB0cnVlIGVuZCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgUnVudGltZTogJ3J1YnkyLjcnLFxuICAgICAgICAgICAgRnVuY3Rpb25OYW1lOiAnbXktZnVuY3Rpb24nLFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0pO1xuICAgIGNvbnN0IGNka1N0YWNrQXJ0aWZhY3QgPSBzZXR1cC5jZGtTdGFja0FydGlmYWN0T2Yoe1xuICAgICAgdGVtcGxhdGU6IHtcbiAgICAgICAgUmVzb3VyY2VzOiB7XG4gICAgICAgICAgRnVuYzoge1xuICAgICAgICAgICAgVHlwZTogJ0FXUzo6TGFtYmRhOjpGdW5jdGlvbicsXG4gICAgICAgICAgICBQcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgIENvZGU6IHtcbiAgICAgICAgICAgICAgICBaaXBGaWxlOiAnZGVmIGhhbmRsZXIoZXZlbnQ6LCBjb250ZXh0OikgZmFsc2UgZW5kJyxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgUnVudGltZTogJ3J1YnkyLjcnLFxuICAgICAgICAgICAgICBGdW5jdGlvbk5hbWU6ICdteS1mdW5jdGlvbicsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgLy8gV0hFTlxuICAgIGNvbnN0IHRyeUhvdHN3YXAgPSBob3Rzd2FwTW9ja1Nka1Byb3ZpZGVyLnRyeUhvdHN3YXBEZXBsb3ltZW50KGhvdHN3YXBNb2RlLCBjZGtTdGFja0FydGlmYWN0KTtcblxuICAgIC8vIFRIRU5cbiAgICBhd2FpdCBleHBlY3QodHJ5SG90c3dhcCkucmVqZWN0cy50b1Rocm93KCdydW50aW1lIHJ1YnkyLjcgaXMgdW5zdXBwb3J0ZWQsIG9ubHkgbm9kZS5qcyBhbmQgcHl0aG9uIHJ1bnRpbWVzIGFyZSBjdXJyZW50bHkgc3VwcG9ydGVkLicpO1xuICB9KTtcbn0pO1xuIl19