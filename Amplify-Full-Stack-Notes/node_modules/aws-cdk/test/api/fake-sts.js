"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FakeSts = void 0;
/* eslint-disable import/order */
const nock = require("nock");
const uuid = require("uuid");
const xmlJs = require("xml-js");
/**
 * Class for mocking AWS HTTP Requests and pretending to be STS
 *
 * This is necessary for testing our authentication layer. Most other mocking
 * libraries don't consider as they mock functional methods which happen BEFORE
 * the SDK's HTTP/Authentication layer.
 *
 * Instead, we want to validate how we're setting up credentials for the
 * SDK, so we pretend to be the STS server and have an in-memory database
 * of users and roles.
 */
class FakeSts {
    constructor() {
        this.assumedRoles = new Array();
        this.identities = {};
        this.roles = {};
    }
    /**
     * Begin mocking
     */
    begin() {
        const self = this;
        nock.disableNetConnect();
        if (!nock.isActive()) {
            nock.activate();
        }
        nock(/.*/).persist().post(/.*/).reply(function (uri, body, cb) {
            const parsedBody = typeof body === 'string' ? urldecode(body) : body;
            try {
                const response = self.handleRequest({
                    uri,
                    host: this.req.headers.host,
                    parsedBody,
                    headers: this.req.headers,
                });
                cb(null, [200, xmlJs.js2xml(response, { compact: true })]);
            }
            catch (e) {
                cb(null, [400, xmlJs.js2xml({
                        ErrorResponse: {
                            _attributes: { xmlns: 'https://sts.amazonaws.com/doc/2011-06-15/' },
                            Error: {
                                Type: 'Sender',
                                Code: e.code ?? 'Error',
                                Message: e.message,
                            },
                            RequestId: '1',
                        },
                    }, { compact: true })]);
            }
        });
        // Scrub some environment variables that might be set if we're running on CodeBuild which will interfere with the tests.
        delete process.env.AWS_PROFILE;
        delete process.env.AWS_REGION;
        delete process.env.AWS_DEFAULT_REGION;
        delete process.env.AWS_ACCESS_KEY_ID;
        delete process.env.AWS_SECRET_ACCESS_KEY;
        delete process.env.AWS_SESSION_TOKEN;
    }
    /**
     * Restore everything to normal
     */
    restore() {
        nock.restore(); // https://github.com/nock/nock/issues/1817
        nock.cleanAll();
        nock.enableNetConnect();
    }
    /**
     * Register a user
     */
    registerUser(account, accessKey, options = {}) {
        const userName = options.name ?? `User${Object.keys(this.identities).length + 1}`;
        this.identities[accessKey] = {
            account: account,
            arn: `arn:${options.partition ?? 'aws'}:sts::${account}:user/${userName}`,
            userId: `${accessKey}:${userName}`,
        };
    }
    /**
     * Register an assumable role
     */
    registerRole(account, roleArn, options = {}) {
        const roleName = options.name ?? `Role${Object.keys(this.roles).length + 1}`;
        this.roles[roleArn] = {
            allowedAccounts: options.allowedAccounts ?? [account],
            arn: roleArn,
            roleName,
            account,
        };
    }
    handleRequest(mockRequest) {
        const response = (() => {
            const identity = this.identity(mockRequest);
            switch (mockRequest.parsedBody.Action) {
                case 'GetCallerIdentity':
                    return this.handleGetCallerIdentity(identity);
                case 'AssumeRole':
                    return this.handleAssumeRole(identity, mockRequest);
            }
            throw new Error(`Unrecognized Action in MockAwsHttp: ${mockRequest.parsedBody.Action}`);
        })();
        // console.log(mockRequest.parsedBody, '->', response);
        return response;
    }
    handleGetCallerIdentity(identity) {
        return {
            GetCallerIdentityResponse: {
                _attributes: { xmlns: 'https://sts.amazonaws.com/doc/2011-06-15/' },
                GetCallerIdentityResult: {
                    Arn: identity.arn,
                    UserId: identity.userId,
                    Account: identity.account,
                },
                ResponseMetadata: {
                    RequestId: '1',
                },
            },
        };
    }
    /**
     * Maps have a funky encoding to them when sent to STS.
     *
     * @see https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html
     */
    decodeMapFromRequestBody(parameter, body) {
        return Object.entries(body)
            .filter(([key, _]) => key.startsWith(`${parameter}.member.`) && key.endsWith('.Key'))
            .map(([key, tagKey]) => ({ Key: tagKey, Value: body[`${parameter}.member.${key.split('.')[2]}.Value`] }));
    }
    /**
     * Lists have a funky encoding when sent to STS.
     *
     * @see https://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html
     */
    decodeListKeysFromRequestBody(parameter, body) {
        return Object.entries(body)
            .filter(([key]) => key.startsWith(`${parameter}.member.`))
            .map(([, value]) => value);
    }
    handleAssumeRole(identity, mockRequest) {
        this.checkForFailure(mockRequest.parsedBody.RoleArn);
        this.assumedRoles.push({
            roleArn: mockRequest.parsedBody.RoleArn,
            roleSessionName: mockRequest.parsedBody.RoleSessionName,
            serialNumber: mockRequest.parsedBody.SerialNumber,
            tokenCode: mockRequest.parsedBody.TokenCode,
            tags: this.decodeMapFromRequestBody('Tags', mockRequest.parsedBody),
            transitiveTagKeys: this.decodeListKeysFromRequestBody('TransitiveTagKeys', mockRequest.parsedBody),
        });
        const roleArn = mockRequest.parsedBody.RoleArn;
        const targetRole = this.roles[roleArn];
        if (!targetRole) {
            throw new Error(`No such role: ${roleArn}`);
        }
        if (!targetRole.allowedAccounts.includes(identity.account)) {
            throw new Error(`Identity from account: ${identity.account} not allowed to assume ${roleArn}, must be one of: ${targetRole.allowedAccounts}`);
        }
        const freshAccessKey = uuid.v4();
        // Register a new "user" (identity) for this access key
        this.registerUser(targetRole.account, freshAccessKey, {
            name: `AssumedRole-${targetRole.roleName}-${identity.userId}`,
        });
        return {
            AssumeRoleResponse: {
                _attributes: { xmlns: 'https://sts.amazonaws.com/doc/2011-06-15/' },
                AssumeRoleResult: {
                    AssumedRoleUser: {
                        Arn: roleArn,
                        AssumedRoleId: `${freshAccessKey}:${targetRole.roleName}`,
                    },
                    Credentials: {
                        AccessKeyId: freshAccessKey,
                        SecretAccessKey: 'Secret',
                        SessionToken: 'Token',
                        Expiration: new Date(Date.now() + 3600 * 1000).toISOString(),
                    },
                    PackedPolicySize: 6,
                },
            },
            ResponseMetadata: {
                RequestId: '1',
            },
        };
    }
    checkForFailure(s) {
        const failureRequested = s.match(/<FAIL:([^>]+)>/);
        if (failureRequested) {
            const err = new Error(`STS failing by user request: ${failureRequested[1]}`);
            err.code = failureRequested[1];
            throw err;
        }
    }
    identity(mockRequest) {
        const keyId = this.accessKeyId(mockRequest);
        this.checkForFailure(keyId);
        const ret = this.identities[keyId];
        if (!ret) {
            throw new Error(`Unrecognized access key used: ${keyId}`);
        }
        return ret;
    }
    /**
     * Return the access key from a signed request
     */
    accessKeyId(mockRequest) {
        // "AWS4-HMAC-SHA256 Credential=(ab1a5e4c-ff41-4811-ac5f-6d1230f7aa90)access/20201210/eu-bla-5/sts/aws4_request, SignedHeaders=host;x-amz-content-sha256;x-amz-date, Signature=9b31011173a7842fa372d4ef7c431c08f0b1514fdaf54145560a4db7ecd24529"
        const auth = mockRequest.headers.authorization;
        const m = auth?.match(/Credential=([^\/]+)/);
        if (!m) {
            throw new Error(`No correct authorization header: ${auth}`);
        }
        return m[1];
    }
}
exports.FakeSts = FakeSts;
function urldecode(body) {
    const parts = body.split('&');
    const ret = {};
    for (const part of parts) {
        const [k, v] = part.split('=');
        ret[decodeURIComponent(k)] = decodeURIComponent(v);
    }
    return ret;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmFrZS1zdHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJmYWtlLXN0cy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSxpQ0FBaUM7QUFDakMsNkJBQTZCO0FBQzdCLDZCQUE2QjtBQUM3QixnQ0FBZ0M7QUF3QmhDOzs7Ozs7Ozs7O0dBVUc7QUFDSCxNQUFhLE9BQU87SUFNbEI7UUFMZ0IsaUJBQVksR0FBRyxJQUFJLEtBQUssRUFBZSxDQUFDO1FBRWhELGVBQVUsR0FBdUMsRUFBRSxDQUFDO1FBQ3BELFVBQUssR0FBbUMsRUFBRSxDQUFDO0lBR25ELENBQUM7SUFFRDs7T0FFRztJQUNJLEtBQUs7UUFDVixNQUFNLElBQUksR0FBRyxJQUFJLENBQUM7UUFFbEIsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7UUFDekIsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsRUFBRSxDQUFDO1lBQ3JCLElBQUksQ0FBQyxRQUFRLEVBQUUsQ0FBQztRQUNsQixDQUFDO1FBQ0QsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxLQUFLLENBQUMsVUFBZ0IsR0FBRyxFQUFFLElBQUksRUFBRSxFQUFFO1lBQ2pFLE1BQU0sVUFBVSxHQUFHLE9BQU8sSUFBSSxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUM7WUFFckUsSUFBSSxDQUFDO2dCQUNILE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxhQUFhLENBQUM7b0JBQ2xDLEdBQUc7b0JBQ0gsSUFBSSxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLElBQUk7b0JBQzNCLFVBQVU7b0JBQ1YsT0FBTyxFQUFFLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTztpQkFDMUIsQ0FBQyxDQUFDO2dCQUNILEVBQUUsQ0FBQyxJQUFJLEVBQUUsQ0FB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O0NBQ0Y7QUFuT0QsMEJBbU9DO0FBcUJELFNBQVMsU0FBUyxDQUFDLElBQVk7SUFDN0IsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUM5QixNQUFNLEdBQUcsR0FBMkIsRUFBRSxDQUFDO0lBQ3ZDLEtBQUssTUFBTSxJQUFJLElBQUksS0FBSyxFQUFFLENBQUM7UUFDekIsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQy9CLEdBQUcsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLGtCQUFrQixDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ3JELENBQUM7SUFDRCxPQUFPLEdBQUcsQ0FBQztBQUNiLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBpbXBvcnQvb3JkZXIgKi9cbmltcG9ydCAqIGFzIG5vY2sgZnJvbSAnbm9jayc7XG5pbXBvcnQgKiBhcyB1dWlkIGZyb20gJ3V1aWQnO1xuaW1wb3J0ICogYXMgeG1sSnMgZnJvbSAneG1sLWpzJztcblxuaW50ZXJmYWNlIFJlZ2lzdGVyZWRJZGVudGl0eSB7XG4gIHJlYWRvbmx5IGFjY291bnQ6IHN0cmluZztcbiAgcmVhZG9ubHkgYXJuOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHVzZXJJZDogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgUmVnaXN0ZXJlZFJvbGUge1xuICByZWFkb25seSBhY2NvdW50OiBzdHJpbmc7XG4gIHJlYWRvbmx5IGFsbG93ZWRBY2NvdW50czogc3RyaW5nW107XG4gIHJlYWRvbmx5IGFybjogc3RyaW5nO1xuICByZWFkb25seSByb2xlTmFtZTogc3RyaW5nO1xufVxuXG5pbnRlcmZhY2UgQXNzdW1lZFJvbGUge1xuICByZWFkb25seSByb2xlQXJuOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHNlcmlhbE51bWJlcjogc3RyaW5nO1xuICByZWFkb25seSB0b2tlbkNvZGU6IHN0cmluZztcbiAgcmVhZG9ubHkgcm9sZVNlc3Npb25OYW1lOiBzdHJpbmc7XG4gIHJlYWRvbmx5IHRhZ3M/OiBBV1MuU1RTLlRhZ1tdO1xuICByZWFkb25seSB0cmFuc2l0aXZlVGFnS2V5cz86IHN0cmluZ1tdO1xufVxuXG4vKipcbiAqIENsYXNzIGZvciBtb2NraW5nIEFXUyBIVFRQIFJlcXVlc3RzIGFuZCBwcmV0ZW5kaW5nIHRvIGJlIFNUU1xuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGZvciB0ZXN0aW5nIG91ciBhdXRoZW50aWNhdGlvbiBsYXllci4gTW9zdCBvdGhlciBtb2NraW5nXG4gKiBsaWJyYXJpZXMgZG9uJ3QgY29uc2lkZXIgYXMgdGhleSBtb2NrIGZ1bmN0aW9uYWwgbWV0aG9kcyB3aGljaCBoYXBwZW4gQkVGT1JFXG4gKiB0aGUgU0RLJ3MgSFRUUC9BdXRoZW50aWNhdGlvbiBsYXllci5cbiAqXG4gKiBJbnN0ZWFkLCB3ZSB3YW50IHRvIHZhbGlkYXRlIGhvdyB3ZSdyZSBzZXR0aW5nIHVwIGNyZWRlbnRpYWxzIGZvciB0aGVcbiAqIFNESywgc28gd2UgcHJldGVuZCB0byBiZSB0aGUgU1RTIHNlcnZlciBhbmQgaGF2ZSBhbiBpbi1tZW1vcnkgZGF0YWJhc2VcbiAqIG9mIHVzZXJzIGFuZCByb2xlcy5cbiAqL1xuZXhwb3J0IGNsYXNzIEZha2VTdHMge1xuICBwdWJsaWMgcmVhZG9ubHkgYXNzdW1lZFJvbGVzID0gbmV3IEFycmF5PEFzc3VtZWRSb2xlPigpO1xuXG4gIHByaXZhdGUgaWRlbnRpdGllczogUmVjb3JkPHN0cmluZywgUmVnaXN0ZXJlZElkZW50aXR5PiA9IHt9O1xuICBwcml2YXRlIHJvbGVzOiBSZWNvcmQ8c3RyaW5nLCBSZWdpc3RlcmVkUm9sZT4gPSB7fTtcblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgfVxuXG4gIC8qKlxuICAgKiBCZWdpbiBtb2NraW5nXG4gICAqL1xuICBwdWJsaWMgYmVnaW4oKSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICBub2NrLmRpc2FibGVOZXRDb25uZWN0KCk7XG4gICAgaWYgKCFub2NrLmlzQWN0aXZlKCkpIHtcbiAgICAgIG5vY2suYWN0aXZhdGUoKTtcbiAgICB9XG4gICAgbm9jaygvLiovKS5wZXJzaXN0KCkucG9zdCgvLiovKS5yZXBseShmdW5jdGlvbiAodGhpcywgdXJpLCBib2R5LCBjYikge1xuICAgICAgY29uc3QgcGFyc2VkQm9keSA9IHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJyA/IHVybGRlY29kZShib2R5KSA6IGJvZHk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gc2VsZi5oYW5kbGVSZXF1ZXN0KHtcbiAgICAgICAgICB1cmksXG4gICAgICAgICAgaG9zdDogdGhpcy5yZXEuaGVhZGVycy5ob3N0LFxuICAgICAgICAgIHBhcnNlZEJvZHksXG4gICAgICAgICAgaGVhZGVyczogdGhpcy5yZXEuaGVhZGVycyxcbiAgICAgICAgfSk7XG4gICAgICAgIGNiKG51bGwsIFsyMDAsIHhtbEpzLmpzMnhtbChyZXNwb25zZSwgeyBjb21wYWN0OiB0cnVlIH0pXSk7XG4gICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgY2IobnVsbCwgWzQwMCwgeG1sSnMuanMyeG1sKHtcbiAgICAgICAgICBFcnJvclJlc3BvbnNlOiB7XG4gICAgICAgICAgICBfYXR0cmlidXRlczogeyB4bWxuczogJ2h0dHBzOi8vc3RzLmFtYXpvbmF3cy5jb20vZG9jLzIwMTEtMDYtMTUvJyB9LFxuICAgICAgICAgICAgRXJyb3I6IHtcbiAgICAgICAgICAgICAgVHlwZTogJ1NlbmRlcicsXG4gICAgICAgICAgICAgIENvZGU6IGUuY29kZSA/PyAnRXJyb3InLFxuICAgICAgICAgICAgICBNZXNzYWdlOiBlLm1lc3NhZ2UsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgUmVxdWVzdElkOiAnMScsXG4gICAgICAgICAgfSxcbiAgICAgICAgfSwgeyBjb21wYWN0OiB0cnVlIH0pXSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBTY3J1YiBzb21lIGVudmlyb25tZW50IHZhcmlhYmxlcyB0aGF0IG1pZ2h0IGJlIHNldCBpZiB3ZSdyZSBydW5uaW5nIG9uIENvZGVCdWlsZCB3aGljaCB3aWxsIGludGVyZmVyZSB3aXRoIHRoZSB0ZXN0cy5cbiAgICBkZWxldGUgcHJvY2Vzcy5lbnYuQVdTX1BST0ZJTEU7XG4gICAgZGVsZXRlIHByb2Nlc3MuZW52LkFXU19SRUdJT047XG4gICAgZGVsZXRlIHByb2Nlc3MuZW52LkFXU19ERUZBVUxUX1JFR0lPTjtcbiAgICBkZWxldGUgcHJvY2Vzcy5lbnYuQVdTX0FDQ0VTU19LRVlfSUQ7XG4gICAgZGVsZXRlIHByb2Nlc3MuZW52LkFXU19TRUNSRVRfQUNDRVNTX0tFWTtcbiAgICBkZWxldGUgcHJvY2Vzcy5lbnYuQVdTX1NFU1NJT05fVE9LRU47XG4gIH1cblxuICAvKipcbiAgICogUmVzdG9yZSBldmVyeXRoaW5nIHRvIG5vcm1hbFxuICAgKi9cbiAgcHVibGljIHJlc3RvcmUoKSB7XG4gICAgbm9jay5yZXN0b3JlKCk7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2NrL25vY2svaXNzdWVzLzE4MTdcbiAgICBub2NrLmNsZWFuQWxsKCk7XG4gICAgbm9jay5lbmFibGVOZXRDb25uZWN0KCk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSB1c2VyXG4gICAqL1xuICBwdWJsaWMgcmVnaXN0ZXJVc2VyKGFjY291bnQ6IHN0cmluZywgYWNjZXNzS2V5OiBzdHJpbmcsIG9wdGlvbnM6IFJlZ2lzdGVyVXNlck9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHVzZXJOYW1lID0gb3B0aW9ucy5uYW1lID8/IGBVc2VyJHtPYmplY3Qua2V5cyh0aGlzLmlkZW50aXRpZXMpLmxlbmd0aCArIDEgfWA7XG5cbiAgICB0aGlzLmlkZW50aXRpZXNbYWNjZXNzS2V5XSA9IHtcbiAgICAgIGFjY291bnQ6IGFjY291bnQsXG4gICAgICBhcm46IGBhcm46JHtvcHRpb25zLnBhcnRpdGlvbiA/PyAnYXdzJ306c3RzOjoke2FjY291bnR9OnVzZXIvJHt1c2VyTmFtZX1gLFxuICAgICAgdXNlcklkOiBgJHthY2Nlc3NLZXl9OiR7dXNlck5hbWV9YCxcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGFuIGFzc3VtYWJsZSByb2xlXG4gICAqL1xuICBwdWJsaWMgcmVnaXN0ZXJSb2xlKGFjY291bnQ6IHN0cmluZywgcm9sZUFybjogc3RyaW5nLCBvcHRpb25zOiBSZWdpc3RlclJvbGVPcHRpb25zID0ge30pIHtcbiAgICBjb25zdCByb2xlTmFtZSA9IG9wdGlvbnMubmFtZSA/PyBgUm9sZSR7T2JqZWN0LmtleXModGhpcy5yb2xlcykubGVuZ3RoICsgMSB9YDtcblxuICAgIHRoaXMucm9sZXNbcm9sZUFybl0gPSB7XG4gICAgICBhbGxvd2VkQWNjb3VudHM6IG9wdGlvbnMuYWxsb3dlZEFjY291bnRzID8/IFthY2NvdW50XSxcbiAgICAgIGFybjogcm9sZUFybixcbiAgICAgIHJvbGVOYW1lLFxuICAgICAgYWNjb3VudCxcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBoYW5kbGVSZXF1ZXN0KG1vY2tSZXF1ZXN0OiBNb2NrUmVxdWVzdCk6IFJlY29yZDxzdHJpbmcsIGFueT4ge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gKCgpID0+IHtcbiAgICAgIGNvbnN0IGlkZW50aXR5ID0gdGhpcy5pZGVudGl0eShtb2NrUmVxdWVzdCk7XG5cbiAgICAgIHN3aXRjaCAobW9ja1JlcXVlc3QucGFyc2VkQm9keS5BY3Rpb24pIHtcbiAgICAgICAgY2FzZSAnR2V0Q2FsbGVySWRlbnRpdHknOlxuICAgICAgICAgIHJldHVybiB0aGlzLmhhbmRsZUdldENhbGxlcklkZW50aXR5KGlkZW50aXR5KTtcblxuICAgICAgICBjYXNlICdBc3N1bWVSb2xlJzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5oYW5kbGVBc3N1bWVSb2xlKGlkZW50aXR5LCBtb2NrUmVxdWVzdCk7XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIEFjdGlvbiBpbiBNb2NrQXdzSHR0cDogJHttb2NrUmVxdWVzdC5wYXJzZWRCb2R5LkFjdGlvbn1gKTtcbiAgICB9KSgpO1xuICAgIC8vIGNvbnNvbGUubG9nKG1vY2tSZXF1ZXN0LnBhcnNlZEJvZHksICctPicsIHJlc3BvbnNlKTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH1cblxuICBwcml2YXRlIGhhbmRsZUdldENhbGxlcklkZW50aXR5KGlkZW50aXR5OiBSZWdpc3RlcmVkSWRlbnRpdHkpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcbiAgICByZXR1cm4ge1xuICAgICAgR2V0Q2FsbGVySWRlbnRpdHlSZXNwb25zZToge1xuICAgICAgICBfYXR0cmlidXRlczogeyB4bWxuczogJ2h0dHBzOi8vc3RzLmFtYXpvbmF3cy5jb20vZG9jLzIwMTEtMDYtMTUvJyB9LFxuICAgICAgICBHZXRDYWxsZXJJZGVudGl0eVJlc3VsdDoge1xuICAgICAgICAgIEFybjogaWRlbnRpdHkuYXJuLFxuICAgICAgICAgIFVzZXJJZDogaWRlbnRpdHkudXNlcklkLFxuICAgICAgICAgIEFjY291bnQ6IGlkZW50aXR5LmFjY291bnQsXG4gICAgICAgIH0sXG4gICAgICAgIFJlc3BvbnNlTWV0YWRhdGE6IHtcbiAgICAgICAgICBSZXF1ZXN0SWQ6ICcxJyxcbiAgICAgICAgfSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYXBzIGhhdmUgYSBmdW5reSBlbmNvZGluZyB0byB0aGVtIHdoZW4gc2VudCB0byBTVFMuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL1NUUy9sYXRlc3QvQVBJUmVmZXJlbmNlL0FQSV9Bc3N1bWVSb2xlLmh0bWxcbiAgICovXG4gIHByaXZhdGUgZGVjb2RlTWFwRnJvbVJlcXVlc3RCb2R5KHBhcmFtZXRlcjogc3RyaW5nLCBib2R5OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KTogQVdTLlNUUy5UYWdbXSB7XG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGJvZHkpXG4gICAgICAuZmlsdGVyKChba2V5LCBfXSkgPT4ga2V5LnN0YXJ0c1dpdGgoYCR7cGFyYW1ldGVyfS5tZW1iZXIuYCkgJiYga2V5LmVuZHNXaXRoKCcuS2V5JykpXG4gICAgICAubWFwKChba2V5LCB0YWdLZXldKSA9PiAoeyBLZXk6IHRhZ0tleSwgVmFsdWU6IGJvZHlbYCR7cGFyYW1ldGVyfS5tZW1iZXIuJHtrZXkuc3BsaXQoJy4nKVsyXX0uVmFsdWVgXSB9KSk7XG4gIH1cblxuICAvKipcbiAgICogTGlzdHMgaGF2ZSBhIGZ1bmt5IGVuY29kaW5nIHdoZW4gc2VudCB0byBTVFMuXG4gICAqXG4gICAqIEBzZWUgaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL1NUUy9sYXRlc3QvQVBJUmVmZXJlbmNlL0FQSV9Bc3N1bWVSb2xlLmh0bWxcbiAgICovXG4gIHByaXZhdGUgZGVjb2RlTGlzdEtleXNGcm9tUmVxdWVzdEJvZHkocGFyYW1ldGVyOiBzdHJpbmcsIGJvZHk6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4pOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIE9iamVjdC5lbnRyaWVzKGJvZHkpXG4gICAgICAuZmlsdGVyKChba2V5XSkgPT4ga2V5LnN0YXJ0c1dpdGgoYCR7cGFyYW1ldGVyfS5tZW1iZXIuYCkpXG4gICAgICAubWFwKChbLCB2YWx1ZV0pID0+IHZhbHVlKTtcbiAgfVxuXG4gIHByaXZhdGUgaGFuZGxlQXNzdW1lUm9sZShpZGVudGl0eTogUmVnaXN0ZXJlZElkZW50aXR5LCBtb2NrUmVxdWVzdDogTW9ja1JlcXVlc3QpOiBSZWNvcmQ8c3RyaW5nLCBhbnk+IHtcbiAgICB0aGlzLmNoZWNrRm9yRmFpbHVyZShtb2NrUmVxdWVzdC5wYXJzZWRCb2R5LlJvbGVBcm4pO1xuXG4gICAgdGhpcy5hc3N1bWVkUm9sZXMucHVzaCh7XG4gICAgICByb2xlQXJuOiBtb2NrUmVxdWVzdC5wYXJzZWRCb2R5LlJvbGVBcm4sXG4gICAgICByb2xlU2Vzc2lvbk5hbWU6IG1vY2tSZXF1ZXN0LnBhcnNlZEJvZHkuUm9sZVNlc3Npb25OYW1lLFxuICAgICAgc2VyaWFsTnVtYmVyOiBtb2NrUmVxdWVzdC5wYXJzZWRCb2R5LlNlcmlhbE51bWJlcixcbiAgICAgIHRva2VuQ29kZTogbW9ja1JlcXVlc3QucGFyc2VkQm9keS5Ub2tlbkNvZGUsXG4gICAgICB0YWdzOiB0aGlzLmRlY29kZU1hcEZyb21SZXF1ZXN0Qm9keSgnVGFncycsIG1vY2tSZXF1ZXN0LnBhcnNlZEJvZHkpLFxuICAgICAgdHJhbnNpdGl2ZVRhZ0tleXM6IHRoaXMuZGVjb2RlTGlzdEtleXNGcm9tUmVxdWVzdEJvZHkoJ1RyYW5zaXRpdmVUYWdLZXlzJywgbW9ja1JlcXVlc3QucGFyc2VkQm9keSksXG4gICAgfSk7XG5cbiAgICBjb25zdCByb2xlQXJuID0gbW9ja1JlcXVlc3QucGFyc2VkQm9keS5Sb2xlQXJuO1xuICAgIGNvbnN0IHRhcmdldFJvbGUgPSB0aGlzLnJvbGVzW3JvbGVBcm5dO1xuICAgIGlmICghdGFyZ2V0Um9sZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBzdWNoIHJvbGU6ICR7cm9sZUFybn1gKTtcbiAgICB9XG5cbiAgICBpZiAoIXRhcmdldFJvbGUuYWxsb3dlZEFjY291bnRzLmluY2x1ZGVzKGlkZW50aXR5LmFjY291bnQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYElkZW50aXR5IGZyb20gYWNjb3VudDogJHtpZGVudGl0eS5hY2NvdW50fSBub3QgYWxsb3dlZCB0byBhc3N1bWUgJHtyb2xlQXJufSwgbXVzdCBiZSBvbmUgb2Y6ICR7dGFyZ2V0Um9sZS5hbGxvd2VkQWNjb3VudHN9YCk7XG4gICAgfVxuXG4gICAgY29uc3QgZnJlc2hBY2Nlc3NLZXkgPSB1dWlkLnY0KCk7XG5cbiAgICAvLyBSZWdpc3RlciBhIG5ldyBcInVzZXJcIiAoaWRlbnRpdHkpIGZvciB0aGlzIGFjY2VzcyBrZXlcbiAgICB0aGlzLnJlZ2lzdGVyVXNlcih0YXJnZXRSb2xlLmFjY291bnQsIGZyZXNoQWNjZXNzS2V5LCB7XG4gICAgICBuYW1lOiBgQXNzdW1lZFJvbGUtJHt0YXJnZXRSb2xlLnJvbGVOYW1lfS0ke2lkZW50aXR5LnVzZXJJZH1gLFxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIEFzc3VtZVJvbGVSZXNwb25zZToge1xuICAgICAgICBfYXR0cmlidXRlczogeyB4bWxuczogJ2h0dHBzOi8vc3RzLmFtYXpvbmF3cy5jb20vZG9jLzIwMTEtMDYtMTUvJyB9LFxuICAgICAgICBBc3N1bWVSb2xlUmVzdWx0OiB7XG4gICAgICAgICAgQXNzdW1lZFJvbGVVc2VyOiB7XG4gICAgICAgICAgICBBcm46IHJvbGVBcm4sXG4gICAgICAgICAgICBBc3N1bWVkUm9sZUlkOiBgJHtmcmVzaEFjY2Vzc0tleX06JHt0YXJnZXRSb2xlLnJvbGVOYW1lfWAsXG4gICAgICAgICAgfSxcbiAgICAgICAgICBDcmVkZW50aWFsczoge1xuICAgICAgICAgICAgQWNjZXNzS2V5SWQ6IGZyZXNoQWNjZXNzS2V5LFxuICAgICAgICAgICAgU2VjcmV0QWNjZXNzS2V5OiAnU2VjcmV0JyxcbiAgICAgICAgICAgIFNlc3Npb25Ub2tlbjogJ1Rva2VuJyxcbiAgICAgICAgICAgIEV4cGlyYXRpb246IG5ldyBEYXRlKERhdGUubm93KCkgKyAzNjAwICogMTAwMCkudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIFBhY2tlZFBvbGljeVNpemU6IDYsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgUmVzcG9uc2VNZXRhZGF0YToge1xuICAgICAgICBSZXF1ZXN0SWQ6ICcxJyxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIHByaXZhdGUgY2hlY2tGb3JGYWlsdXJlKHM6IHN0cmluZykge1xuICAgIGNvbnN0IGZhaWx1cmVSZXF1ZXN0ZWQgPSBzLm1hdGNoKC88RkFJTDooW14+XSspPi8pO1xuICAgIGlmIChmYWlsdXJlUmVxdWVzdGVkKSB7XG4gICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoYFNUUyBmYWlsaW5nIGJ5IHVzZXIgcmVxdWVzdDogJHtmYWlsdXJlUmVxdWVzdGVkWzFdfWApO1xuICAgICAgKGVyciBhcyBhbnkpLmNvZGUgPSBmYWlsdXJlUmVxdWVzdGVkWzFdO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgaWRlbnRpdHkobW9ja1JlcXVlc3Q6IE1vY2tSZXF1ZXN0KSB7XG4gICAgY29uc3Qga2V5SWQgPSB0aGlzLmFjY2Vzc0tleUlkKG1vY2tSZXF1ZXN0KTtcbiAgICB0aGlzLmNoZWNrRm9yRmFpbHVyZShrZXlJZCk7XG5cbiAgICBjb25zdCByZXQgPSB0aGlzLmlkZW50aXRpZXNba2V5SWRdO1xuICAgIGlmICghcmV0KSB7IHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIGFjY2VzcyBrZXkgdXNlZDogJHtrZXlJZH1gKTsgfVxuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBhY2Nlc3Mga2V5IGZyb20gYSBzaWduZWQgcmVxdWVzdFxuICAgKi9cbiAgcHJpdmF0ZSBhY2Nlc3NLZXlJZChtb2NrUmVxdWVzdDogTW9ja1JlcXVlc3QpOiBzdHJpbmcge1xuICAgIC8vIFwiQVdTNC1ITUFDLVNIQTI1NiBDcmVkZW50aWFsPShhYjFhNWU0Yy1mZjQxLTQ4MTEtYWM1Zi02ZDEyMzBmN2FhOTApYWNjZXNzLzIwMjAxMjEwL2V1LWJsYS01L3N0cy9hd3M0X3JlcXVlc3QsIFNpZ25lZEhlYWRlcnM9aG9zdDt4LWFtei1jb250ZW50LXNoYTI1Njt4LWFtei1kYXRlLCBTaWduYXR1cmU9OWIzMTAxMTE3M2E3ODQyZmEzNzJkNGVmN2M0MzFjMDhmMGIxNTE0ZmRhZjU0MTQ1NTYwYTRkYjdlY2QyNDUyOVwiXG4gICAgY29uc3QgYXV0aCA9IG1vY2tSZXF1ZXN0LmhlYWRlcnMuYXV0aG9yaXphdGlvbjtcblxuICAgIGNvbnN0IG0gPSBhdXRoPy5tYXRjaCgvQ3JlZGVudGlhbD0oW15cXC9dKykvKTtcbiAgICBpZiAoIW0pIHsgdGhyb3cgbmV3IEVycm9yKGBObyBjb3JyZWN0IGF1dGhvcml6YXRpb24gaGVhZGVyOiAke2F1dGh9YCk7IH1cbiAgICByZXR1cm4gbVsxXTtcbiAgfVxufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJlZ2lzdGVyVXNlck9wdGlvbnMge1xuICByZWFkb25seSBuYW1lPzogc3RyaW5nO1xuICByZWFkb25seSBwYXJ0aXRpb24/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVnaXN0ZXJSb2xlT3B0aW9ucyB7XG4gIHJlYWRvbmx5IGFsbG93ZWRBY2NvdW50cz86IHN0cmluZ1tdO1xuICByZWFkb25seSBuYW1lPzogc3RyaW5nO1xuICByZWFkb25seSBwYXJ0aXRpb24/OiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBNb2NrUmVxdWVzdCB7XG4gIHJlYWRvbmx5IGhvc3Q6IHN0cmluZztcbiAgcmVhZG9ubHkgdXJpOiBzdHJpbmc7XG4gIHJlYWRvbmx5IGhlYWRlcnM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gIHJlYWRvbmx5IHBhcnNlZEJvZHk6IFJlY29yZDxzdHJpbmcsIHN0cmluZz47XG4gIHJlYWRvbmx5IHNlc3Npb25UYWdzPzogeyBba2V5OiBzdHJpbmddOiBzdHJpbmcgfTtcbn1cblxuZnVuY3Rpb24gdXJsZGVjb2RlKGJvZHk6IHN0cmluZyk6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4ge1xuICBjb25zdCBwYXJ0cyA9IGJvZHkuc3BsaXQoJyYnKTtcbiAgY29uc3QgcmV0OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG4gIGZvciAoY29uc3QgcGFydCBvZiBwYXJ0cykge1xuICAgIGNvbnN0IFtrLCB2XSA9IHBhcnQuc3BsaXQoJz0nKTtcbiAgICByZXRbZGVjb2RlVVJJQ29tcG9uZW50KGspXSA9IGRlY29kZVVSSUNvbXBvbmVudCh2KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuIl19