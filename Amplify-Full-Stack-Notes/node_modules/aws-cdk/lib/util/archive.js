"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.zipDirectory = void 0;
const console_1 = require("console");
const fs_1 = require("fs");
const path = require("path");
const glob = require("glob");
// eslint-disable-next-line @typescript-eslint/no-require-imports
const archiver = require('archiver');
// Adapted from cdk-assets
async function zipDirectory(directory, outputFile) {
    // We write to a temporary file and rename at the last moment. This is so that if we are
    // interrupted during this process, we don't leave a half-finished file in the target location.
    const temporaryOutputFile = `${outputFile}.${randomString()}._tmp`;
    await writeZipFile(directory, temporaryOutputFile);
    await moveIntoPlace(temporaryOutputFile, outputFile);
}
exports.zipDirectory = zipDirectory;
function writeZipFile(directory, outputFile) {
    return new Promise(async (ok, fail) => {
        // The below options are needed to support following symlinks when building zip files:
        // - nodir: This will prevent symlinks themselves from being copied into the zip.
        // - follow: This will follow symlinks and copy the files within.
        const globOptions = {
            dot: true,
            nodir: true,
            follow: true,
            cwd: directory,
        };
        const files = glob.sync('**', globOptions); // The output here is already sorted
        const output = (0, fs_1.createWriteStream)(outputFile);
        const archive = archiver('zip');
        archive.on('warning', fail);
        archive.on('error', fail);
        // archive has been finalized and the output file descriptor has closed, resolve promise
        // this has to be done before calling `finalize` since the events may fire immediately after.
        // see https://www.npmjs.com/package/archiver
        output.once('close', ok);
        archive.pipe(output);
        // Append files serially to ensure file order
        for (const file of files) {
            const fullPath = path.resolve(directory, file);
            // Exactly 2 promises
            // eslint-disable-next-line @cdklabs/promiseall-no-unbounded-parallelism
            const [data, stat] = await Promise.all([fs_1.promises.readFile(fullPath), fs_1.promises.stat(fullPath)]);
            archive.append(data, {
                name: file,
                mode: stat.mode,
            });
        }
        await archive.finalize();
    });
}
/**
 * Rename the file to the target location, taking into account:
 *
 * - That we may see EPERM on Windows while an Antivirus scanner still has the
 *   file open, so retry a couple of times.
 * - This same function may be called in parallel and be interrupted at any point.
 */
async function moveIntoPlace(source, target) {
    let delay = 100;
    let attempts = 5;
    while (true) {
        try {
            // 'rename' is guaranteed to overwrite an existing target, as long as it is a file (not a directory)
            await fs_1.promises.rename(source, target);
            return;
        }
        catch (e) {
            if (e.code !== 'EPERM' || attempts-- <= 0) {
                throw e;
            }
            (0, console_1.error)(e.message);
            await sleep(Math.floor(Math.random() * delay));
            delay *= 2;
        }
    }
}
function sleep(ms) {
    return new Promise(ok => setTimeout(ok, ms));
}
function randomString() {
    return Math.random().toString(36).replace(/[^a-z0-9]+/g, '');
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXJjaGl2ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImFyY2hpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEscUNBQWdDO0FBQ2hDLDJCQUF1RDtBQUN2RCw2QkFBNkI7QUFDN0IsNkJBQTZCO0FBRTdCLGlFQUFpRTtBQUNqRSxNQUFNLFFBQVEsR0FBRyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUM7QUFFckMsMEJBQTBCO0FBQ25CLEtBQUssVUFBVSxZQUFZLENBQUMsU0FBaUIsRUFBRSxVQUFrQjtJQUN0RSx3RkFBd0Y7SUFDeEYsK0ZBQStGO0lBQy9GLE1BQU0sbUJBQW1CLEdBQUcsR0FBRyxVQUFVLElBQUksWUFBWSxFQUFFLE9BQU8sQ0FBQztJQUNuRSxNQUFNLFlBQVksQ0FBQyxTQUFTLEVBQUUsbUJBQW1CLENBQUMsQ0FBQztJQUNuRCxNQUFNLGFBQWEsQ0FBQyxtQkFBbUIsRUFBRSxVQUFVLENBQUMsQ0FBQztBQUN2RCxDQUFDO0FBTkQsb0NBTUM7QUFFRCxTQUFTLFlBQVksQ0FBQyxTQUFpQixFQUFFLFVBQWtCO0lBQ3pELE9BQU8sSUFBSSxPQUFPLENBQUMsS0FBSyxFQUFFLEVBQUUsRUFBRSxJQUFJLEVBQUUsRUFBRTtRQUNwQyxzRkFBc0Y7UUFDdEYsaUZBQWlGO1FBQ2pGLGlFQUFpRTtRQUNqRSxNQUFNLFdBQVcsR0FBRztZQUNsQixHQUFHLEVBQUUsSUFBSTtZQUNULEtBQUssRUFBRSxJQUFJO1lBQ1gsTUFBTSxFQUFFLElBQUk7WUFDWixHQUFHLEVBQUUsU0FBUztTQUNmLENBQUM7UUFDRixNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxXQUFXLENBQUMsQ0FBQyxDQUFDLG9DQUFvQztRQUVoRixNQUFNLE1BQU0sR0FBRyxJQUFBLHNCQUFpQixFQUFDLFVBQVUsQ0FBQyxDQUFDO1FBRTdDLE1BQU0sT0FBTyxHQUFHLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNoQyxPQUFPLENBQUMsRUFBRSxDQUFDLFNBQVMsRUFBRSxJQUFJLENBQUMsQ0FBQztRQUM1QixPQUFPLENBQUMsRUFBRSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsQ0FBQztRQUUxQix3RkFBd0Y7UUFDeEYsNkZBQTZGO1FBQzdGLDZDQUE2QztRQUM3QyxNQUFNLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxFQUFFLENBQUMsQ0FBQztRQUV6QixPQUFPLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBRXJCLDZDQUE2QztRQUM3QyxLQUFLLE1BQU0sSUFBSSxJQUFJLEtBQUssRUFBRSxDQUFDO1lBQ3pCLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxDQUFDO1lBQy9DLHFCQUFxQjtZQUNyQix3RUFBd0U7WUFDeEUsTUFBTSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsR0FBRyxNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxhQUFFLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxFQUFFLGFBQUUsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ25GLE9BQU8sQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFO2dCQUNuQixJQUFJLEVBQUUsSUFBSTtnQkFDVixJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUk7YUFDaEIsQ0FBQyxDQUFDO1FBQ0wsQ0FBQztRQUVELE1BQU0sT0FBTyxDQUFDLFFBQVEsRUFBRSxDQUFDO0lBQzNCLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQUVEOzs7Ozs7R0FNRztBQUNILEtBQUssVUFBVSxhQUFhLENBQUMsTUFBYyxFQUFFLE1BQWM7SUFDekQsSUFBSSxLQUFLLEdBQUcsR0FBRyxDQUFDO0lBQ2hCLElBQUksUUFBUSxHQUFHLENBQUMsQ0FBQztJQUNqQixPQUFPLElBQUksRUFBRSxDQUFDO1FBQ1osSUFBSSxDQUFDO1lBQ0gsb0dBQW9HO1lBQ3BHLE1BQU0sYUFBRSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQUM7WUFDaEMsT0FBTztRQUNULENBQUM7UUFBQyxPQUFPLENBQU0sRUFBRSxDQUFDO1lBQ2hCLElBQUksQ0FBQyxDQUFDLElBQUksS0FBSyxPQUFPLElBQUksUUFBUSxFQUFFLElBQUksQ0FBQyxFQUFFLENBQUM7Z0JBQzFDLE1BQU0sQ0FBQyxDQUFDO1lBQ1YsQ0FBQztZQUNELElBQUEsZUFBSyxFQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUNqQixNQUFNLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsR0FBRyxLQUFLLENBQUMsQ0FBQyxDQUFDO1lBQy9DLEtBQUssSUFBSSxDQUFDLENBQUM7UUFDYixDQUFDO0lBQ0gsQ0FBQztBQUNILENBQUM7QUFFRCxTQUFTLEtBQUssQ0FBQyxFQUFVO0lBQ3ZCLE9BQU8sSUFBSSxPQUFPLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDL0MsQ0FBQztBQUVELFNBQVMsWUFBWTtJQUNuQixPQUFPLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUMsT0FBTyxDQUFDLGFBQWEsRUFBRSxFQUFFLENBQUMsQ0FBQztBQUMvRCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXJyb3IgfSBmcm9tICdjb25zb2xlJztcbmltcG9ydCB7IGNyZWF0ZVdyaXRlU3RyZWFtLCBwcm9taXNlcyBhcyBmcyB9IGZyb20gJ2ZzJztcbmltcG9ydCAqIGFzIHBhdGggZnJvbSAncGF0aCc7XG5pbXBvcnQgKiBhcyBnbG9iIGZyb20gJ2dsb2InO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXJlcXVpcmUtaW1wb3J0c1xuY29uc3QgYXJjaGl2ZXIgPSByZXF1aXJlKCdhcmNoaXZlcicpO1xuXG4vLyBBZGFwdGVkIGZyb20gY2RrLWFzc2V0c1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHppcERpcmVjdG9yeShkaXJlY3Rvcnk6IHN0cmluZywgb3V0cHV0RmlsZTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG4gIC8vIFdlIHdyaXRlIHRvIGEgdGVtcG9yYXJ5IGZpbGUgYW5kIHJlbmFtZSBhdCB0aGUgbGFzdCBtb21lbnQuIFRoaXMgaXMgc28gdGhhdCBpZiB3ZSBhcmVcbiAgLy8gaW50ZXJydXB0ZWQgZHVyaW5nIHRoaXMgcHJvY2Vzcywgd2UgZG9uJ3QgbGVhdmUgYSBoYWxmLWZpbmlzaGVkIGZpbGUgaW4gdGhlIHRhcmdldCBsb2NhdGlvbi5cbiAgY29uc3QgdGVtcG9yYXJ5T3V0cHV0RmlsZSA9IGAke291dHB1dEZpbGV9LiR7cmFuZG9tU3RyaW5nKCl9Ll90bXBgO1xuICBhd2FpdCB3cml0ZVppcEZpbGUoZGlyZWN0b3J5LCB0ZW1wb3JhcnlPdXRwdXRGaWxlKTtcbiAgYXdhaXQgbW92ZUludG9QbGFjZSh0ZW1wb3JhcnlPdXRwdXRGaWxlLCBvdXRwdXRGaWxlKTtcbn1cblxuZnVuY3Rpb24gd3JpdGVaaXBGaWxlKGRpcmVjdG9yeTogc3RyaW5nLCBvdXRwdXRGaWxlOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChvaywgZmFpbCkgPT4ge1xuICAgIC8vIFRoZSBiZWxvdyBvcHRpb25zIGFyZSBuZWVkZWQgdG8gc3VwcG9ydCBmb2xsb3dpbmcgc3ltbGlua3Mgd2hlbiBidWlsZGluZyB6aXAgZmlsZXM6XG4gICAgLy8gLSBub2RpcjogVGhpcyB3aWxsIHByZXZlbnQgc3ltbGlua3MgdGhlbXNlbHZlcyBmcm9tIGJlaW5nIGNvcGllZCBpbnRvIHRoZSB6aXAuXG4gICAgLy8gLSBmb2xsb3c6IFRoaXMgd2lsbCBmb2xsb3cgc3ltbGlua3MgYW5kIGNvcHkgdGhlIGZpbGVzIHdpdGhpbi5cbiAgICBjb25zdCBnbG9iT3B0aW9ucyA9IHtcbiAgICAgIGRvdDogdHJ1ZSxcbiAgICAgIG5vZGlyOiB0cnVlLFxuICAgICAgZm9sbG93OiB0cnVlLFxuICAgICAgY3dkOiBkaXJlY3RvcnksXG4gICAgfTtcbiAgICBjb25zdCBmaWxlcyA9IGdsb2Iuc3luYygnKionLCBnbG9iT3B0aW9ucyk7IC8vIFRoZSBvdXRwdXQgaGVyZSBpcyBhbHJlYWR5IHNvcnRlZFxuXG4gICAgY29uc3Qgb3V0cHV0ID0gY3JlYXRlV3JpdGVTdHJlYW0ob3V0cHV0RmlsZSk7XG5cbiAgICBjb25zdCBhcmNoaXZlID0gYXJjaGl2ZXIoJ3ppcCcpO1xuICAgIGFyY2hpdmUub24oJ3dhcm5pbmcnLCBmYWlsKTtcbiAgICBhcmNoaXZlLm9uKCdlcnJvcicsIGZhaWwpO1xuXG4gICAgLy8gYXJjaGl2ZSBoYXMgYmVlbiBmaW5hbGl6ZWQgYW5kIHRoZSBvdXRwdXQgZmlsZSBkZXNjcmlwdG9yIGhhcyBjbG9zZWQsIHJlc29sdmUgcHJvbWlzZVxuICAgIC8vIHRoaXMgaGFzIHRvIGJlIGRvbmUgYmVmb3JlIGNhbGxpbmcgYGZpbmFsaXplYCBzaW5jZSB0aGUgZXZlbnRzIG1heSBmaXJlIGltbWVkaWF0ZWx5IGFmdGVyLlxuICAgIC8vIHNlZSBodHRwczovL3d3dy5ucG1qcy5jb20vcGFja2FnZS9hcmNoaXZlclxuICAgIG91dHB1dC5vbmNlKCdjbG9zZScsIG9rKTtcblxuICAgIGFyY2hpdmUucGlwZShvdXRwdXQpO1xuXG4gICAgLy8gQXBwZW5kIGZpbGVzIHNlcmlhbGx5IHRvIGVuc3VyZSBmaWxlIG9yZGVyXG4gICAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgICBjb25zdCBmdWxsUGF0aCA9IHBhdGgucmVzb2x2ZShkaXJlY3RvcnksIGZpbGUpO1xuICAgICAgLy8gRXhhY3RseSAyIHByb21pc2VzXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQGNka2xhYnMvcHJvbWlzZWFsbC1uby11bmJvdW5kZWQtcGFyYWxsZWxpc21cbiAgICAgIGNvbnN0IFtkYXRhLCBzdGF0XSA9IGF3YWl0IFByb21pc2UuYWxsKFtmcy5yZWFkRmlsZShmdWxsUGF0aCksIGZzLnN0YXQoZnVsbFBhdGgpXSk7XG4gICAgICBhcmNoaXZlLmFwcGVuZChkYXRhLCB7XG4gICAgICAgIG5hbWU6IGZpbGUsXG4gICAgICAgIG1vZGU6IHN0YXQubW9kZSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGF3YWl0IGFyY2hpdmUuZmluYWxpemUoKTtcbiAgfSk7XG59XG5cbi8qKlxuICogUmVuYW1lIHRoZSBmaWxlIHRvIHRoZSB0YXJnZXQgbG9jYXRpb24sIHRha2luZyBpbnRvIGFjY291bnQ6XG4gKlxuICogLSBUaGF0IHdlIG1heSBzZWUgRVBFUk0gb24gV2luZG93cyB3aGlsZSBhbiBBbnRpdmlydXMgc2Nhbm5lciBzdGlsbCBoYXMgdGhlXG4gKiAgIGZpbGUgb3Blbiwgc28gcmV0cnkgYSBjb3VwbGUgb2YgdGltZXMuXG4gKiAtIFRoaXMgc2FtZSBmdW5jdGlvbiBtYXkgYmUgY2FsbGVkIGluIHBhcmFsbGVsIGFuZCBiZSBpbnRlcnJ1cHRlZCBhdCBhbnkgcG9pbnQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIG1vdmVJbnRvUGxhY2Uoc291cmNlOiBzdHJpbmcsIHRhcmdldDogc3RyaW5nKSB7XG4gIGxldCBkZWxheSA9IDEwMDtcbiAgbGV0IGF0dGVtcHRzID0gNTtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICB0cnkge1xuICAgICAgLy8gJ3JlbmFtZScgaXMgZ3VhcmFudGVlZCB0byBvdmVyd3JpdGUgYW4gZXhpc3RpbmcgdGFyZ2V0LCBhcyBsb25nIGFzIGl0IGlzIGEgZmlsZSAobm90IGEgZGlyZWN0b3J5KVxuICAgICAgYXdhaXQgZnMucmVuYW1lKHNvdXJjZSwgdGFyZ2V0KTtcbiAgICAgIHJldHVybjtcbiAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgIGlmIChlLmNvZGUgIT09ICdFUEVSTScgfHwgYXR0ZW1wdHMtLSA8PSAwKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgICBlcnJvcihlLm1lc3NhZ2UpO1xuICAgICAgYXdhaXQgc2xlZXAoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogZGVsYXkpKTtcbiAgICAgIGRlbGF5ICo9IDI7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNsZWVwKG1zOiBudW1iZXIpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKG9rID0+IHNldFRpbWVvdXQob2ssIG1zKSk7XG59XG5cbmZ1bmN0aW9uIHJhbmRvbVN0cmluZygpIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnJlcGxhY2UoL1teYS16MC05XSsvZywgJycpO1xufVxuIl19