"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CloudFormationDeployments = exports.Deployments = void 0;
const crypto_1 = require("crypto");
const cdk_assets = require("cdk-assets");
const cdk_assets_1 = require("cdk-assets");
const chalk = require("chalk");
const logging_1 = require("../logging");
const credentials_1 = require("./aws-auth/credentials");
const deploy_stack_1 = require("./deploy-stack");
const environment_resources_1 = require("./environment-resources");
const nested_stack_helpers_1 = require("./nested-stack-helpers");
const cloudformation_1 = require("./util/cloudformation");
const stack_activity_monitor_1 = require("./util/cloudformation/stack-activity-monitor");
const stack_event_poller_1 = require("./util/cloudformation/stack-event-poller");
const stack_status_1 = require("./util/cloudformation/stack-status");
const placeholders_1 = require("./util/placeholders");
const template_body_parameter_1 = require("./util/template-body-parameter");
const asset_manifest_builder_1 = require("../util/asset-manifest-builder");
const asset_publishing_1 = require("../util/asset-publishing");
const BOOTSTRAP_STACK_VERSION_FOR_ROLLBACK = 23;
/**
 * Scope for a single set of deployments from a set of Cloud Assembly Artifacts
 *
 * Manages lookup of SDKs, Bootstrap stacks, etc.
 */
class Deployments {
    constructor(props) {
        this.props = props;
        this.sdkCache = new Map();
        this.publisherCache = new Map();
        this.sdkProvider = props.sdkProvider;
        this.environmentResources = new environment_resources_1.EnvironmentResourcesRegistry(props.toolkitStackName);
    }
    /**
     * Resolves the environment for a stack.
     */
    async resolveEnvironment(stack) {
        return this.sdkProvider.resolveEnvironment(stack.environment);
    }
    async readCurrentTemplateWithNestedStacks(rootStackArtifact, retrieveProcessedTemplate = false) {
        const sdk = (await this.prepareSdkWithLookupOrDeployRole(rootStackArtifact)).stackSdk;
        return (0, nested_stack_helpers_1.loadCurrentTemplateWithNestedStacks)(rootStackArtifact, sdk, retrieveProcessedTemplate);
    }
    async readCurrentTemplate(stackArtifact) {
        (0, logging_1.debug)(`Reading existing template for stack ${stackArtifact.displayName}.`);
        const sdk = (await this.prepareSdkWithLookupOrDeployRole(stackArtifact)).stackSdk;
        return (0, nested_stack_helpers_1.loadCurrentTemplate)(stackArtifact, sdk);
    }
    async resourceIdentifierSummaries(stackArtifact) {
        (0, logging_1.debug)(`Retrieving template summary for stack ${stackArtifact.displayName}.`);
        // Currently, needs to use `deploy-role` since it may need to read templates in the staging
        // bucket which have been encrypted with a KMS key (and lookup-role may not read encrypted things)
        const { stackSdk, resolvedEnvironment, envResources } = await this.prepareSdkFor(stackArtifact, undefined, credentials_1.Mode.ForReading);
        const cfn = stackSdk.cloudFormation();
        await (0, cloudformation_1.uploadStackTemplateAssets)(stackArtifact, this);
        // Upload the template, if necessary, before passing it to CFN
        const builder = new asset_manifest_builder_1.AssetManifestBuilder();
        const cfnParam = await (0, template_body_parameter_1.makeBodyParameter)(stackArtifact, resolvedEnvironment, builder, envResources, stackSdk);
        // If the `makeBodyParameter` before this added assets, make sure to publish them before
        // calling the API.
        const addedAssets = builder.toManifest(stackArtifact.assembly.directory);
        for (const entry of addedAssets.entries) {
            await this.buildSingleAsset('no-version-validation', addedAssets, entry, {
                stack: stackArtifact,
            });
            await this.publishSingleAsset(addedAssets, entry, {
                stack: stackArtifact,
            });
        }
        const response = await cfn.getTemplateSummary(cfnParam).promise();
        if (!response.ResourceIdentifierSummaries) {
            (0, logging_1.debug)('GetTemplateSummary API call did not return "ResourceIdentifierSummaries"');
        }
        return response.ResourceIdentifierSummaries ?? [];
    }
    async deployStack(options) {
        let deploymentMethod = options.deploymentMethod;
        if (options.changeSetName || options.execute !== undefined) {
            if (deploymentMethod) {
                throw new Error('You cannot supply both \'deploymentMethod\' and \'changeSetName/execute\'. Supply one or the other.');
            }
            deploymentMethod = {
                method: 'change-set',
                changeSetName: options.changeSetName,
                execute: options.execute,
            };
        }
        const { stackSdk, resolvedEnvironment, cloudFormationRoleArn, envResources, } = await this.prepareSdkFor(options.stack, options.roleArn, credentials_1.Mode.ForWriting);
        // Do a verification of the bootstrap stack version
        await this.validateBootstrapStackVersion(options.stack.stackName, options.stack.requiresBootstrapStackVersion, options.stack.bootstrapStackVersionSsmParameter, envResources);
        return (0, deploy_stack_1.deployStack)({
            stack: options.stack,
            resolvedEnvironment,
            deployName: options.deployName,
            notificationArns: options.notificationArns,
            quiet: options.quiet,
            sdk: stackSdk,
            sdkProvider: this.sdkProvider,
            roleArn: cloudFormationRoleArn,
            reuseAssets: options.reuseAssets,
            envResources,
            tags: options.tags,
            deploymentMethod,
            force: options.force,
            parameters: options.parameters,
            usePreviousParameters: options.usePreviousParameters,
            progress: options.progress,
            ci: options.ci,
            rollback: options.rollback,
            hotswap: options.hotswap,
            extraUserAgent: options.extraUserAgent,
            resourcesToImport: options.resourcesToImport,
            overrideTemplate: options.overrideTemplate,
            assetParallelism: options.assetParallelism,
        });
    }
    async rollbackStack(options) {
        let resourcesToSkip = options.orphanLogicalIds ?? [];
        if (options.force && resourcesToSkip.length > 0) {
            throw new Error('Cannot combine --force with --orphan');
        }
        const { stackSdk, resolvedEnvironment: _, cloudFormationRoleArn, envResources, } = await this.prepareSdkFor(options.stack, options.roleArn, credentials_1.Mode.ForWriting);
        if (options.validateBootstrapStackVersion ?? true) {
            // Do a verification of the bootstrap stack version
            await this.validateBootstrapStackVersion(options.stack.stackName, BOOTSTRAP_STACK_VERSION_FOR_ROLLBACK, options.stack.bootstrapStackVersionSsmParameter, envResources);
        }
        const cfn = stackSdk.cloudFormation();
        const deployName = options.stack.stackName;
        // We loop in case of `--force` and the stack ends up in `CONTINUE_UPDATE_ROLLBACK`.
        let maxLoops = 10;
        while (maxLoops--) {
            let cloudFormationStack = await cloudformation_1.CloudFormationStack.lookup(cfn, deployName);
            switch (cloudFormationStack.stackStatus.rollbackChoice) {
                case stack_status_1.RollbackChoice.NONE:
                    (0, logging_1.warning)(`Stack ${deployName} does not need a rollback: ${cloudFormationStack.stackStatus}`);
                    return { notInRollbackableState: true };
                case stack_status_1.RollbackChoice.START_ROLLBACK:
                    (0, logging_1.debug)(`Initiating rollback of stack ${deployName}`);
                    await cfn.rollbackStack({
                        StackName: deployName,
                        RoleARN: cloudFormationRoleArn,
                        ClientRequestToken: (0, crypto_1.randomUUID)(),
                        // Enabling this is just the better overall default, the only reason it isn't the upstream default is backwards compatibility
                        RetainExceptOnCreate: true,
                    }).promise();
                    break;
                case stack_status_1.RollbackChoice.CONTINUE_UPDATE_ROLLBACK:
                    if (options.force) {
                        // Find the failed resources from the deployment and automatically skip them
                        // (Using deployment log because we definitely have `DescribeStackEvents` permissions, and we might not have
                        // `DescribeStackResources` permissions).
                        const poller = new stack_event_poller_1.StackEventPoller(cfn, {
                            stackName: deployName,
                            stackStatuses: ['ROLLBACK_IN_PROGRESS', 'UPDATE_ROLLBACK_IN_PROGRESS'],
                        });
                        await poller.poll();
                        resourcesToSkip = poller.resourceErrors
                            .filter(r => !r.isStackEvent && r.parentStackLogicalIds.length === 0)
                            .map(r => r.event.LogicalResourceId ?? '');
                    }
                    const skipDescription = resourcesToSkip.length > 0
                        ? ` (orphaning: ${resourcesToSkip.join(', ')})`
                        : '';
                    (0, logging_1.warning)(`Continuing rollback of stack ${deployName}${skipDescription}`);
                    await cfn.continueUpdateRollback({
                        StackName: deployName,
                        ClientRequestToken: (0, crypto_1.randomUUID)(),
                        RoleARN: cloudFormationRoleArn,
                        ResourcesToSkip: resourcesToSkip,
                    }).promise();
                    break;
                case stack_status_1.RollbackChoice.ROLLBACK_FAILED:
                    (0, logging_1.warning)(`Stack ${deployName} failed creation and rollback. This state cannot be rolled back. You can recreate this stack by running 'cdk deploy'.`);
                    return { notInRollbackableState: true };
                default:
                    throw new Error(`Unexpected rollback choice: ${cloudFormationStack.stackStatus.rollbackChoice}`);
            }
            const monitor = options.quiet ? undefined : stack_activity_monitor_1.StackActivityMonitor.withDefaultPrinter(cfn, deployName, options.stack, {
                ci: options.ci,
            }).start();
            let stackErrorMessage = undefined;
            let finalStackState = cloudFormationStack;
            try {
                const successStack = await (0, cloudformation_1.stabilizeStack)(cfn, deployName);
                // This shouldn't really happen, but catch it anyway. You never know.
                if (!successStack) {
                    throw new Error('Stack deploy failed (the stack disappeared while we were rolling it back)');
                }
                finalStackState = successStack;
                const errors = monitor?.errors?.join(', ');
                if (errors) {
                    stackErrorMessage = errors;
                }
            }
            catch (e) {
                stackErrorMessage = suffixWithErrors(e.message, monitor?.errors);
            }
            finally {
                await monitor?.stop();
            }
            if (finalStackState.stackStatus.isRollbackSuccess || !stackErrorMessage) {
                return { success: true };
            }
            // Either we need to ignore some resources to continue the rollback, or something went wrong
            if (finalStackState.stackStatus.rollbackChoice === stack_status_1.RollbackChoice.CONTINUE_UPDATE_ROLLBACK && options.force) {
                // Do another loop-de-loop
                continue;
            }
            throw new Error(`${stackErrorMessage} (fix problem and retry, or orphan these resources using --orphan or --force)`);
            ;
        }
        throw new Error('Rollback did not finish after a large number of iterations; stopping because it looks like we\'re not making progress anymore. You can retry if rollback was progressing as expected.');
    }
    async destroyStack(options) {
        const { stackSdk, cloudFormationRoleArn: roleArn } = await this.prepareSdkFor(options.stack, options.roleArn, credentials_1.Mode.ForWriting);
        return (0, deploy_stack_1.destroyStack)({
            sdk: stackSdk,
            roleArn,
            stack: options.stack,
            deployName: options.deployName,
            quiet: options.quiet,
            ci: options.ci,
        });
    }
    async stackExists(options) {
        let stackSdk;
        if (options.tryLookupRole) {
            stackSdk = (await this.prepareSdkWithLookupOrDeployRole(options.stack)).stackSdk;
        }
        else {
            stackSdk = (await this.prepareSdkFor(options.stack, undefined, credentials_1.Mode.ForReading)).stackSdk;
        }
        const stack = await cloudformation_1.CloudFormationStack.lookup(stackSdk.cloudFormation(), options.deployName ?? options.stack.stackName);
        return stack.exists;
    }
    async prepareSdkWithDeployRole(stackArtifact) {
        return this.prepareSdkFor(stackArtifact, undefined, credentials_1.Mode.ForWriting);
    }
    async prepareSdkWithLookupOrDeployRole(stackArtifact) {
        // try to assume the lookup role
        try {
            const result = await this.prepareSdkWithLookupRoleFor(stackArtifact);
            if (result.didAssumeRole) {
                return {
                    resolvedEnvironment: result.resolvedEnvironment,
                    stackSdk: result.sdk,
                    envResources: result.envResources,
                };
            }
        }
        catch { }
        // fall back to the deploy role
        return this.prepareSdkFor(stackArtifact, undefined, credentials_1.Mode.ForReading);
    }
    /**
     * Get the environment necessary for touching the given stack
     *
     * Returns the following:
     *
     * - The resolved environment for the stack (no more 'unknown-account/unknown-region')
     * - SDK loaded with the right credentials for calling `CreateChangeSet`.
     * - The Execution Role that should be passed to CloudFormation.
     */
    async prepareSdkFor(stack, roleArn, mode) {
        if (!stack.environment) {
            throw new Error(`The stack ${stack.displayName} does not have an environment`);
        }
        const resolvedEnvironment = await this.resolveEnvironment(stack);
        // Substitute any placeholders with information about the current environment
        const arns = await (0, placeholders_1.replaceEnvPlaceholders)({
            assumeRoleArn: stack.assumeRoleArn,
            // Use the override if given, otherwise use the field from the stack
            cloudFormationRoleArn: roleArn ?? stack.cloudFormationExecutionRoleArn,
        }, resolvedEnvironment, this.sdkProvider);
        const stackSdk = await this.cachedSdkForEnvironment(resolvedEnvironment, mode, {
            assumeRoleArn: arns.assumeRoleArn,
            assumeRoleExternalId: stack.assumeRoleExternalId,
            assumeRoleAdditionalOptions: stack.assumeRoleAdditionalOptions,
        });
        return {
            stackSdk: stackSdk.sdk,
            resolvedEnvironment,
            cloudFormationRoleArn: arns.cloudFormationRoleArn,
            envResources: this.environmentResources.for(resolvedEnvironment, stackSdk.sdk),
        };
    }
    /**
      * Try to use the bootstrap lookupRole. There are two scenarios that are handled here
      *  1. The lookup role may not exist (it was added in bootstrap stack version 7)
      *  2. The lookup role may not have the correct permissions (ReadOnlyAccess was added in
      *      bootstrap stack version 8)
      *
      * In the case of 1 (lookup role doesn't exist) `forEnvironment` will either:
      *   1. Return the default credentials if the default credentials are for the stack account
      *   2. Throw an error if the default credentials are not for the stack account.
      *
      * If we successfully assume the lookup role we then proceed to 2 and check whether the bootstrap
      * stack version is valid. If it is not we throw an error which should be handled in the calling
      * function (and fallback to use a different role, etc)
      *
      * If we do not successfully assume the lookup role, but do get back the default credentials
      * then return those and note that we are returning the default credentials. The calling
      * function can then decide to use them or fallback to another role.
      */
    async prepareSdkWithLookupRoleFor(stack) {
        const resolvedEnvironment = await this.sdkProvider.resolveEnvironment(stack.environment);
        // Substitute any placeholders with information about the current environment
        const arns = await (0, placeholders_1.replaceEnvPlaceholders)({
            lookupRoleArn: stack.lookupRole?.arn,
        }, resolvedEnvironment, this.sdkProvider);
        // try to assume the lookup role
        const warningMessage = `Could not assume ${arns.lookupRoleArn}, proceeding anyway.`;
        try {
            // Trying to assume lookup role and cache the sdk for the environment
            const stackSdk = await this.cachedSdkForEnvironment(resolvedEnvironment, credentials_1.Mode.ForReading, {
                assumeRoleArn: arns.lookupRoleArn,
                assumeRoleExternalId: stack.lookupRole?.assumeRoleExternalId,
                assumeRoleAdditionalOptions: stack.lookupRole?.assumeRoleAdditionalOptions,
            });
            const envResources = this.environmentResources.for(resolvedEnvironment, stackSdk.sdk);
            // if we succeed in assuming the lookup role, make sure we have the correct bootstrap stack version
            if (stackSdk.didAssumeRole && stack.lookupRole?.bootstrapStackVersionSsmParameter && stack.lookupRole.requiresBootstrapStackVersion) {
                const version = await envResources.versionFromSsmParameter(stack.lookupRole.bootstrapStackVersionSsmParameter);
                if (version < stack.lookupRole.requiresBootstrapStackVersion) {
                    throw new Error(`Bootstrap stack version '${stack.lookupRole.requiresBootstrapStackVersion}' is required, found version '${version}'. To get rid of this error, please upgrade to bootstrap version >= ${stack.lookupRole.requiresBootstrapStackVersion}`);
                }
            }
            else if (!stackSdk.didAssumeRole) {
                const lookUpRoleExists = stack.lookupRole ? true : false;
                (0, logging_1.warning)(`Lookup role ${lookUpRoleExists ? 'exists but' : 'does not exist, hence'} was not assumed. Proceeding with default credentials.`);
            }
            return { ...stackSdk, resolvedEnvironment, envResources };
        }
        catch (e) {
            (0, logging_1.debug)(e);
            // only print out the warnings if the lookupRole exists
            if (stack.lookupRole) {
                (0, logging_1.warning)(warningMessage);
            }
            // This error should be shown even if debug mode is off
            if (e instanceof Error && e.message.includes('Bootstrap stack version')) {
                (0, logging_1.error)(e.message);
            }
            throw (e);
        }
    }
    async prepareAndValidateAssets(asset, options) {
        const { envResources } = await this.prepareSdkFor(options.stack, options.roleArn, credentials_1.Mode.ForWriting);
        await this.validateBootstrapStackVersion(options.stack.stackName, asset.requiresBootstrapStackVersion, asset.bootstrapStackVersionSsmParameter, envResources);
        const manifest = cdk_assets_1.AssetManifest.fromFile(asset.file);
        return { manifest, stackEnv: envResources.environment };
    }
    /**
     * Build all assets in a manifest
     *
     * @deprecated Use `buildSingleAsset` instead
     */
    async buildAssets(asset, options) {
        const { manifest, stackEnv } = await this.prepareAndValidateAssets(asset, options);
        await (0, asset_publishing_1.buildAssets)(manifest, this.sdkProvider, stackEnv, options.buildOptions);
    }
    /**
     * Publish all assets in a manifest
     *
     * @deprecated Use `publishSingleAsset` instead
     */
    async publishAssets(asset, options) {
        const { manifest, stackEnv } = await this.prepareAndValidateAssets(asset, options);
        await (0, asset_publishing_1.publishAssets)(manifest, this.sdkProvider, stackEnv, options.publishOptions);
    }
    /**
     * Build a single asset from an asset manifest
     *
     * If an assert manifest artifact is given, the bootstrap stack version
     * will be validated according to the constraints in that manifest artifact.
     * If that is not necessary, `'no-version-validation'` can be passed.
     */
    // eslint-disable-next-line max-len
    async buildSingleAsset(assetArtifact, assetManifest, asset, options) {
        const { resolvedEnvironment, envResources } = await this.prepareSdkFor(options.stack, options.roleArn, credentials_1.Mode.ForWriting);
        if (assetArtifact !== 'no-version-validation') {
            await this.validateBootstrapStackVersion(options.stack.stackName, assetArtifact.requiresBootstrapStackVersion, assetArtifact.bootstrapStackVersionSsmParameter, envResources);
        }
        const publisher = this.cachedPublisher(assetManifest, resolvedEnvironment, options.stackName);
        await publisher.buildEntry(asset);
        if (publisher.hasFailures) {
            throw new Error(`Failed to build asset ${asset.id}`);
        }
    }
    /**
     * Publish a single asset from an asset manifest
     */
    // eslint-disable-next-line max-len
    async publishSingleAsset(assetManifest, asset, options) {
        const { resolvedEnvironment: stackEnv } = await this.prepareSdkFor(options.stack, options.roleArn, credentials_1.Mode.ForWriting);
        // No need to validate anymore, we already did that during build
        const publisher = this.cachedPublisher(assetManifest, stackEnv, options.stackName);
        await publisher.publishEntry(asset);
        if (publisher.hasFailures) {
            throw new Error(`Failed to publish asset ${asset.id}`);
        }
    }
    /**
     * Return whether a single asset has been published already
     */
    async isSingleAssetPublished(assetManifest, asset, options) {
        const { resolvedEnvironment: stackEnv } = await this.prepareSdkFor(options.stack, options.roleArn, credentials_1.Mode.ForWriting);
        const publisher = this.cachedPublisher(assetManifest, stackEnv, options.stackName);
        return publisher.isEntryPublished(asset);
    }
    /**
     * Validate that the bootstrap stack has the right version for this stack
     *
     * Call into envResources.validateVersion, but prepend the stack name in case of failure.
     */
    async validateBootstrapStackVersion(stackName, requiresBootstrapStackVersion, bootstrapStackVersionSsmParameter, envResources) {
        try {
            await envResources.validateVersion(requiresBootstrapStackVersion, bootstrapStackVersionSsmParameter);
        }
        catch (e) {
            throw new Error(`${stackName}: ${e.message}`);
        }
    }
    async cachedSdkForEnvironment(environment, mode, options) {
        const cacheKeyElements = [
            environment.account,
            environment.region,
            `${mode}`,
            options?.assumeRoleArn ?? '',
            options?.assumeRoleExternalId ?? '',
        ];
        if (options?.assumeRoleAdditionalOptions) {
            cacheKeyElements.push(JSON.stringify(options.assumeRoleAdditionalOptions));
        }
        const cacheKey = cacheKeyElements.join(':');
        const existing = this.sdkCache.get(cacheKey);
        if (existing) {
            return existing;
        }
        const ret = await this.sdkProvider.forEnvironment(environment, mode, options);
        this.sdkCache.set(cacheKey, ret);
        return ret;
    }
    cachedPublisher(assetManifest, env, stackName) {
        const existing = this.publisherCache.get(assetManifest);
        if (existing) {
            return existing;
        }
        const prefix = stackName ? `${chalk.bold(stackName)}: ` : '';
        const publisher = new cdk_assets.AssetPublishing(assetManifest, {
            aws: new asset_publishing_1.PublishingAws(this.sdkProvider, env),
            progressListener: new ParallelSafeAssetProgress(prefix, this.props.quiet ?? false),
        });
        this.publisherCache.set(assetManifest, publisher);
        return publisher;
    }
}
exports.Deployments = Deployments;
/**
 * Asset progress that doesn't do anything with percentages (currently)
 */
class ParallelSafeAssetProgress {
    constructor(prefix, quiet) {
        this.prefix = prefix;
        this.quiet = quiet;
    }
    onPublishEvent(type, event) {
        const handler = this.quiet && type !== 'fail' ? logging_1.debug : asset_publishing_1.EVENT_TO_LOGGER[type];
        handler(`${this.prefix}${type}: ${event.message}`);
    }
}
/**
 * @deprecated Use 'Deployments' instead
 */
class CloudFormationDeployments extends Deployments {
}
exports.CloudFormationDeployments = CloudFormationDeployments;
function suffixWithErrors(msg, errors) {
    return errors && errors.length > 0
        ? `${msg}: ${errors.join(', ')}`
        : msg;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVwbG95bWVudHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJkZXBsb3ltZW50cy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSxtQ0FBb0M7QUFFcEMseUNBQXlDO0FBQ3pDLDJDQUEyRDtBQUMzRCwrQkFBK0I7QUFFL0Isd0NBQW1EO0FBQ25ELHdEQUE4QztBQUc5QyxpREFBZ0c7QUFDaEcsbUVBQTZGO0FBRTdGLGlFQUFnSTtBQUNoSSwwREFBaUs7QUFDaksseUZBQTJHO0FBQzNHLGlGQUE0RTtBQUM1RSxxRUFBb0U7QUFDcEUsc0RBQTZEO0FBQzdELDRFQUFtRTtBQUNuRSwyRUFBc0U7QUFDdEUsK0RBQWdKO0FBRWhKLE1BQU0sb0NBQW9DLEdBQUcsRUFBRSxDQUFDO0FBZ1doRDs7OztHQUlHO0FBQ0gsTUFBYSxXQUFXO0lBTXRCLFlBQTZCLEtBQXVCO1FBQXZCLFVBQUssR0FBTCxLQUFLLENBQWtCO1FBSm5DLGFBQVEsR0FBRyxJQUFJLEdBQUcsRUFBNkIsQ0FBQztRQUNoRCxtQkFBYyxHQUFHLElBQUksR0FBRyxFQUE2QyxDQUFDO1FBSXJGLElBQUksQ0FBQyxXQUFXLEdBQUcsS0FBSyxDQUFDLFdBQVcsQ0FBQztRQUNyQyxJQUFJLENBQUMsb0JBQW9CLEdBQUcsSUFBSSxvREFBNEIsQ0FBQyxLQUFLLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztJQUN2RixDQUFDO0lBRUQ7O09BRUc7SUFDSSxLQUFLLENBQUMsa0JBQWtCLENBQUMsS0FBd0M7UUFDdEUsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDLGtCQUFrQixDQUFDLEtBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUNoRSxDQUFDO0lBRU0sS0FBSyxDQUFDLG1DQUFtQyxDQUM5QyxpQkFBb0QsRUFDcEQsNEJBQXFDLEtBQUs7UUFFMUMsTUFBTSxHQUFHLEdBQUcsQ0FBQyxNQUFNLElBQUksQ0FBQyxnQ0FBZ0MsQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFD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QW1CLFVBQUssR0FBTCxLQUFLLENBQVM7SUFDNUUsQ0FBQztJQUVNLGNBQWMsQ0FBQyxJQUEwQixFQUFFLEtBQWtDO1FBQ2xGLE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxLQUFLLElBQUksSUFBSSxLQUFLLE1BQU0sQ0FBQyxDQUFDLENBQUMsZUFBSyxDQUFDLENBQUMsQ0FBQyxrQ0FBZSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQzlFLE9BQU8sQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLEdBQUcsSUFBSSxLQUFLLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDO0lBQ3JELENBQUM7Q0FDRjtBQUVEOztHQUVHO0FBQ0gsTUFBYSx5QkFBMEIsU0FBUSxXQUFXO0NBQ3pEO0FBREQsOERBQ0M7QUFFRCxTQUFTLGdCQUFnQixDQUFDLEdBQVcsRUFBRSxNQUFpQjtJQUN0RCxPQUFPLE1BQU0sSUFBSSxNQUFNLENBQUMsTUFBTSxHQUFHLENBQUM7UUFDaEMsQ0FBQyxDQUFDLEdBQUcsR0FBRyxLQUFLLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFDaEMsQ0FBQyxDQUFDLEdBQUcsQ0FBQztBQUNWLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByYW5kb21VVUlEIH0gZnJvbSAnY3J5cHRvJztcbmltcG9ydCAqIGFzIGN4YXBpIGZyb20gJ0Bhd3MtY2RrL2N4LWFwaSc7XG5pbXBvcnQgKiBhcyBjZGtfYXNzZXRzIGZyb20gJ2Nkay1hc3NldHMnO1xuaW1wb3J0IHsgQXNzZXRNYW5pZmVzdCwgSU1hbmlmZXN0RW50cnkgfSBmcm9tICdjZGstYXNzZXRzJztcbmltcG9ydCAqIGFzIGNoYWxrIGZyb20gJ2NoYWxrJztcbmltcG9ydCB7IFRhZyB9IGZyb20gJy4uL2Nkay10b29sa2l0JztcbmltcG9ydCB7IGRlYnVnLCB3YXJuaW5nLCBlcnJvciB9IGZyb20gJy4uL2xvZ2dpbmcnO1xuaW1wb3J0IHsgTW9kZSB9IGZyb20gJy4vYXdzLWF1dGgvY3JlZGVudGlhbHMnO1xuaW1wb3J0IHsgSVNESyB9IGZyb20gJy4vYXdzLWF1dGgvc2RrJztcbmltcG9ydCB7IENyZWRlbnRpYWxzT3B0aW9ucywgU2RrRm9yRW52aXJvbm1lbnQsIFNka1Byb3ZpZGVyIH0gZnJvbSAnLi9hd3MtYXV0aC9zZGstcHJvdmlkZXInO1xuaW1wb3J0IHsgZGVwbG95U3RhY2ssIERlcGxveVN0YWNrUmVzdWx0LCBkZXN0cm95U3RhY2ssIERlcGxveW1lbnRNZXRob2QgfSBmcm9tICcuL2RlcGxveS1zdGFjayc7XG5pbXBvcnQgeyBFbnZpcm9ubWVudFJlc291cmNlcywgRW52aXJvbm1lbnRSZXNvdXJjZXNSZWdpc3RyeSB9IGZyb20gJy4vZW52aXJvbm1lbnQtcmVzb3VyY2VzJztcbmltcG9ydCB7IEhvdHN3YXBNb2RlIH0gZnJvbSAnLi9ob3Rzd2FwL2NvbW1vbic7XG5pbXBvcnQgeyBsb2FkQ3VycmVudFRlbXBsYXRlV2l0aE5lc3RlZFN0YWNrcywgbG9hZEN1cnJlbnRUZW1wbGF0ZSwgUm9vdFRlbXBsYXRlV2l0aE5lc3RlZFN0YWNrcyB9IGZyb20gJy4vbmVzdGVkLXN0YWNrLWhlbHBlcnMnO1xuaW1wb3J0IHsgQ2xvdWRGb3JtYXRpb25TdGFjaywgVGVtcGxhdGUsIFJlc291cmNlc1RvSW1wb3J0LCBSZXNvdXJjZUlkZW50aWZpZXJTdW1tYXJpZXMsIHN0YWJpbGl6ZVN0YWNrLCB1cGxvYWRTdGFja1RlbXBsYXRlQXNzZXRzIH0gZnJvbSAnLi91dGlsL2Nsb3VkZm9ybWF0aW9uJztcbmltcG9ydCB7IFN0YWNrQWN0aXZpdHlNb25pdG9yLCBTdGFja0FjdGl2aXR5UHJvZ3Jlc3MgfSBmcm9tICcuL3V0aWwvY2xvdWRmb3JtYXRpb24vc3RhY2stYWN0aXZpdHktbW9uaXRvcic7XG5pbXBvcnQgeyBTdGFja0V2ZW50UG9sbGVyIH0gZnJvbSAnLi91dGlsL2Nsb3VkZm9ybWF0aW9uL3N0YWNrLWV2ZW50LXBvbGxlcic7XG5pbXBvcnQgeyBSb2xsYmFja0Nob2ljZSB9IGZyb20gJy4vdXRpbC9jbG91ZGZvcm1hdGlvbi9zdGFjay1zdGF0dXMnO1xuaW1wb3J0IHsgcmVwbGFjZUVudlBsYWNlaG9sZGVycyB9IGZyb20gJy4vdXRpbC9wbGFjZWhvbGRlcnMnO1xuaW1wb3J0IHsgbWFrZUJvZHlQYXJhbWV0ZXIgfSBmcm9tICcuL3V0aWwvdGVtcGxhdGUtYm9keS1wYXJhbWV0ZXInO1xuaW1wb3J0IHsgQXNzZXRNYW5pZmVzdEJ1aWxkZXIgfSBmcm9tICcuLi91dGlsL2Fzc2V0LW1hbmlmZXN0LWJ1aWxkZXInO1xuaW1wb3J0IHsgYnVpbGRBc3NldHMsIHB1Ymxpc2hBc3NldHMsIEJ1aWxkQXNzZXRzT3B0aW9ucywgUHVibGlzaEFzc2V0c09wdGlvbnMsIFB1Ymxpc2hpbmdBd3MsIEVWRU5UX1RPX0xPR0dFUiB9IGZyb20gJy4uL3V0aWwvYXNzZXQtcHVibGlzaGluZyc7XG5cbmNvbnN0IEJPT1RTVFJBUF9TVEFDS19WRVJTSU9OX0ZPUl9ST0xMQkFDSyA9IDIzO1xuXG4vKipcbiAqIFNESyBvYnRhaW5lZCBieSBhc3N1bWluZyB0aGUgbG9va3VwIHJvbGVcbiAqIGZvciBhIGdpdmVuIGVudmlyb25tZW50XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUHJlcGFyZWRTZGtXaXRoTG9va3VwUm9sZUZvckVudmlyb25tZW50IHtcbiAgLyoqXG4gICAqIFRoZSBTREsgZm9yIHRoZSBnaXZlbiBlbnZpcm9ubWVudFxuICAgKi9cbiAgcmVhZG9ubHkgc2RrOiBJU0RLO1xuXG4gIC8qKlxuICAgKiBUaGUgcmVzb2x2ZWQgZW52aXJvbm1lbnQgZm9yIHRoZSBzdGFja1xuICAgKiAobm8gbW9yZSAndW5rbm93bi1hY2NvdW50L3Vua25vd24tcmVnaW9uJylcbiAgICovXG4gIHJlYWRvbmx5IHJlc29sdmVkRW52aXJvbm1lbnQ6IGN4YXBpLkVudmlyb25tZW50O1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIG9yIG5vdCB0aGUgYXNzdW1lIHJvbGUgd2FzIHN1Y2Nlc3NmdWwuXG4gICAqIElmIHRoZSBhc3N1bWUgcm9sZSB3YXMgbm90IHN1Y2Nlc3NmdWwgKGZhbHNlKVxuICAgKiB0aGVuIHRoYXQgbWVhbnMgdGhhdCB0aGUgJ3NkaycgcmV0dXJuZWQgY29udGFpbnNcbiAgICogdGhlIGRlZmF1bHQgY3JlZGVudGlhbHMgKG5vdCB0aGUgYXNzdW1lIHJvbGUgY3JlZGVudGlhbHMpXG4gICAqL1xuICByZWFkb25seSBkaWRBc3N1bWVSb2xlOiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBBbiBvYmplY3QgZm9yIGFjY2Vzc2luZyB0aGUgYm9vdHN0cmFwIHJlc291cmNlcyBpbiB0aGlzIGVudmlyb25tZW50XG4gICAqL1xuICByZWFkb25seSBlbnZSZXNvdXJjZXM6IEVudmlyb25tZW50UmVzb3VyY2VzO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIERlcGxveVN0YWNrT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBTdGFjayB0byBkZXBsb3lcbiAgICovXG4gIHJlYWRvbmx5IHN0YWNrOiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3Q7XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGlvbiByb2xlIGZvciB0aGUgZGVwbG95bWVudCAocGFzcyB0aHJvdWdoIHRvIENsb3VkRm9ybWF0aW9uKVxuICAgKlxuICAgKiBAZGVmYXVsdCAtIEN1cnJlbnQgcm9sZVxuICAgKi9cbiAgcmVhZG9ubHkgcm9sZUFybj86IHN0cmluZztcblxuICAvKipcbiAgICogVG9waWMgQVJOcyB0byBzZW5kIGEgbWVzc2FnZSB3aGVuIGRlcGxveW1lbnQgZmluaXNoZXMgKHBhc3MgdGhyb3VnaCB0byBDbG91ZEZvcm1hdGlvbilcbiAgICpcbiAgICogQGRlZmF1bHQgLSBObyBub3RpZmljYXRpb25zXG4gICAqL1xuICByZWFkb25seSBub3RpZmljYXRpb25Bcm5zPzogc3RyaW5nW107XG5cbiAgLyoqXG4gICAqIE92ZXJyaWRlIG5hbWUgdW5kZXIgd2hpY2ggc3RhY2sgd2lsbCBiZSBkZXBsb3llZFxuICAgKlxuICAgKiBAZGVmYXVsdCAtIFVzZSBhcnRpZmFjdCBkZWZhdWx0XG4gICAqL1xuICByZWFkb25seSBkZXBsb3lOYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBEb24ndCBzaG93IHN0YWNrIGRlcGxveW1lbnQgZXZlbnRzLCBqdXN0IHdhaXRcbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHJlYWRvbmx5IHF1aWV0PzogYm9vbGVhbjtcblxuICAvKipcbiAgICogTmFtZSBvZiB0aGUgdG9vbGtpdCBzdGFjaywgaWYgbm90IHRoZSBkZWZhdWx0IG5hbWVcbiAgICpcbiAgICogQGRlZmF1bHQgJ0NES1Rvb2xraXQnXG4gICAqL1xuICByZWFkb25seSB0b29sa2l0U3RhY2tOYW1lPzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBMaXN0IG9mIGFzc2V0IElEcyB3aGljaCBzaG91bGQgTk9UIGJlIGJ1aWx0IG9yIHVwbG9hZGVkXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gQnVpbGQgYWxsIGFzc2V0c1xuICAgKi9cbiAgcmVhZG9ubHkgcmV1c2VBc3NldHM/OiBzdHJpbmdbXTtcblxuICAvKipcbiAgICogU3RhY2sgdGFncyAocGFzcyB0aHJvdWdoIHRvIENsb3VkRm9ybWF0aW9uKVxuICAgKi9cbiAgcmVhZG9ubHkgdGFncz86IFRhZ1tdO1xuXG4gIC8qKlxuICAgKiBTdGFnZSB0aGUgY2hhbmdlIHNldCBidXQgZG9uJ3QgZXhlY3V0ZSBpdFxuICAgKlxuICAgKiBAZGVmYXVsdCAtIHRydWVcbiAgICogQGRlcHJlY2F0ZWQgVXNlICdkZXBsb3ltZW50TWV0aG9kJyBpbnN0ZWFkXG4gICAqL1xuICByZWFkb25seSBleGVjdXRlPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogT3B0aW9uYWwgbmFtZSB0byB1c2UgZm9yIHRoZSBDbG91ZEZvcm1hdGlvbiBjaGFuZ2Ugc2V0LlxuICAgKiBJZiBub3QgcHJvdmlkZWQsIGEgbmFtZSB3aWxsIGJlIGdlbmVyYXRlZCBhdXRvbWF0aWNhbGx5LlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgJ2RlcGxveW1lbnRNZXRob2QnIGluc3RlYWRcbiAgICovXG4gIHJlYWRvbmx5IGNoYW5nZVNldE5hbWU/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFNlbGVjdCB0aGUgZGVwbG95bWVudCBtZXRob2QgKGRpcmVjdCBvciB1c2luZyBhIGNoYW5nZSBzZXQpXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gQ2hhbmdlIHNldCB3aXRoIGRlZmF1bHQgb3B0aW9uc1xuICAgKi9cbiAgcmVhZG9ubHkgZGVwbG95bWVudE1ldGhvZD86IERlcGxveW1lbnRNZXRob2Q7XG5cbiAgLyoqXG4gICAqIEZvcmNlIGRlcGxveW1lbnQsIGV2ZW4gaWYgdGhlIGRlcGxveWVkIHRlbXBsYXRlIGlzIGlkZW50aWNhbCB0byB0aGUgb25lIHdlIGFyZSBhYm91dCB0byBkZXBsb3kuXG4gICAqIEBkZWZhdWx0IGZhbHNlIGRlcGxveW1lbnQgd2lsbCBiZSBza2lwcGVkIGlmIHRoZSB0ZW1wbGF0ZSBpcyBpZGVudGljYWxcbiAgICovXG4gIHJlYWRvbmx5IGZvcmNlPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogRXh0cmEgcGFyYW1ldGVycyBmb3IgQ2xvdWRGb3JtYXRpb25cbiAgICogQGRlZmF1bHQgLSBubyBhZGRpdGlvbmFsIHBhcmFtZXRlcnMgd2lsbCBiZSBwYXNzZWQgdG8gdGhlIHRlbXBsYXRlXG4gICAqL1xuICByZWFkb25seSBwYXJhbWV0ZXJzPzogeyBbbmFtZTogc3RyaW5nXTogc3RyaW5nIHwgdW5kZWZpbmVkIH07XG5cbiAgLyoqXG4gICAqIFVzZSBwcmV2aW91cyB2YWx1ZXMgZm9yIHVuc3BlY2lmaWVkIHBhcmFtZXRlcnNcbiAgICpcbiAgICogSWYgbm90IHNldCwgYWxsIHBhcmFtZXRlcnMgbXVzdCBiZSBzcGVjaWZpZWQgZm9yIGV2ZXJ5IGRlcGxveW1lbnQuXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIHJlYWRvbmx5IHVzZVByZXZpb3VzUGFyYW1ldGVycz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIERpc3BsYXkgbW9kZSBmb3Igc3RhY2sgZGVwbG95bWVudCBwcm9ncmVzcy5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBTdGFja0FjdGl2aXR5UHJvZ3Jlc3MuQmFyIC0gc3RhY2sgZXZlbnRzIHdpbGwgYmUgZGlzcGxheWVkIGZvclxuICAgKiAgIHRoZSByZXNvdXJjZSBjdXJyZW50bHkgYmVpbmcgZGVwbG95ZWQuXG4gICAqL1xuICByZWFkb25seSBwcm9ncmVzcz86IFN0YWNrQWN0aXZpdHlQcm9ncmVzcztcblxuICAvKipcbiAgICogV2hldGhlciB3ZSBhcmUgb24gYSBDSSBzeXN0ZW1cbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHJlYWRvbmx5IGNpPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogUm9sbGJhY2sgZmFpbGVkIGRlcGxveW1lbnRzXG4gICAqXG4gICAqIEBkZWZhdWx0IHRydWVcbiAgICovXG4gIHJlYWRvbmx5IHJvbGxiYWNrPzogYm9vbGVhbjtcblxuICAvKlxuICAgKiBXaGV0aGVyIHRvIHBlcmZvcm0gYSAnaG90c3dhcCcgZGVwbG95bWVudC5cbiAgICogQSAnaG90c3dhcCcgZGVwbG95bWVudCB3aWxsIGF0dGVtcHQgdG8gc2hvcnQtY2lyY3VpdCBDbG91ZEZvcm1hdGlvblxuICAgKiBhbmQgdXBkYXRlIHRoZSBhZmZlY3RlZCByZXNvdXJjZXMgbGlrZSBMYW1iZGEgZnVuY3Rpb25zIGRpcmVjdGx5LlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIGBIb3Rzd2FwTW9kZS5GVUxMX0RFUExPWU1FTlRgIGZvciByZWd1bGFyIGRlcGxveW1lbnRzLCBgSG90c3dhcE1vZGUuSE9UU1dBUF9PTkxZYCBmb3IgJ3dhdGNoJyBkZXBsb3ltZW50c1xuICAgKi9cbiAgcmVhZG9ubHkgaG90c3dhcD86IEhvdHN3YXBNb2RlO1xuXG4gIC8qKlxuICAgKiBUaGUgZXh0cmEgc3RyaW5nIHRvIGFwcGVuZCB0byB0aGUgVXNlci1BZ2VudCBoZWFkZXIgd2hlbiBwZXJmb3JtaW5nIEFXUyBTREsgY2FsbHMuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gbm90aGluZyBleHRyYSBpcyBhcHBlbmRlZCB0byB0aGUgVXNlci1BZ2VudCBoZWFkZXJcbiAgICovXG4gIHJlYWRvbmx5IGV4dHJhVXNlckFnZW50Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBMaXN0IG9mIGV4aXN0aW5nIHJlc291cmNlcyB0byBiZSBJTVBPUlRFRCBpbnRvIHRoZSBzdGFjaywgaW5zdGVhZCBvZiBiZWluZyBDUkVBVEVEXG4gICAqL1xuICByZWFkb25seSByZXNvdXJjZXNUb0ltcG9ydD86IFJlc291cmNlc1RvSW1wb3J0O1xuXG4gIC8qKlxuICAgKiBJZiBwcmVzZW50LCB1c2UgdGhpcyBnaXZlbiB0ZW1wbGF0ZSBpbnN0ZWFkIG9mIHRoZSBzdG9yZWQgb25lXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gVXNlIHRoZSBzdG9yZWQgdGVtcGxhdGVcbiAgICovXG4gIHJlYWRvbmx5IG92ZXJyaWRlVGVtcGxhdGU/OiBhbnk7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gYnVpbGQvcHVibGlzaCBhc3NldHMgaW4gcGFyYWxsZWxcbiAgICpcbiAgICogQGRlZmF1bHQgdHJ1ZSBUbyByZW1haW4gYmFja3dhcmQgY29tcGF0aWJsZS5cbiAgICovXG4gIHJlYWRvbmx5IGFzc2V0UGFyYWxsZWxpc20/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGRlcGxveSBpZiB0aGUgYXBwIGNvbnRhaW5zIG5vIHN0YWNrcy5cbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGlnbm9yZU5vU3RhY2tzPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBSb2xsYmFja1N0YWNrT3B0aW9ucyB7XG4gIC8qKlxuICAgKiBTdGFjayB0byByb2xsIGJhY2tcbiAgICovXG4gIHJlYWRvbmx5IHN0YWNrOiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3Q7XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGlvbiByb2xlIGZvciB0aGUgZGVwbG95bWVudCAocGFzcyB0aHJvdWdoIHRvIENsb3VkRm9ybWF0aW9uKVxuICAgKlxuICAgKiBAZGVmYXVsdCAtIEN1cnJlbnQgcm9sZVxuICAgKi9cbiAgcmVhZG9ubHkgcm9sZUFybj86IHN0cmluZztcblxuICAvKipcbiAgICogRG9uJ3Qgc2hvdyBzdGFjayBkZXBsb3ltZW50IGV2ZW50cywganVzdCB3YWl0XG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICByZWFkb25seSBxdWlldD86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgd2UgYXJlIG9uIGEgQ0kgc3lzdGVtXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICByZWFkb25seSBjaT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIE5hbWUgb2YgdGhlIHRvb2xraXQgc3RhY2ssIGlmIG5vdCB0aGUgZGVmYXVsdCBuYW1lXG4gICAqXG4gICAqIEBkZWZhdWx0ICdDREtUb29sa2l0J1xuICAgKi9cbiAgcmVhZG9ubHkgdG9vbGtpdFN0YWNrTmFtZT86IHN0cmluZztcblxuICAvKipcbiAgICogV2hldGhlciB0byBmb3JjZSBhIHJvbGxiYWNrIG9yIG5vdFxuICAgKlxuICAgKiBGb3JjaW5nIGEgcm9sbGJhY2sgd2lsbCBvcnBoYW4gYWxsIHVuZGVsZXRhYmxlIHJlc291cmNlcy5cbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIHJlYWRvbmx5IGZvcmNlPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogT3JwaGFuIHRoZSByZXNvdXJjZXMgd2l0aCB0aGUgZ2l2ZW4gbG9naWNhbCBJRHNcbiAgICpcbiAgICogQGRlZmF1bHQgLSBObyBvcnBoYW5pbmdcbiAgICovXG4gIHJlYWRvbmx5IG9ycGhhbkxvZ2ljYWxJZHM/OiBzdHJpbmdbXTtcblxuICAvKipcbiAgICogRGlzcGxheSBtb2RlIGZvciBzdGFjayBkZXBsb3ltZW50IHByb2dyZXNzLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIFN0YWNrQWN0aXZpdHlQcm9ncmVzcy5CYXIgLSBzdGFjayBldmVudHMgd2lsbCBiZSBkaXNwbGF5ZWQgZm9yXG4gICAqICAgdGhlIHJlc291cmNlIGN1cnJlbnRseSBiZWluZyBkZXBsb3llZC5cbiAgICovXG4gIHJlYWRvbmx5IHByb2dyZXNzPzogU3RhY2tBY3Rpdml0eVByb2dyZXNzO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHZhbGlkYXRlIHRoZSB2ZXJzaW9uIG9mIHRoZSBib290c3RyYXAgc3RhY2sgcGVybWlzc2lvbnNcbiAgICpcbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgcmVhZG9ubHkgdmFsaWRhdGVCb290c3RyYXBTdGFja1ZlcnNpb24/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFJvbGxiYWNrU3RhY2tSZXN1bHQge1xuICByZWFkb25seSBub3RJblJvbGxiYWNrYWJsZVN0YXRlPzogYm9vbGVhbjtcbiAgcmVhZG9ubHkgc3VjY2Vzcz86IGJvb2xlYW47XG59XG5cbmludGVyZmFjZSBBc3NldE9wdGlvbnMge1xuICAvKipcbiAgICogU3RhY2sgd2l0aCBhc3NldHMgdG8gYnVpbGQuXG4gICAqL1xuICByZWFkb25seSBzdGFjazogY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0O1xuXG4gIC8qKlxuICAgKiBFeGVjdXRpb24gcm9sZSBmb3IgdGhlIGJ1aWxkaW5nLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIEN1cnJlbnQgcm9sZVxuICAgKi9cbiAgcmVhZG9ubHkgcm9sZUFybj86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBCdWlsZFN0YWNrQXNzZXRzT3B0aW9ucyBleHRlbmRzIEFzc2V0T3B0aW9ucyB7XG4gIC8qKlxuICAgKiBPcHRpb25zIHRvIHBhc3Mgb24gdG8gYGJ1aWxkQXNzZXRzKClgIGZ1bmN0aW9uXG4gICAqL1xuICByZWFkb25seSBidWlsZE9wdGlvbnM/OiBCdWlsZEFzc2V0c09wdGlvbnM7XG5cbiAgLyoqXG4gICAqIFN0YWNrIG5hbWUgdGhpcyBhc3NldCBpcyBmb3JcbiAgICovXG4gIHJlYWRvbmx5IHN0YWNrTmFtZT86IHN0cmluZztcbn1cblxuaW50ZXJmYWNlIFB1Ymxpc2hTdGFja0Fzc2V0c09wdGlvbnMgZXh0ZW5kcyBBc3NldE9wdGlvbnMge1xuICAvKipcbiAgICogT3B0aW9ucyB0byBwYXNzIG9uIHRvIGBwdWJsaXNoQXNlc3RzKClgIGZ1bmN0aW9uXG4gICAqL1xuICByZWFkb25seSBwdWJsaXNoT3B0aW9ucz86IE9taXQ8UHVibGlzaEFzc2V0c09wdGlvbnMsICdidWlsZEFzc2V0cyc+O1xuXG4gIC8qKlxuICAgKiBTdGFjayBuYW1lIHRoaXMgYXNzZXQgaXMgZm9yXG4gICAqL1xuICByZWFkb25seSBzdGFja05hbWU/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGVzdHJveVN0YWNrT3B0aW9ucyB7XG4gIHN0YWNrOiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3Q7XG4gIGRlcGxveU5hbWU/OiBzdHJpbmc7XG4gIHJvbGVBcm4/OiBzdHJpbmc7XG4gIHF1aWV0PzogYm9vbGVhbjtcbiAgZm9yY2U/OiBib29sZWFuO1xuICBjaT86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RhY2tFeGlzdHNPcHRpb25zIHtcbiAgc3RhY2s6IGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdDtcbiAgZGVwbG95TmFtZT86IHN0cmluZztcbiAgdHJ5TG9va3VwUm9sZT86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGVwbG95bWVudHNQcm9wcyB7XG4gIHNka1Byb3ZpZGVyOiBTZGtQcm92aWRlcjtcbiAgcmVhZG9ubHkgdG9vbGtpdFN0YWNrTmFtZT86IHN0cmluZztcbiAgcmVhZG9ubHkgcXVpZXQ/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIFNESyBvYnRhaW5lZCBieSBhc3N1bWluZyB0aGUgZGVwbG95IHJvbGVcbiAqIGZvciBhIGdpdmVuIGVudmlyb25tZW50XG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgUHJlcGFyZWRTZGtGb3JFbnZpcm9ubWVudCB7XG4gIC8qKlxuICAgKiBUaGUgU0RLIGZvciB0aGUgZ2l2ZW4gZW52aXJvbm1lbnRcbiAgICovXG4gIHJlYWRvbmx5IHN0YWNrU2RrOiBJU0RLO1xuXG4gIC8qKlxuICAgKiBUaGUgcmVzb2x2ZWQgZW52aXJvbm1lbnQgZm9yIHRoZSBzdGFja1xuICAgKiAobm8gbW9yZSAndW5rbm93bi1hY2NvdW50L3Vua25vd24tcmVnaW9uJylcbiAgICovXG4gIHJlYWRvbmx5IHJlc29sdmVkRW52aXJvbm1lbnQ6IGN4YXBpLkVudmlyb25tZW50O1xuICAvKipcbiAgICogVGhlIEV4ZWN1dGlvbiBSb2xlIHRoYXQgc2hvdWxkIGJlIHBhc3NlZCB0byBDbG91ZEZvcm1hdGlvbi5cbiAgICpcbiAgICogQGRlZmF1bHQgLSBubyBleGVjdXRpb24gcm9sZSBpcyB1c2VkXG4gICAqL1xuICByZWFkb25seSBjbG91ZEZvcm1hdGlvblJvbGVBcm4/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIEFjY2VzcyBjbGFzcyBmb3IgZW52aXJvbm1lbnRhbCByZXNvdXJjZXMgdG8gaGVscCB0aGUgZGVwbG95bWVudFxuICAgKi9cbiAgcmVhZG9ubHkgZW52UmVzb3VyY2VzOiBFbnZpcm9ubWVudFJlc291cmNlcztcbn1cblxuLyoqXG4gKiBTY29wZSBmb3IgYSBzaW5nbGUgc2V0IG9mIGRlcGxveW1lbnRzIGZyb20gYSBzZXQgb2YgQ2xvdWQgQXNzZW1ibHkgQXJ0aWZhY3RzXG4gKlxuICogTWFuYWdlcyBsb29rdXAgb2YgU0RLcywgQm9vdHN0cmFwIHN0YWNrcywgZXRjLlxuICovXG5leHBvcnQgY2xhc3MgRGVwbG95bWVudHMge1xuICBwcml2YXRlIHJlYWRvbmx5IHNka1Byb3ZpZGVyOiBTZGtQcm92aWRlcjtcbiAgcHJpdmF0ZSByZWFkb25seSBzZGtDYWNoZSA9IG5ldyBNYXA8c3RyaW5nLCBTZGtGb3JFbnZpcm9ubWVudD4oKTtcbiAgcHJpdmF0ZSByZWFkb25seSBwdWJsaXNoZXJDYWNoZSA9IG5ldyBNYXA8QXNzZXRNYW5pZmVzdCwgY2RrX2Fzc2V0cy5Bc3NldFB1Ymxpc2hpbmc+KCk7XG4gIHByaXZhdGUgcmVhZG9ubHkgZW52aXJvbm1lbnRSZXNvdXJjZXM6IEVudmlyb25tZW50UmVzb3VyY2VzUmVnaXN0cnk7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBwcm9wczogRGVwbG95bWVudHNQcm9wcykge1xuICAgIHRoaXMuc2RrUHJvdmlkZXIgPSBwcm9wcy5zZGtQcm92aWRlcjtcbiAgICB0aGlzLmVudmlyb25tZW50UmVzb3VyY2VzID0gbmV3IEVudmlyb25tZW50UmVzb3VyY2VzUmVnaXN0cnkocHJvcHMudG9vbGtpdFN0YWNrTmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogUmVzb2x2ZXMgdGhlIGVudmlyb25tZW50IGZvciBhIHN0YWNrLlxuICAgKi9cbiAgcHVibGljIGFzeW5jIHJlc29sdmVFbnZpcm9ubWVudChzdGFjazogY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0KTogUHJvbWlzZTxjeGFwaS5FbnZpcm9ubWVudD4ge1xuICAgIHJldHVybiB0aGlzLnNka1Byb3ZpZGVyLnJlc29sdmVFbnZpcm9ubWVudChzdGFjay5lbnZpcm9ubWVudCk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgcmVhZEN1cnJlbnRUZW1wbGF0ZVdpdGhOZXN0ZWRTdGFja3MoXG4gICAgcm9vdFN0YWNrQXJ0aWZhY3Q6IGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdCxcbiAgICByZXRyaWV2ZVByb2Nlc3NlZFRlbXBsYXRlOiBib29sZWFuID0gZmFsc2UsXG4gICk6IFByb21pc2U8Um9vdFRlbXBsYXRlV2l0aE5lc3RlZFN0YWNrcz4ge1xuICAgIGNvbnN0IHNkayA9IChhd2FpdCB0aGlzLnByZXBhcmVTZGtXaXRoTG9va3VwT3JEZXBsb3lSb2xlKHJvb3RTdGFja0FydGlmYWN0KSkuc3RhY2tTZGs7XG4gICAgcmV0dXJuIGxvYWRDdXJyZW50VGVtcGxhdGVXaXRoTmVzdGVkU3RhY2tzKHJvb3RTdGFja0FydGlmYWN0LCBzZGssIHJldHJpZXZlUHJvY2Vzc2VkVGVtcGxhdGUpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHJlYWRDdXJyZW50VGVtcGxhdGUoc3RhY2tBcnRpZmFjdDogY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0KTogUHJvbWlzZTxUZW1wbGF0ZT4ge1xuICAgIGRlYnVnKGBSZWFkaW5nIGV4aXN0aW5nIHRlbXBsYXRlIGZvciBzdGFjayAke3N0YWNrQXJ0aWZhY3QuZGlzcGxheU5hbWV9LmApO1xuICAgIGNvbnN0IHNkayA9IChhd2FpdCB0aGlzLnByZXBhcmVTZGtXaXRoTG9va3VwT3JEZXBsb3lSb2xlKHN0YWNrQXJ0aWZhY3QpKS5zdGFja1NkaztcbiAgICByZXR1cm4gbG9hZEN1cnJlbnRUZW1wbGF0ZShzdGFja0FydGlmYWN0LCBzZGspO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIHJlc291cmNlSWRlbnRpZmllclN1bW1hcmllcyhcbiAgICBzdGFja0FydGlmYWN0OiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3QsXG4gICk6IFByb21pc2U8UmVzb3VyY2VJZGVudGlmaWVyU3VtbWFyaWVzPiB7XG4gICAgZGVidWcoYFJldHJpZXZpbmcgdGVtcGxhdGUgc3VtbWFyeSBmb3Igc3RhY2sgJHtzdGFja0FydGlmYWN0LmRpc3BsYXlOYW1lfS5gKTtcbiAgICAvLyBDdXJyZW50bHksIG5lZWRzIHRvIHVzZSBgZGVwbG95LXJvbGVgIHNpbmNlIGl0IG1heSBuZWVkIHRvIHJlYWQgdGVtcGxhdGVzIGluIHRoZSBzdGFnaW5nXG4gICAgLy8gYnVja2V0IHdoaWNoIGhhdmUgYmVlbiBlbmNyeXB0ZWQgd2l0aCBhIEtNUyBrZXkgKGFuZCBsb29rdXAtcm9sZSBtYXkgbm90IHJlYWQgZW5jcnlwdGVkIHRoaW5ncylcbiAgICBjb25zdCB7IHN0YWNrU2RrLCByZXNvbHZlZEVudmlyb25tZW50LCBlbnZSZXNvdXJjZXMgfSA9IGF3YWl0IHRoaXMucHJlcGFyZVNka0ZvcihzdGFja0FydGlmYWN0LCB1bmRlZmluZWQsIE1vZGUuRm9yUmVhZGluZyk7XG4gICAgY29uc3QgY2ZuID0gc3RhY2tTZGsuY2xvdWRGb3JtYXRpb24oKTtcblxuICAgIGF3YWl0IHVwbG9hZFN0YWNrVGVtcGxhdGVBc3NldHMoc3RhY2tBcnRpZmFjdCwgdGhpcyk7XG5cbiAgICAvLyBVcGxvYWQgdGhlIHRlbXBsYXRlLCBpZiBuZWNlc3NhcnksIGJlZm9yZSBwYXNzaW5nIGl0IHRvIENGTlxuICAgIGNvbnN0IGJ1aWxkZXIgPSBuZXcgQXNzZXRNYW5pZmVzdEJ1aWxkZXIoKTtcbiAgICBjb25zdCBjZm5QYXJhbSA9IGF3YWl0IG1ha2VCb2R5UGFyYW1ldGVyKFxuICAgICAgc3RhY2tBcnRpZmFjdCxcbiAgICAgIHJlc29sdmVkRW52aXJvbm1lbnQsXG4gICAgICBidWlsZGVyLFxuICAgICAgZW52UmVzb3VyY2VzLFxuICAgICAgc3RhY2tTZGspO1xuXG4gICAgLy8gSWYgdGhlIGBtYWtlQm9keVBhcmFtZXRlcmAgYmVmb3JlIHRoaXMgYWRkZWQgYXNzZXRzLCBtYWtlIHN1cmUgdG8gcHVibGlzaCB0aGVtIGJlZm9yZVxuICAgIC8vIGNhbGxpbmcgdGhlIEFQSS5cbiAgICBjb25zdCBhZGRlZEFzc2V0cyA9IGJ1aWxkZXIudG9NYW5pZmVzdChzdGFja0FydGlmYWN0LmFzc2VtYmx5LmRpcmVjdG9yeSk7XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBhZGRlZEFzc2V0cy5lbnRyaWVzKSB7XG4gICAgICBhd2FpdCB0aGlzLmJ1aWxkU2luZ2xlQXNzZXQoJ25vLXZlcnNpb24tdmFsaWRhdGlvbicsIGFkZGVkQXNzZXRzLCBlbnRyeSwge1xuICAgICAgICBzdGFjazogc3RhY2tBcnRpZmFjdCxcbiAgICAgIH0pO1xuICAgICAgYXdhaXQgdGhpcy5wdWJsaXNoU2luZ2xlQXNzZXQoYWRkZWRBc3NldHMsIGVudHJ5LCB7XG4gICAgICAgIHN0YWNrOiBzdGFja0FydGlmYWN0LFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBjZm4uZ2V0VGVtcGxhdGVTdW1tYXJ5KGNmblBhcmFtKS5wcm9taXNlKCk7XG4gICAgaWYgKCFyZXNwb25zZS5SZXNvdXJjZUlkZW50aWZpZXJTdW1tYXJpZXMpIHtcbiAgICAgIGRlYnVnKCdHZXRUZW1wbGF0ZVN1bW1hcnkgQVBJIGNhbGwgZGlkIG5vdCByZXR1cm4gXCJSZXNvdXJjZUlkZW50aWZpZXJTdW1tYXJpZXNcIicpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzcG9uc2UuUmVzb3VyY2VJZGVudGlmaWVyU3VtbWFyaWVzID8/IFtdO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGRlcGxveVN0YWNrKG9wdGlvbnM6IERlcGxveVN0YWNrT3B0aW9ucyk6IFByb21pc2U8RGVwbG95U3RhY2tSZXN1bHQ+IHtcbiAgICBsZXQgZGVwbG95bWVudE1ldGhvZCA9IG9wdGlvbnMuZGVwbG95bWVudE1ldGhvZDtcbiAgICBpZiAob3B0aW9ucy5jaGFuZ2VTZXROYW1lIHx8IG9wdGlvbnMuZXhlY3V0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoZGVwbG95bWVudE1ldGhvZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBjYW5ub3Qgc3VwcGx5IGJvdGggXFwnZGVwbG95bWVudE1ldGhvZFxcJyBhbmQgXFwnY2hhbmdlU2V0TmFtZS9leGVjdXRlXFwnLiBTdXBwbHkgb25lIG9yIHRoZSBvdGhlci4nKTtcbiAgICAgIH1cbiAgICAgIGRlcGxveW1lbnRNZXRob2QgPSB7XG4gICAgICAgIG1ldGhvZDogJ2NoYW5nZS1zZXQnLFxuICAgICAgICBjaGFuZ2VTZXROYW1lOiBvcHRpb25zLmNoYW5nZVNldE5hbWUsXG4gICAgICAgIGV4ZWN1dGU6IG9wdGlvbnMuZXhlY3V0ZSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgc3RhY2tTZGssXG4gICAgICByZXNvbHZlZEVudmlyb25tZW50LFxuICAgICAgY2xvdWRGb3JtYXRpb25Sb2xlQXJuLFxuICAgICAgZW52UmVzb3VyY2VzLFxuICAgIH0gPSBhd2FpdCB0aGlzLnByZXBhcmVTZGtGb3Iob3B0aW9ucy5zdGFjaywgb3B0aW9ucy5yb2xlQXJuLCBNb2RlLkZvcldyaXRpbmcpO1xuXG4gICAgLy8gRG8gYSB2ZXJpZmljYXRpb24gb2YgdGhlIGJvb3RzdHJhcCBzdGFjayB2ZXJzaW9uXG4gICAgYXdhaXQgdGhpcy52YWxpZGF0ZUJvb3RzdHJhcFN0YWNrVmVyc2lvbihcbiAgICAgIG9wdGlvbnMuc3RhY2suc3RhY2tOYW1lLFxuICAgICAgb3B0aW9ucy5zdGFjay5yZXF1aXJlc0Jvb3RzdHJhcFN0YWNrVmVyc2lvbixcbiAgICAgIG9wdGlvbnMuc3RhY2suYm9vdHN0cmFwU3RhY2tWZXJzaW9uU3NtUGFyYW1ldGVyLFxuICAgICAgZW52UmVzb3VyY2VzKTtcblxuICAgIHJldHVybiBkZXBsb3lTdGFjayh7XG4gICAgICBzdGFjazogb3B0aW9ucy5zdGFjayxcbiAgICAgIHJlc29sdmVkRW52aXJvbm1lbnQsXG4gICAgICBkZXBsb3lOYW1lOiBvcHRpb25zLmRlcGxveU5hbWUsXG4gICAgICBub3RpZmljYXRpb25Bcm5zOiBvcHRpb25zLm5vdGlmaWNhdGlvbkFybnMsXG4gICAgICBxdWlldDogb3B0aW9ucy5xdWlldCxcbiAgICAgIHNkazogc3RhY2tTZGssXG4gICAgICBzZGtQcm92aWRlcjogdGhpcy5zZGtQcm92aWRlcixcbiAgICAgIHJvbGVBcm46IGNsb3VkRm9ybWF0aW9uUm9sZUFybixcbiAgICAgIHJldXNlQXNzZXRzOiBvcHRpb25zLnJldXNlQXNzZXRzLFxuICAgICAgZW52UmVzb3VyY2VzLFxuICAgICAgdGFnczogb3B0aW9ucy50YWdzLFxuICAgICAgZGVwbG95bWVudE1ldGhvZCxcbiAgICAgIGZvcmNlOiBvcHRpb25zLmZvcmNlLFxuICAgICAgcGFyYW1ldGVyczogb3B0aW9ucy5wYXJhbWV0ZXJzLFxuICAgICAgdXNlUHJldmlvdXNQYXJhbWV0ZXJzOiBvcHRpb25zLnVzZVByZXZpb3VzUGFyYW1ldGVycyxcbiAgICAgIHByb2dyZXNzOiBvcHRpb25zLnByb2dyZXNzLFxuICAgICAgY2k6IG9wdGlvbnMuY2ksXG4gICAgICByb2xsYmFjazogb3B0aW9ucy5yb2xsYmFjayxcbiAgICAgIGhvdHN3YXA6IG9wdGlvbnMuaG90c3dhcCxcbiAgICAgIGV4dHJhVXNlckFnZW50OiBvcHRpb25zLmV4dHJhVXNlckFnZW50LFxuICAgICAgcmVzb3VyY2VzVG9JbXBvcnQ6IG9wdGlvbnMucmVzb3VyY2VzVG9JbXBvcnQsXG4gICAgICBvdmVycmlkZVRlbXBsYXRlOiBvcHRpb25zLm92ZXJyaWRlVGVtcGxhdGUsXG4gICAgICBhc3NldFBhcmFsbGVsaXNtOiBvcHRpb25zLmFzc2V0UGFyYWxsZWxpc20sXG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgYXN5bmMgcm9sbGJhY2tTdGFjayhvcHRpb25zOiBSb2xsYmFja1N0YWNrT3B0aW9ucyk6IFByb21pc2U8Um9sbGJhY2tTdGFja1Jlc3VsdD4ge1xuICAgIGxldCByZXNvdXJjZXNUb1NraXA6IHN0cmluZ1tdID0gb3B0aW9ucy5vcnBoYW5Mb2dpY2FsSWRzID8/IFtdO1xuICAgIGlmIChvcHRpb25zLmZvcmNlICYmIHJlc291cmNlc1RvU2tpcC5sZW5ndGggPiAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb21iaW5lIC0tZm9yY2Ugd2l0aCAtLW9ycGhhbicpO1xuICAgIH1cblxuICAgIGNvbnN0IHtcbiAgICAgIHN0YWNrU2RrLFxuICAgICAgcmVzb2x2ZWRFbnZpcm9ubWVudDogXyxcbiAgICAgIGNsb3VkRm9ybWF0aW9uUm9sZUFybixcbiAgICAgIGVudlJlc291cmNlcyxcbiAgICB9ID0gYXdhaXQgdGhpcy5wcmVwYXJlU2RrRm9yKG9wdGlvbnMuc3RhY2ssIG9wdGlvbnMucm9sZUFybiwgTW9kZS5Gb3JXcml0aW5nKTtcblxuICAgIGlmIChvcHRpb25zLnZhbGlkYXRlQm9vdHN0cmFwU3RhY2tWZXJzaW9uID8/IHRydWUpIHtcbiAgICAgIC8vIERvIGEgdmVyaWZpY2F0aW9uIG9mIHRoZSBib290c3RyYXAgc3RhY2sgdmVyc2lvblxuICAgICAgYXdhaXQgdGhpcy52YWxpZGF0ZUJvb3RzdHJhcFN0YWNrVmVyc2lvbihcbiAgICAgICAgb3B0aW9ucy5zdGFjay5zdGFja05hbWUsXG4gICAgICAgIEJPT1RTVFJBUF9TVEFDS19WRVJTSU9OX0ZPUl9ST0xMQkFDSyxcbiAgICAgICAgb3B0aW9ucy5zdGFjay5ib290c3RyYXBTdGFja1ZlcnNpb25Tc21QYXJhbWV0ZXIsXG4gICAgICAgIGVudlJlc291cmNlcyk7XG4gICAgfVxuXG4gICAgY29uc3QgY2ZuID0gc3RhY2tTZGsuY2xvdWRGb3JtYXRpb24oKTtcbiAgICBjb25zdCBkZXBsb3lOYW1lID0gb3B0aW9ucy5zdGFjay5zdGFja05hbWU7XG5cbiAgICAvLyBXZSBsb29wIGluIGNhc2Ugb2YgYC0tZm9yY2VgIGFuZCB0aGUgc3RhY2sgZW5kcyB1cCBpbiBgQ09OVElOVUVfVVBEQVRFX1JPTExCQUNLYC5cbiAgICBsZXQgbWF4TG9vcHMgPSAxMDtcbiAgICB3aGlsZSAobWF4TG9vcHMtLSkge1xuICAgICAgbGV0IGNsb3VkRm9ybWF0aW9uU3RhY2sgPSBhd2FpdCBDbG91ZEZvcm1hdGlvblN0YWNrLmxvb2t1cChjZm4sIGRlcGxveU5hbWUpO1xuXG4gICAgICBzd2l0Y2ggKGNsb3VkRm9ybWF0aW9uU3RhY2suc3RhY2tTdGF0dXMucm9sbGJhY2tDaG9pY2UpIHtcbiAgICAgICAgY2FzZSBSb2xsYmFja0Nob2ljZS5OT05FOlxuICAgICAgICAgIHdhcm5pbmcoYFN0YWNrICR7ZGVwbG95TmFtZX0gZG9lcyBub3QgbmVlZCBhIHJvbGxiYWNrOiAke2Nsb3VkRm9ybWF0aW9uU3RhY2suc3RhY2tTdGF0dXN9YCk7XG4gICAgICAgICAgcmV0dXJuIHsgbm90SW5Sb2xsYmFja2FibGVTdGF0ZTogdHJ1ZSB9O1xuXG4gICAgICAgIGNhc2UgUm9sbGJhY2tDaG9pY2UuU1RBUlRfUk9MTEJBQ0s6XG4gICAgICAgICAgZGVidWcoYEluaXRpYXRpbmcgcm9sbGJhY2sgb2Ygc3RhY2sgJHtkZXBsb3lOYW1lfWApO1xuICAgICAgICAgIGF3YWl0IGNmbi5yb2xsYmFja1N0YWNrKHtcbiAgICAgICAgICAgIFN0YWNrTmFtZTogZGVwbG95TmFtZSxcbiAgICAgICAgICAgIFJvbGVBUk46IGNsb3VkRm9ybWF0aW9uUm9sZUFybixcbiAgICAgICAgICAgIENsaWVudFJlcXVlc3RUb2tlbjogcmFuZG9tVVVJRCgpLFxuICAgICAgICAgICAgLy8gRW5hYmxpbmcgdGhpcyBpcyBqdXN0IHRoZSBiZXR0ZXIgb3ZlcmFsbCBkZWZhdWx0LCB0aGUgb25seSByZWFzb24gaXQgaXNuJ3QgdGhlIHVwc3RyZWFtIGRlZmF1bHQgaXMgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgICAgICAgIFJldGFpbkV4Y2VwdE9uQ3JlYXRlOiB0cnVlLFxuICAgICAgICAgIH0pLnByb21pc2UoKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFJvbGxiYWNrQ2hvaWNlLkNPTlRJTlVFX1VQREFURV9ST0xMQkFDSzpcbiAgICAgICAgICBpZiAob3B0aW9ucy5mb3JjZSkge1xuICAgICAgICAgICAgLy8gRmluZCB0aGUgZmFpbGVkIHJlc291cmNlcyBmcm9tIHRoZSBkZXBsb3ltZW50IGFuZCBhdXRvbWF0aWNhbGx5IHNraXAgdGhlbVxuICAgICAgICAgICAgLy8gKFVzaW5nIGRlcGxveW1lbnQgbG9nIGJlY2F1c2Ugd2UgZGVmaW5pdGVseSBoYXZlIGBEZXNjcmliZVN0YWNrRXZlbnRzYCBwZXJtaXNzaW9ucywgYW5kIHdlIG1pZ2h0IG5vdCBoYXZlXG4gICAgICAgICAgICAvLyBgRGVzY3JpYmVTdGFja1Jlc291cmNlc2AgcGVybWlzc2lvbnMpLlxuICAgICAgICAgICAgY29uc3QgcG9sbGVyID0gbmV3IFN0YWNrRXZlbnRQb2xsZXIoY2ZuLCB7XG4gICAgICAgICAgICAgIHN0YWNrTmFtZTogZGVwbG95TmFtZSxcbiAgICAgICAgICAgICAgc3RhY2tTdGF0dXNlczogWydST0xMQkFDS19JTl9QUk9HUkVTUycsICdVUERBVEVfUk9MTEJBQ0tfSU5fUFJPR1JFU1MnXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXdhaXQgcG9sbGVyLnBvbGwoKTtcbiAgICAgICAgICAgIHJlc291cmNlc1RvU2tpcCA9IHBvbGxlci5yZXNvdXJjZUVycm9yc1xuICAgICAgICAgICAgICAuZmlsdGVyKHIgPT4gIXIuaXNTdGFja0V2ZW50ICYmIHIucGFyZW50U3RhY2tMb2dpY2FsSWRzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgLm1hcChyID0+IHIuZXZlbnQuTG9naWNhbFJlc291cmNlSWQgPz8gJycpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHNraXBEZXNjcmlwdGlvbiA9IHJlc291cmNlc1RvU2tpcC5sZW5ndGggPiAwXG4gICAgICAgICAgICA/IGAgKG9ycGhhbmluZzogJHtyZXNvdXJjZXNUb1NraXAuam9pbignLCAnKX0pYFxuICAgICAgICAgICAgOiAnJztcbiAgICAgICAgICB3YXJuaW5nKGBDb250aW51aW5nIHJvbGxiYWNrIG9mIHN0YWNrICR7ZGVwbG95TmFtZX0ke3NraXBEZXNjcmlwdGlvbn1gKTtcbiAgICAgICAgICBhd2FpdCBjZm4uY29udGludWVVcGRhdGVSb2xsYmFjayh7XG4gICAgICAgICAgICBTdGFja05hbWU6IGRlcGxveU5hbWUsXG4gICAgICAgICAgICBDbGllbnRSZXF1ZXN0VG9rZW46IHJhbmRvbVVVSUQoKSxcbiAgICAgICAgICAgIFJvbGVBUk46IGNsb3VkRm9ybWF0aW9uUm9sZUFybixcbiAgICAgICAgICAgIFJlc291cmNlc1RvU2tpcDogcmVzb3VyY2VzVG9Ta2lwLFxuICAgICAgICAgIH0pLnByb21pc2UoKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFJvbGxiYWNrQ2hvaWNlLlJPTExCQUNLX0ZBSUxFRDpcbiAgICAgICAgICB3YXJuaW5nKGBTdGFjayAke2RlcGxveU5hbWV9IGZhaWxlZCBjcmVhdGlvbiBhbmQgcm9sbGJhY2suIFRoaXMgc3RhdGUgY2Fubm90IGJlIHJvbGxlZCBiYWNrLiBZb3UgY2FuIHJlY3JlYXRlIHRoaXMgc3RhY2sgYnkgcnVubmluZyAnY2RrIGRlcGxveScuYCk7XG4gICAgICAgICAgcmV0dXJuIHsgbm90SW5Sb2xsYmFja2FibGVTdGF0ZTogdHJ1ZSB9O1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIHJvbGxiYWNrIGNob2ljZTogJHtjbG91ZEZvcm1hdGlvblN0YWNrLnN0YWNrU3RhdHVzLnJvbGxiYWNrQ2hvaWNlfWApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBtb25pdG9yID0gb3B0aW9ucy5xdWlldCA/IHVuZGVmaW5lZCA6IFN0YWNrQWN0aXZpdHlNb25pdG9yLndpdGhEZWZhdWx0UHJpbnRlcihjZm4sIGRlcGxveU5hbWUsIG9wdGlvbnMuc3RhY2ssIHtcbiAgICAgICAgY2k6IG9wdGlvbnMuY2ksXG4gICAgICB9KS5zdGFydCgpO1xuXG4gICAgICBsZXQgc3RhY2tFcnJvck1lc3NhZ2U6IHN0cmluZyB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbiAgICAgIGxldCBmaW5hbFN0YWNrU3RhdGUgPSBjbG91ZEZvcm1hdGlvblN0YWNrO1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc3VjY2Vzc1N0YWNrID0gYXdhaXQgc3RhYmlsaXplU3RhY2soY2ZuLCBkZXBsb3lOYW1lKTtcblxuICAgICAgICAvLyBUaGlzIHNob3VsZG4ndCByZWFsbHkgaGFwcGVuLCBidXQgY2F0Y2ggaXQgYW55d2F5LiBZb3UgbmV2ZXIga25vdy5cbiAgICAgICAgaWYgKCFzdWNjZXNzU3RhY2spIHsgdGhyb3cgbmV3IEVycm9yKCdTdGFjayBkZXBsb3kgZmFpbGVkICh0aGUgc3RhY2sgZGlzYXBwZWFyZWQgd2hpbGUgd2Ugd2VyZSByb2xsaW5nIGl0IGJhY2spJyk7IH1cbiAgICAgICAgZmluYWxTdGFja1N0YXRlID0gc3VjY2Vzc1N0YWNrO1xuXG4gICAgICAgIGNvbnN0IGVycm9ycyA9IG1vbml0b3I/LmVycm9ycz8uam9pbignLCAnKTtcbiAgICAgICAgaWYgKGVycm9ycykge1xuICAgICAgICAgIHN0YWNrRXJyb3JNZXNzYWdlID0gZXJyb3JzO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlOiBhbnkpIHtcbiAgICAgICAgc3RhY2tFcnJvck1lc3NhZ2UgPSBzdWZmaXhXaXRoRXJyb3JzKGUubWVzc2FnZSwgbW9uaXRvcj8uZXJyb3JzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGF3YWl0IG1vbml0b3I/LnN0b3AoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsU3RhY2tTdGF0ZS5zdGFja1N0YXR1cy5pc1JvbGxiYWNrU3VjY2VzcyB8fCAhc3RhY2tFcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSB9O1xuICAgICAgfVxuXG4gICAgICAvLyBFaXRoZXIgd2UgbmVlZCB0byBpZ25vcmUgc29tZSByZXNvdXJjZXMgdG8gY29udGludWUgdGhlIHJvbGxiYWNrLCBvciBzb21ldGhpbmcgd2VudCB3cm9uZ1xuICAgICAgaWYgKGZpbmFsU3RhY2tTdGF0ZS5zdGFja1N0YXR1cy5yb2xsYmFja0Nob2ljZSA9PT0gUm9sbGJhY2tDaG9pY2UuQ09OVElOVUVfVVBEQVRFX1JPTExCQUNLICYmIG9wdGlvbnMuZm9yY2UpIHtcbiAgICAgICAgLy8gRG8gYW5vdGhlciBsb29wLWRlLWxvb3BcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtzdGFja0Vycm9yTWVzc2FnZX0gKGZpeCBwcm9ibGVtIGFuZCByZXRyeSwgb3Igb3JwaGFuIHRoZXNlIHJlc291cmNlcyB1c2luZyAtLW9ycGhhbiBvciAtLWZvcmNlKWApOztcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSb2xsYmFjayBkaWQgbm90IGZpbmlzaCBhZnRlciBhIGxhcmdlIG51bWJlciBvZiBpdGVyYXRpb25zOyBzdG9wcGluZyBiZWNhdXNlIGl0IGxvb2tzIGxpa2Ugd2VcXCdyZSBub3QgbWFraW5nIHByb2dyZXNzIGFueW1vcmUuIFlvdSBjYW4gcmV0cnkgaWYgcm9sbGJhY2sgd2FzIHByb2dyZXNzaW5nIGFzIGV4cGVjdGVkLicpO1xuICB9XG5cbiAgcHVibGljIGFzeW5jIGRlc3Ryb3lTdGFjayhvcHRpb25zOiBEZXN0cm95U3RhY2tPcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgeyBzdGFja1NkaywgY2xvdWRGb3JtYXRpb25Sb2xlQXJuOiByb2xlQXJuIH0gPSBhd2FpdCB0aGlzLnByZXBhcmVTZGtGb3Iob3B0aW9ucy5zdGFjaywgb3B0aW9ucy5yb2xlQXJuLCBNb2RlLkZvcldyaXRpbmcpO1xuXG4gICAgcmV0dXJuIGRlc3Ryb3lTdGFjayh7XG4gICAgICBzZGs6IHN0YWNrU2RrLFxuICAgICAgcm9sZUFybixcbiAgICAgIHN0YWNrOiBvcHRpb25zLnN0YWNrLFxuICAgICAgZGVwbG95TmFtZTogb3B0aW9ucy5kZXBsb3lOYW1lLFxuICAgICAgcXVpZXQ6IG9wdGlvbnMucXVpZXQsXG4gICAgICBjaTogb3B0aW9ucy5jaSxcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBzdGFja0V4aXN0cyhvcHRpb25zOiBTdGFja0V4aXN0c09wdGlvbnMpOiBQcm9taXNlPGJvb2xlYW4+IHtcbiAgICBsZXQgc3RhY2tTZGs7XG4gICAgaWYgKG9wdGlvbnMudHJ5TG9va3VwUm9sZSkge1xuICAgICAgc3RhY2tTZGsgPSAoYXdhaXQgdGhpcy5wcmVwYXJlU2RrV2l0aExvb2t1cE9yRGVwbG95Um9sZShvcHRpb25zLnN0YWNrKSkuc3RhY2tTZGs7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YWNrU2RrID0gKGF3YWl0IHRoaXMucHJlcGFyZVNka0ZvcihvcHRpb25zLnN0YWNrLCB1bmRlZmluZWQsIE1vZGUuRm9yUmVhZGluZykpLnN0YWNrU2RrO1xuICAgIH1cbiAgICBjb25zdCBzdGFjayA9IGF3YWl0IENsb3VkRm9ybWF0aW9uU3RhY2subG9va3VwKHN0YWNrU2RrLmNsb3VkRm9ybWF0aW9uKCksIG9wdGlvbnMuZGVwbG95TmFtZSA/PyBvcHRpb25zLnN0YWNrLnN0YWNrTmFtZSk7XG4gICAgcmV0dXJuIHN0YWNrLmV4aXN0cztcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBwcmVwYXJlU2RrV2l0aERlcGxveVJvbGUoc3RhY2tBcnRpZmFjdDogY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0KTogUHJvbWlzZTxQcmVwYXJlZFNka0ZvckVudmlyb25tZW50PiB7XG4gICAgcmV0dXJuIHRoaXMucHJlcGFyZVNka0ZvcihzdGFja0FydGlmYWN0LCB1bmRlZmluZWQsIE1vZGUuRm9yV3JpdGluZyk7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHByZXBhcmVTZGtXaXRoTG9va3VwT3JEZXBsb3lSb2xlKHN0YWNrQXJ0aWZhY3Q6IGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdCk6IFByb21pc2U8UHJlcGFyZWRTZGtGb3JFbnZpcm9ubWVudD4ge1xuICAgIC8vIHRyeSB0byBhc3N1bWUgdGhlIGxvb2t1cCByb2xlXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMucHJlcGFyZVNka1dpdGhMb29rdXBSb2xlRm9yKHN0YWNrQXJ0aWZhY3QpO1xuICAgICAgaWYgKHJlc3VsdC5kaWRBc3N1bWVSb2xlKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgcmVzb2x2ZWRFbnZpcm9ubWVudDogcmVzdWx0LnJlc29sdmVkRW52aXJvbm1lbnQsXG4gICAgICAgICAgc3RhY2tTZGs6IHJlc3VsdC5zZGssXG4gICAgICAgICAgZW52UmVzb3VyY2VzOiByZXN1bHQuZW52UmVzb3VyY2VzLFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gY2F0Y2ggeyB9XG4gICAgLy8gZmFsbCBiYWNrIHRvIHRoZSBkZXBsb3kgcm9sZVxuICAgIHJldHVybiB0aGlzLnByZXBhcmVTZGtGb3Ioc3RhY2tBcnRpZmFjdCwgdW5kZWZpbmVkLCBNb2RlLkZvclJlYWRpbmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgZW52aXJvbm1lbnQgbmVjZXNzYXJ5IGZvciB0b3VjaGluZyB0aGUgZ2l2ZW4gc3RhY2tcbiAgICpcbiAgICogUmV0dXJucyB0aGUgZm9sbG93aW5nOlxuICAgKlxuICAgKiAtIFRoZSByZXNvbHZlZCBlbnZpcm9ubWVudCBmb3IgdGhlIHN0YWNrIChubyBtb3JlICd1bmtub3duLWFjY291bnQvdW5rbm93bi1yZWdpb24nKVxuICAgKiAtIFNESyBsb2FkZWQgd2l0aCB0aGUgcmlnaHQgY3JlZGVudGlhbHMgZm9yIGNhbGxpbmcgYENyZWF0ZUNoYW5nZVNldGAuXG4gICAqIC0gVGhlIEV4ZWN1dGlvbiBSb2xlIHRoYXQgc2hvdWxkIGJlIHBhc3NlZCB0byBDbG91ZEZvcm1hdGlvbi5cbiAgICovXG4gIHByaXZhdGUgYXN5bmMgcHJlcGFyZVNka0ZvcihcbiAgICBzdGFjazogY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0LFxuICAgIHJvbGVBcm46IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICBtb2RlOiBNb2RlLFxuICApOiBQcm9taXNlPFByZXBhcmVkU2RrRm9yRW52aXJvbm1lbnQ+IHtcbiAgICBpZiAoIXN0YWNrLmVudmlyb25tZW50KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBzdGFjayAke3N0YWNrLmRpc3BsYXlOYW1lfSBkb2VzIG5vdCBoYXZlIGFuIGVudmlyb25tZW50YCk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzb2x2ZWRFbnZpcm9ubWVudCA9IGF3YWl0IHRoaXMucmVzb2x2ZUVudmlyb25tZW50KHN0YWNrKTtcblxuICAgIC8vIFN1YnN0aXR1dGUgYW55IHBsYWNlaG9sZGVycyB3aXRoIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjdXJyZW50IGVudmlyb25tZW50XG4gICAgY29uc3QgYXJucyA9IGF3YWl0IHJlcGxhY2VFbnZQbGFjZWhvbGRlcnMoe1xuICAgICAgYXNzdW1lUm9sZUFybjogc3RhY2suYXNzdW1lUm9sZUFybixcblxuICAgICAgLy8gVXNlIHRoZSBvdmVycmlkZSBpZiBnaXZlbiwgb3RoZXJ3aXNlIHVzZSB0aGUgZmllbGQgZnJvbSB0aGUgc3RhY2tcbiAgICAgIGNsb3VkRm9ybWF0aW9uUm9sZUFybjogcm9sZUFybiA/PyBzdGFjay5jbG91ZEZvcm1hdGlvbkV4ZWN1dGlvblJvbGVBcm4sXG4gICAgfSwgcmVzb2x2ZWRFbnZpcm9ubWVudCwgdGhpcy5zZGtQcm92aWRlcik7XG5cbiAgICBjb25zdCBzdGFja1NkayA9IGF3YWl0IHRoaXMuY2FjaGVkU2RrRm9yRW52aXJvbm1lbnQocmVzb2x2ZWRFbnZpcm9ubWVudCwgbW9kZSwge1xuICAgICAgYXNzdW1lUm9sZUFybjogYXJucy5hc3N1bWVSb2xlQXJuLFxuICAgICAgYXNzdW1lUm9sZUV4dGVybmFsSWQ6IHN0YWNrLmFzc3VtZVJvbGVFeHRlcm5hbElkLFxuICAgICAgYXNzdW1lUm9sZUFkZGl0aW9uYWxPcHRpb25zOiBzdGFjay5hc3N1bWVSb2xlQWRkaXRpb25hbE9wdGlvbnMsXG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgc3RhY2tTZGs6IHN0YWNrU2RrLnNkayxcbiAgICAgIHJlc29sdmVkRW52aXJvbm1lbnQsXG4gICAgICBjbG91ZEZvcm1hdGlvblJvbGVBcm46IGFybnMuY2xvdWRGb3JtYXRpb25Sb2xlQXJuLFxuICAgICAgZW52UmVzb3VyY2VzOiB0aGlzLmVudmlyb25tZW50UmVzb3VyY2VzLmZvcihyZXNvbHZlZEVudmlyb25tZW50LCBzdGFja1Nkay5zZGspLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICAqIFRyeSB0byB1c2UgdGhlIGJvb3RzdHJhcCBsb29rdXBSb2xlLiBUaGVyZSBhcmUgdHdvIHNjZW5hcmlvcyB0aGF0IGFyZSBoYW5kbGVkIGhlcmVcbiAgICAqICAxLiBUaGUgbG9va3VwIHJvbGUgbWF5IG5vdCBleGlzdCAoaXQgd2FzIGFkZGVkIGluIGJvb3RzdHJhcCBzdGFjayB2ZXJzaW9uIDcpXG4gICAgKiAgMi4gVGhlIGxvb2t1cCByb2xlIG1heSBub3QgaGF2ZSB0aGUgY29ycmVjdCBwZXJtaXNzaW9ucyAoUmVhZE9ubHlBY2Nlc3Mgd2FzIGFkZGVkIGluXG4gICAgKiAgICAgIGJvb3RzdHJhcCBzdGFjayB2ZXJzaW9uIDgpXG4gICAgKlxuICAgICogSW4gdGhlIGNhc2Ugb2YgMSAobG9va3VwIHJvbGUgZG9lc24ndCBleGlzdCkgYGZvckVudmlyb25tZW50YCB3aWxsIGVpdGhlcjpcbiAgICAqICAgMS4gUmV0dXJuIHRoZSBkZWZhdWx0IGNyZWRlbnRpYWxzIGlmIHRoZSBkZWZhdWx0IGNyZWRlbnRpYWxzIGFyZSBmb3IgdGhlIHN0YWNrIGFjY291bnRcbiAgICAqICAgMi4gVGhyb3cgYW4gZXJyb3IgaWYgdGhlIGRlZmF1bHQgY3JlZGVudGlhbHMgYXJlIG5vdCBmb3IgdGhlIHN0YWNrIGFjY291bnQuXG4gICAgKlxuICAgICogSWYgd2Ugc3VjY2Vzc2Z1bGx5IGFzc3VtZSB0aGUgbG9va3VwIHJvbGUgd2UgdGhlbiBwcm9jZWVkIHRvIDIgYW5kIGNoZWNrIHdoZXRoZXIgdGhlIGJvb3RzdHJhcFxuICAgICogc3RhY2sgdmVyc2lvbiBpcyB2YWxpZC4gSWYgaXQgaXMgbm90IHdlIHRocm93IGFuIGVycm9yIHdoaWNoIHNob3VsZCBiZSBoYW5kbGVkIGluIHRoZSBjYWxsaW5nXG4gICAgKiBmdW5jdGlvbiAoYW5kIGZhbGxiYWNrIHRvIHVzZSBhIGRpZmZlcmVudCByb2xlLCBldGMpXG4gICAgKlxuICAgICogSWYgd2UgZG8gbm90IHN1Y2Nlc3NmdWxseSBhc3N1bWUgdGhlIGxvb2t1cCByb2xlLCBidXQgZG8gZ2V0IGJhY2sgdGhlIGRlZmF1bHQgY3JlZGVudGlhbHNcbiAgICAqIHRoZW4gcmV0dXJuIHRob3NlIGFuZCBub3RlIHRoYXQgd2UgYXJlIHJldHVybmluZyB0aGUgZGVmYXVsdCBjcmVkZW50aWFscy4gVGhlIGNhbGxpbmdcbiAgICAqIGZ1bmN0aW9uIGNhbiB0aGVuIGRlY2lkZSB0byB1c2UgdGhlbSBvciBmYWxsYmFjayB0byBhbm90aGVyIHJvbGUuXG4gICAgKi9cbiAgcHVibGljIGFzeW5jIHByZXBhcmVTZGtXaXRoTG9va3VwUm9sZUZvcihcbiAgICBzdGFjazogY3hhcGkuQ2xvdWRGb3JtYXRpb25TdGFja0FydGlmYWN0LFxuICApOiBQcm9taXNlPFByZXBhcmVkU2RrV2l0aExvb2t1cFJvbGVGb3JFbnZpcm9ubWVudD4ge1xuICAgIGNvbnN0IHJlc29sdmVkRW52aXJvbm1lbnQgPSBhd2FpdCB0aGlzLnNka1Byb3ZpZGVyLnJlc29sdmVFbnZpcm9ubWVudChzdGFjay5lbnZpcm9ubWVudCk7XG5cbiAgICAvLyBTdWJzdGl0dXRlIGFueSBwbGFjZWhvbGRlcnMgd2l0aCBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY3VycmVudCBlbnZpcm9ubWVudFxuICAgIGNvbnN0IGFybnMgPSBhd2FpdCByZXBsYWNlRW52UGxhY2Vob2xkZXJzKHtcbiAgICAgIGxvb2t1cFJvbGVBcm46IHN0YWNrLmxvb2t1cFJvbGU/LmFybixcbiAgICB9LCByZXNvbHZlZEVudmlyb25tZW50LCB0aGlzLnNka1Byb3ZpZGVyKTtcblxuICAgIC8vIHRyeSB0byBhc3N1bWUgdGhlIGxvb2t1cCByb2xlXG4gICAgY29uc3Qgd2FybmluZ01lc3NhZ2UgPSBgQ291bGQgbm90IGFzc3VtZSAke2FybnMubG9va3VwUm9sZUFybn0sIHByb2NlZWRpbmcgYW55d2F5LmA7XG5cbiAgICB0cnkge1xuICAgICAgLy8gVHJ5aW5nIHRvIGFzc3VtZSBsb29rdXAgcm9sZSBhbmQgY2FjaGUgdGhlIHNkayBmb3IgdGhlIGVudmlyb25tZW50XG4gICAgICBjb25zdCBzdGFja1NkayA9IGF3YWl0IHRoaXMuY2FjaGVkU2RrRm9yRW52aXJvbm1lbnQocmVzb2x2ZWRFbnZpcm9ubWVudCwgTW9kZS5Gb3JSZWFkaW5nLCB7XG4gICAgICAgIGFzc3VtZVJvbGVBcm46IGFybnMubG9va3VwUm9sZUFybixcbiAgICAgICAgYXNzdW1lUm9sZUV4dGVybmFsSWQ6IHN0YWNrLmxvb2t1cFJvbGU/LmFzc3VtZVJvbGVFeHRlcm5hbElkLFxuICAgICAgICBhc3N1bWVSb2xlQWRkaXRpb25hbE9wdGlvbnM6IHN0YWNrLmxvb2t1cFJvbGU/LmFzc3VtZVJvbGVBZGRpdGlvbmFsT3B0aW9ucyxcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBlbnZSZXNvdXJjZXMgPSB0aGlzLmVudmlyb25tZW50UmVzb3VyY2VzLmZvcihyZXNvbHZlZEVudmlyb25tZW50LCBzdGFja1Nkay5zZGspO1xuXG4gICAgICAvLyBpZiB3ZSBzdWNjZWVkIGluIGFzc3VtaW5nIHRoZSBsb29rdXAgcm9sZSwgbWFrZSBzdXJlIHdlIGhhdmUgdGhlIGNvcnJlY3QgYm9vdHN0cmFwIHN0YWNrIHZlcnNpb25cbiAgICAgIGlmIChzdGFja1Nkay5kaWRBc3N1bWVSb2xlICYmIHN0YWNrLmxvb2t1cFJvbGU/LmJvb3RzdHJhcFN0YWNrVmVyc2lvblNzbVBhcmFtZXRlciAmJiBzdGFjay5sb29rdXBSb2xlLnJlcXVpcmVzQm9vdHN0cmFwU3RhY2tWZXJzaW9uKSB7XG4gICAgICAgIGNvbnN0IHZlcnNpb24gPSBhd2FpdCBlbnZSZXNvdXJjZXMudmVyc2lvbkZyb21Tc21QYXJhbWV0ZXIoc3RhY2subG9va3VwUm9sZS5ib290c3RyYXBTdGFja1ZlcnNpb25Tc21QYXJhbWV0ZXIpO1xuICAgICAgICBpZiAodmVyc2lvbiA8IHN0YWNrLmxvb2t1cFJvbGUucmVxdWlyZXNCb290c3RyYXBTdGFja1ZlcnNpb24pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEJvb3RzdHJhcCBzdGFjayB2ZXJzaW9uICcke3N0YWNrLmxvb2t1cFJvbGUucmVxdWlyZXNCb290c3RyYXBTdGFja1ZlcnNpb259JyBpcyByZXF1aXJlZCwgZm91bmQgdmVyc2lvbiAnJHt2ZXJzaW9ufScuIFRvIGdldCByaWQgb2YgdGhpcyBlcnJvciwgcGxlYXNlIHVwZ3JhZGUgdG8gYm9vdHN0cmFwIHZlcnNpb24gPj0gJHtzdGFjay5sb29rdXBSb2xlLnJlcXVpcmVzQm9vdHN0cmFwU3RhY2tWZXJzaW9ufWApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFzdGFja1Nkay5kaWRBc3N1bWVSb2xlKSB7XG4gICAgICAgIGNvbnN0IGxvb2tVcFJvbGVFeGlzdHMgPSBzdGFjay5sb29rdXBSb2xlID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICB3YXJuaW5nKGBMb29rdXAgcm9sZSAkeyBsb29rVXBSb2xlRXhpc3RzID8gJ2V4aXN0cyBidXQnIDogJ2RvZXMgbm90IGV4aXN0LCBoZW5jZSd9IHdhcyBub3QgYXNzdW1lZC4gUHJvY2VlZGluZyB3aXRoIGRlZmF1bHQgY3JlZGVudGlhbHMuYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4geyAuLi5zdGFja1NkaywgcmVzb2x2ZWRFbnZpcm9ubWVudCwgZW52UmVzb3VyY2VzIH07XG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICBkZWJ1ZyhlKTtcblxuICAgICAgLy8gb25seSBwcmludCBvdXQgdGhlIHdhcm5pbmdzIGlmIHRoZSBsb29rdXBSb2xlIGV4aXN0c1xuICAgICAgaWYgKHN0YWNrLmxvb2t1cFJvbGUpIHtcbiAgICAgICAgd2FybmluZyh3YXJuaW5nTWVzc2FnZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoaXMgZXJyb3Igc2hvdWxkIGJlIHNob3duIGV2ZW4gaWYgZGVidWcgbW9kZSBpcyBvZmZcbiAgICAgIGlmIChlIGluc3RhbmNlb2YgRXJyb3IgJiYgZS5tZXNzYWdlLmluY2x1ZGVzKCdCb290c3RyYXAgc3RhY2sgdmVyc2lvbicpKSB7XG4gICAgICAgIGVycm9yKGUubWVzc2FnZSk7XG4gICAgICB9XG5cbiAgICAgIHRocm93IChlKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHByZXBhcmVBbmRWYWxpZGF0ZUFzc2V0cyhhc3NldDogY3hhcGkuQXNzZXRNYW5pZmVzdEFydGlmYWN0LCBvcHRpb25zOiBBc3NldE9wdGlvbnMpIHtcbiAgICBjb25zdCB7IGVudlJlc291cmNlcyB9ID0gYXdhaXQgdGhpcy5wcmVwYXJlU2RrRm9yKG9wdGlvbnMuc3RhY2ssIG9wdGlvbnMucm9sZUFybiwgTW9kZS5Gb3JXcml0aW5nKTtcblxuICAgIGF3YWl0IHRoaXMudmFsaWRhdGVCb290c3RyYXBTdGFja1ZlcnNpb24oXG4gICAgICBvcHRpb25zLnN0YWNrLnN0YWNrTmFtZSxcbiAgICAgIGFzc2V0LnJlcXVpcmVzQm9vdHN0cmFwU3RhY2tWZXJzaW9uLFxuICAgICAgYXNzZXQuYm9vdHN0cmFwU3RhY2tWZXJzaW9uU3NtUGFyYW1ldGVyLFxuICAgICAgZW52UmVzb3VyY2VzKTtcblxuICAgIGNvbnN0IG1hbmlmZXN0ID0gQXNzZXRNYW5pZmVzdC5mcm9tRmlsZShhc3NldC5maWxlKTtcblxuICAgIHJldHVybiB7IG1hbmlmZXN0LCBzdGFja0VudjogZW52UmVzb3VyY2VzLmVudmlyb25tZW50IH07XG4gIH1cblxuICAvKipcbiAgICogQnVpbGQgYWxsIGFzc2V0cyBpbiBhIG1hbmlmZXN0XG4gICAqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBgYnVpbGRTaW5nbGVBc3NldGAgaW5zdGVhZFxuICAgKi9cbiAgcHVibGljIGFzeW5jIGJ1aWxkQXNzZXRzKGFzc2V0OiBjeGFwaS5Bc3NldE1hbmlmZXN0QXJ0aWZhY3QsIG9wdGlvbnM6IEJ1aWxkU3RhY2tBc3NldHNPcHRpb25zKSB7XG4gICAgY29uc3QgeyBtYW5pZmVzdCwgc3RhY2tFbnYgfSA9IGF3YWl0IHRoaXMucHJlcGFyZUFuZFZhbGlkYXRlQXNzZXRzKGFzc2V0LCBvcHRpb25zKTtcbiAgICBhd2FpdCBidWlsZEFzc2V0cyhtYW5pZmVzdCwgdGhpcy5zZGtQcm92aWRlciwgc3RhY2tFbnYsIG9wdGlvbnMuYnVpbGRPcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQdWJsaXNoIGFsbCBhc3NldHMgaW4gYSBtYW5pZmVzdFxuICAgKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYHB1Ymxpc2hTaW5nbGVBc3NldGAgaW5zdGVhZFxuICAgKi9cbiAgcHVibGljIGFzeW5jIHB1Ymxpc2hBc3NldHMoYXNzZXQ6IGN4YXBpLkFzc2V0TWFuaWZlc3RBcnRpZmFjdCwgb3B0aW9uczogUHVibGlzaFN0YWNrQXNzZXRzT3B0aW9ucykge1xuICAgIGNvbnN0IHsgbWFuaWZlc3QsIHN0YWNrRW52IH0gPSBhd2FpdCB0aGlzLnByZXBhcmVBbmRWYWxpZGF0ZUFzc2V0cyhhc3NldCwgb3B0aW9ucyk7XG4gICAgYXdhaXQgcHVibGlzaEFzc2V0cyhtYW5pZmVzdCwgdGhpcy5zZGtQcm92aWRlciwgc3RhY2tFbnYsIG9wdGlvbnMucHVibGlzaE9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1aWxkIGEgc2luZ2xlIGFzc2V0IGZyb20gYW4gYXNzZXQgbWFuaWZlc3RcbiAgICpcbiAgICogSWYgYW4gYXNzZXJ0IG1hbmlmZXN0IGFydGlmYWN0IGlzIGdpdmVuLCB0aGUgYm9vdHN0cmFwIHN0YWNrIHZlcnNpb25cbiAgICogd2lsbCBiZSB2YWxpZGF0ZWQgYWNjb3JkaW5nIHRvIHRoZSBjb25zdHJhaW50cyBpbiB0aGF0IG1hbmlmZXN0IGFydGlmYWN0LlxuICAgKiBJZiB0aGF0IGlzIG5vdCBuZWNlc3NhcnksIGAnbm8tdmVyc2lvbi12YWxpZGF0aW9uJ2AgY2FuIGJlIHBhc3NlZC5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG4gIHB1YmxpYyBhc3luYyBidWlsZFNpbmdsZUFzc2V0KGFzc2V0QXJ0aWZhY3Q6IGN4YXBpLkFzc2V0TWFuaWZlc3RBcnRpZmFjdCB8ICduby12ZXJzaW9uLXZhbGlkYXRpb24nLCBhc3NldE1hbmlmZXN0OiBBc3NldE1hbmlmZXN0LCBhc3NldDogSU1hbmlmZXN0RW50cnksIG9wdGlvbnM6IEJ1aWxkU3RhY2tBc3NldHNPcHRpb25zKSB7XG4gICAgY29uc3QgeyByZXNvbHZlZEVudmlyb25tZW50LCBlbnZSZXNvdXJjZXMgfSA9IGF3YWl0IHRoaXMucHJlcGFyZVNka0ZvcihvcHRpb25zLnN0YWNrLCBvcHRpb25zLnJvbGVBcm4sIE1vZGUuRm9yV3JpdGluZyk7XG5cbiAgICBpZiAoYXNzZXRBcnRpZmFjdCAhPT0gJ25vLXZlcnNpb24tdmFsaWRhdGlvbicpIHtcbiAgICAgIGF3YWl0IHRoaXMudmFsaWRhdGVCb290c3RyYXBTdGFja1ZlcnNpb24oXG4gICAgICAgIG9wdGlvbnMuc3RhY2suc3RhY2tOYW1lLFxuICAgICAgICBhc3NldEFydGlmYWN0LnJlcXVpcmVzQm9vdHN0cmFwU3RhY2tWZXJzaW9uLFxuICAgICAgICBhc3NldEFydGlmYWN0LmJvb3RzdHJhcFN0YWNrVmVyc2lvblNzbVBhcmFtZXRlcixcbiAgICAgICAgZW52UmVzb3VyY2VzKTtcbiAgICB9XG5cbiAgICBjb25zdCBwdWJsaXNoZXIgPSB0aGlzLmNhY2hlZFB1Ymxpc2hlcihhc3NldE1hbmlmZXN0LCByZXNvbHZlZEVudmlyb25tZW50LCBvcHRpb25zLnN0YWNrTmFtZSk7XG4gICAgYXdhaXQgcHVibGlzaGVyLmJ1aWxkRW50cnkoYXNzZXQpO1xuICAgIGlmIChwdWJsaXNoZXIuaGFzRmFpbHVyZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGJ1aWxkIGFzc2V0ICR7YXNzZXQuaWR9YCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFB1Ymxpc2ggYSBzaW5nbGUgYXNzZXQgZnJvbSBhbiBhc3NldCBtYW5pZmVzdFxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgcHVibGljIGFzeW5jIHB1Ymxpc2hTaW5nbGVBc3NldChhc3NldE1hbmlmZXN0OiBBc3NldE1hbmlmZXN0LCBhc3NldDogSU1hbmlmZXN0RW50cnksIG9wdGlvbnM6IFB1Ymxpc2hTdGFja0Fzc2V0c09wdGlvbnMpIHtcbiAgICBjb25zdCB7IHJlc29sdmVkRW52aXJvbm1lbnQ6IHN0YWNrRW52IH0gPSBhd2FpdCB0aGlzLnByZXBhcmVTZGtGb3Iob3B0aW9ucy5zdGFjaywgb3B0aW9ucy5yb2xlQXJuLCBNb2RlLkZvcldyaXRpbmcpO1xuXG4gICAgLy8gTm8gbmVlZCB0byB2YWxpZGF0ZSBhbnltb3JlLCB3ZSBhbHJlYWR5IGRpZCB0aGF0IGR1cmluZyBidWlsZFxuICAgIGNvbnN0IHB1Ymxpc2hlciA9IHRoaXMuY2FjaGVkUHVibGlzaGVyKGFzc2V0TWFuaWZlc3QsIHN0YWNrRW52LCBvcHRpb25zLnN0YWNrTmFtZSk7XG4gICAgYXdhaXQgcHVibGlzaGVyLnB1Ymxpc2hFbnRyeShhc3NldCk7XG4gICAgaWYgKHB1Ymxpc2hlci5oYXNGYWlsdXJlcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcHVibGlzaCBhc3NldCAke2Fzc2V0LmlkfWApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gd2hldGhlciBhIHNpbmdsZSBhc3NldCBoYXMgYmVlbiBwdWJsaXNoZWQgYWxyZWFkeVxuICAgKi9cbiAgcHVibGljIGFzeW5jIGlzU2luZ2xlQXNzZXRQdWJsaXNoZWQoYXNzZXRNYW5pZmVzdDogQXNzZXRNYW5pZmVzdCwgYXNzZXQ6IElNYW5pZmVzdEVudHJ5LCBvcHRpb25zOiBQdWJsaXNoU3RhY2tBc3NldHNPcHRpb25zKSB7XG4gICAgY29uc3QgeyByZXNvbHZlZEVudmlyb25tZW50OiBzdGFja0VudiB9ID0gYXdhaXQgdGhpcy5wcmVwYXJlU2RrRm9yKG9wdGlvbnMuc3RhY2ssIG9wdGlvbnMucm9sZUFybiwgTW9kZS5Gb3JXcml0aW5nKTtcbiAgICBjb25zdCBwdWJsaXNoZXIgPSB0aGlzLmNhY2hlZFB1Ymxpc2hlcihhc3NldE1hbmlmZXN0LCBzdGFja0Vudiwgb3B0aW9ucy5zdGFja05hbWUpO1xuICAgIHJldHVybiBwdWJsaXNoZXIuaXNFbnRyeVB1Ymxpc2hlZChhc3NldCk7XG4gIH1cblxuICAvKipcbiAgICogVmFsaWRhdGUgdGhhdCB0aGUgYm9vdHN0cmFwIHN0YWNrIGhhcyB0aGUgcmlnaHQgdmVyc2lvbiBmb3IgdGhpcyBzdGFja1xuICAgKlxuICAgKiBDYWxsIGludG8gZW52UmVzb3VyY2VzLnZhbGlkYXRlVmVyc2lvbiwgYnV0IHByZXBlbmQgdGhlIHN0YWNrIG5hbWUgaW4gY2FzZSBvZiBmYWlsdXJlLlxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyB2YWxpZGF0ZUJvb3RzdHJhcFN0YWNrVmVyc2lvbihcbiAgICBzdGFja05hbWU6IHN0cmluZyxcbiAgICByZXF1aXJlc0Jvb3RzdHJhcFN0YWNrVmVyc2lvbjogbnVtYmVyIHwgdW5kZWZpbmVkLFxuICAgIGJvb3RzdHJhcFN0YWNrVmVyc2lvblNzbVBhcmFtZXRlcjogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIGVudlJlc291cmNlczogRW52aXJvbm1lbnRSZXNvdXJjZXMpIHtcblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCBlbnZSZXNvdXJjZXMudmFsaWRhdGVWZXJzaW9uKHJlcXVpcmVzQm9vdHN0cmFwU3RhY2tWZXJzaW9uLCBib290c3RyYXBTdGFja1ZlcnNpb25Tc21QYXJhbWV0ZXIpO1xuICAgIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3N0YWNrTmFtZX06ICR7ZS5tZXNzYWdlfWApO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgY2FjaGVkU2RrRm9yRW52aXJvbm1lbnQoXG4gICAgZW52aXJvbm1lbnQ6IGN4YXBpLkVudmlyb25tZW50LFxuICAgIG1vZGU6IE1vZGUsXG4gICAgb3B0aW9ucz86IENyZWRlbnRpYWxzT3B0aW9ucyxcbiAgKSB7XG4gICAgY29uc3QgY2FjaGVLZXlFbGVtZW50cyA9IFtcbiAgICAgIGVudmlyb25tZW50LmFjY291bnQsXG4gICAgICBlbnZpcm9ubWVudC5yZWdpb24sXG4gICAgICBgJHttb2RlfWAsXG4gICAgICBvcHRpb25zPy5hc3N1bWVSb2xlQXJuID8/ICcnLFxuICAgICAgb3B0aW9ucz8uYXNzdW1lUm9sZUV4dGVybmFsSWQgPz8gJycsXG4gICAgXTtcblxuICAgIGlmIChvcHRpb25zPy5hc3N1bWVSb2xlQWRkaXRpb25hbE9wdGlvbnMpIHtcbiAgICAgIGNhY2hlS2V5RWxlbWVudHMucHVzaChKU09OLnN0cmluZ2lmeShvcHRpb25zLmFzc3VtZVJvbGVBZGRpdGlvbmFsT3B0aW9ucykpO1xuICAgIH1cblxuICAgIGNvbnN0IGNhY2hlS2V5ID0gY2FjaGVLZXlFbGVtZW50cy5qb2luKCc6Jyk7XG4gICAgY29uc3QgZXhpc3RpbmcgPSB0aGlzLnNka0NhY2hlLmdldChjYWNoZUtleSk7XG4gICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICAgIGNvbnN0IHJldCA9IGF3YWl0IHRoaXMuc2RrUHJvdmlkZXIuZm9yRW52aXJvbm1lbnQoZW52aXJvbm1lbnQsIG1vZGUsIG9wdGlvbnMpO1xuICAgIHRoaXMuc2RrQ2FjaGUuc2V0KGNhY2hlS2V5LCByZXQpO1xuICAgIHJldHVybiByZXQ7XG4gIH1cblxuICBwcml2YXRlIGNhY2hlZFB1Ymxpc2hlcihhc3NldE1hbmlmZXN0OiBjZGtfYXNzZXRzLkFzc2V0TWFuaWZlc3QsIGVudjogY3hhcGkuRW52aXJvbm1lbnQsIHN0YWNrTmFtZT86IHN0cmluZykge1xuICAgIGNvbnN0IGV4aXN0aW5nID0gdGhpcy5wdWJsaXNoZXJDYWNoZS5nZXQoYXNzZXRNYW5pZmVzdCk7XG4gICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICAgIGNvbnN0IHByZWZpeCA9IHN0YWNrTmFtZSA/IGAke2NoYWxrLmJvbGQoc3RhY2tOYW1lKX06IGAgOiAnJztcbiAgICBjb25zdCBwdWJsaXNoZXIgPSBuZXcgY2RrX2Fzc2V0cy5Bc3NldFB1Ymxpc2hpbmcoYXNzZXRNYW5pZmVzdCwge1xuICAgICAgYXdzOiBuZXcgUHVibGlzaGluZ0F3cyh0aGlzLnNka1Byb3ZpZGVyLCBlbnYpLFxuICAgICAgcHJvZ3Jlc3NMaXN0ZW5lcjogbmV3IFBhcmFsbGVsU2FmZUFzc2V0UHJvZ3Jlc3MocHJlZml4LCB0aGlzLnByb3BzLnF1aWV0ID8/IGZhbHNlKSxcbiAgICB9KTtcbiAgICB0aGlzLnB1Ymxpc2hlckNhY2hlLnNldChhc3NldE1hbmlmZXN0LCBwdWJsaXNoZXIpO1xuICAgIHJldHVybiBwdWJsaXNoZXI7XG4gIH1cbn1cblxuLyoqXG4gKiBBc3NldCBwcm9ncmVzcyB0aGF0IGRvZXNuJ3QgZG8gYW55dGhpbmcgd2l0aCBwZXJjZW50YWdlcyAoY3VycmVudGx5KVxuICovXG5jbGFzcyBQYXJhbGxlbFNhZmVBc3NldFByb2dyZXNzIGltcGxlbWVudHMgY2RrX2Fzc2V0cy5JUHVibGlzaFByb2dyZXNzTGlzdGVuZXIge1xuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IHByZWZpeDogc3RyaW5nLCBwcml2YXRlIHJlYWRvbmx5IHF1aWV0OiBib29sZWFuKSB7XG4gIH1cblxuICBwdWJsaWMgb25QdWJsaXNoRXZlbnQodHlwZTogY2RrX2Fzc2V0cy5FdmVudFR5cGUsIGV2ZW50OiBjZGtfYXNzZXRzLklQdWJsaXNoUHJvZ3Jlc3MpOiB2b2lkIHtcbiAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5xdWlldCAmJiB0eXBlICE9PSAnZmFpbCcgPyBkZWJ1ZyA6IEVWRU5UX1RPX0xPR0dFUlt0eXBlXTtcbiAgICBoYW5kbGVyKGAke3RoaXMucHJlZml4fSR7dHlwZX06ICR7ZXZlbnQubWVzc2FnZX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIEBkZXByZWNhdGVkIFVzZSAnRGVwbG95bWVudHMnIGluc3RlYWRcbiAqL1xuZXhwb3J0IGNsYXNzIENsb3VkRm9ybWF0aW9uRGVwbG95bWVudHMgZXh0ZW5kcyBEZXBsb3ltZW50cyB7XG59XG5cbmZ1bmN0aW9uIHN1ZmZpeFdpdGhFcnJvcnMobXNnOiBzdHJpbmcsIGVycm9ycz86IHN0cmluZ1tdKSB7XG4gIHJldHVybiBlcnJvcnMgJiYgZXJyb3JzLmxlbmd0aCA+IDBcbiAgICA/IGAke21zZ306ICR7ZXJyb3JzLmpvaW4oJywgJyl9YFxuICAgIDogbXNnO1xufSJdfQ==