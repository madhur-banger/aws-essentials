"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ParameterValues = exports.TemplateParameters = exports.stabilizeStack = exports.waitForStackDeploy = exports.waitForStackDelete = exports.changeSetHasNoChanges = exports.cleanupOldChangeset = exports.uploadStackTemplateAssets = exports.createDiffChangeSet = exports.waitForChangeSet = exports.CloudFormationStack = void 0;
const cx_api_1 = require("@aws-cdk/cx-api");
const cxapi = require("@aws-cdk/cx-api");
const cdk_assets_1 = require("cdk-assets");
const stack_status_1 = require("./cloudformation/stack-status");
const template_body_parameter_1 = require("./template-body-parameter");
const logging_1 = require("../../logging");
const serialize_1 = require("../../serialize");
const asset_manifest_builder_1 = require("../../util/asset-manifest-builder");
/**
 * Represents an (existing) Stack in CloudFormation
 *
 * Bundle and cache some information that we need during deployment (so we don't have to make
 * repeated calls to CloudFormation).
 */
class CloudFormationStack {
    static async lookup(cfn, stackName, retrieveProcessedTemplate = false) {
        try {
            const response = await cfn.describeStacks({ StackName: stackName }).promise();
            return new CloudFormationStack(cfn, stackName, response.Stacks && response.Stacks[0], retrieveProcessedTemplate);
        }
        catch (e) {
            if (e.code === 'ValidationError' && e.message === `Stack with id ${stackName} does not exist`) {
                return new CloudFormationStack(cfn, stackName, undefined);
            }
            throw e;
        }
    }
    /**
     * Return a copy of the given stack that does not exist
     *
     * It's a little silly that it needs arguments to do that, but there we go.
     */
    static doesNotExist(cfn, stackName) {
        return new CloudFormationStack(cfn, stackName);
    }
    /**
     * From static information (for testing)
     */
    static fromStaticInformation(cfn, stackName, stack) {
        return new CloudFormationStack(cfn, stackName, stack);
    }
    constructor(cfn, stackName, stack, retrieveProcessedTemplate = false) {
        this.cfn = cfn;
        this.stackName = stackName;
        this.stack = stack;
        this.retrieveProcessedTemplate = retrieveProcessedTemplate;
    }
    /**
     * Retrieve the stack's deployed template
     *
     * Cached, so will only be retrieved once. Will return an empty
     * structure if the stack does not exist.
     */
    async template() {
        if (!this.exists) {
            return {};
        }
        if (this._template === undefined) {
            const response = await this.cfn.getTemplate({
                StackName: this.stackName,
                TemplateStage: this.retrieveProcessedTemplate ? 'Processed' : 'Original',
            }).promise();
            this._template = (response.TemplateBody && (0, serialize_1.deserializeStructure)(response.TemplateBody)) || {};
        }
        return this._template;
    }
    /**
     * Whether the stack exists
     */
    get exists() {
        return this.stack !== undefined;
    }
    /**
     * The stack's ID
     *
     * Throws if the stack doesn't exist.
     */
    get stackId() {
        this.assertExists();
        return this.stack.StackId;
    }
    /**
     * The stack's current outputs
     *
     * Empty object if the stack doesn't exist
     */
    get outputs() {
        if (!this.exists) {
            return {};
        }
        const result = {};
        (this.stack.Outputs || []).forEach(output => {
            result[output.OutputKey] = output.OutputValue;
        });
        return result;
    }
    /**
     * The stack's status
     *
     * Special status NOT_FOUND if the stack does not exist.
     */
    get stackStatus() {
        if (!this.exists) {
            return new stack_status_1.StackStatus('NOT_FOUND', 'Stack not found during lookup');
        }
        return stack_status_1.StackStatus.fromStackDescription(this.stack);
    }
    /**
     * The stack's current tags
     *
     * Empty list if the stack does not exist
     */
    get tags() {
        return this.stack?.Tags || [];
    }
    /**
     * SNS Topic ARNs that will receive stack events.
     *
     * Empty list if the stack does not exist
     */
    get notificationArns() {
        return this.stack?.NotificationARNs ?? [];
    }
    /**
     * Return the names of all current parameters to the stack
     *
     * Empty list if the stack does not exist.
     */
    get parameterNames() {
        return Object.keys(this.parameters);
    }
    /**
     * Return the names and values of all current parameters to the stack
     *
     * Empty object if the stack does not exist.
     */
    get parameters() {
        if (!this.exists) {
            return {};
        }
        const ret = {};
        for (const param of this.stack.Parameters ?? []) {
            ret[param.ParameterKey] = param.ResolvedValue ?? param.ParameterValue;
        }
        return ret;
    }
    /**
     * Return the termination protection of the stack
     */
    get terminationProtection() {
        return this.stack?.EnableTerminationProtection;
    }
    assertExists() {
        if (!this.exists) {
            throw new Error(`No stack named '${this.stackName}'`);
        }
    }
}
exports.CloudFormationStack = CloudFormationStack;
/**
 * Describe a changeset in CloudFormation, regardless of its current state.
 *
 * @param cfn           a CloudFormation client
 * @param stackName     the name of the Stack the ChangeSet belongs to
 * @param changeSetName the name of the ChangeSet
 * @param fetchAll      if true, fetches all pages of the change set description.
 *
 * @returns       CloudFormation information about the ChangeSet
 */
async function describeChangeSet(cfn, stackName, changeSetName, { fetchAll }) {
    const response = await cfn.describeChangeSet({ StackName: stackName, ChangeSetName: changeSetName }).promise();
    // If fetchAll is true, traverse all pages from the change set description.
    while (fetchAll && response.NextToken != null) {
        const nextPage = await cfn.describeChangeSet({
            StackName: stackName,
            ChangeSetName: response.ChangeSetId ?? changeSetName,
            NextToken: response.NextToken,
        }).promise();
        // Consolidate the changes
        if (nextPage.Changes != null) {
            response.Changes = response.Changes != null
                ? response.Changes.concat(nextPage.Changes)
                : nextPage.Changes;
        }
        // Forward the new NextToken
        response.NextToken = nextPage.NextToken;
    }
    return response;
}
/**
 * Waits for a function to return non-+undefined+ before returning.
 *
 * @param valueProvider a function that will return a value that is not +undefined+ once the wait should be over
 * @param timeout     the time to wait between two calls to +valueProvider+
 *
 * @returns       the value that was returned by +valueProvider+
 */
async function waitFor(valueProvider, timeout = 5000) {
    while (true) {
        const result = await valueProvider();
        if (result === null) {
            return undefined;
        }
        else if (result !== undefined) {
            return result;
        }
        await new Promise(cb => setTimeout(cb, timeout));
    }
}
/**
 * Waits for a ChangeSet to be available for triggering a StackUpdate.
 *
 * Will return a changeset that is either ready to be executed or has no changes.
 * Will throw in other cases.
 *
 * @param cfn           a CloudFormation client
 * @param stackName     the name of the Stack that the ChangeSet belongs to
 * @param changeSetName the name of the ChangeSet
 * @param fetchAll      if true, fetches all pages of the ChangeSet before returning.
 *
 * @returns       the CloudFormation description of the ChangeSet
 */
// eslint-disable-next-line max-len
async function waitForChangeSet(cfn, stackName, changeSetName, { fetchAll }) {
    (0, logging_1.debug)('Waiting for changeset %s on stack %s to finish creating...', changeSetName, stackName);
    const ret = await waitFor(async () => {
        const description = await describeChangeSet(cfn, stackName, changeSetName, { fetchAll });
        // The following doesn't use a switch because tsc will not allow fall-through, UNLESS it is allows
        // EVERYWHERE that uses this library directly or indirectly, which is undesirable.
        if (description.Status === 'CREATE_PENDING' || description.Status === 'CREATE_IN_PROGRESS') {
            (0, logging_1.debug)('Changeset %s on stack %s is still creating', changeSetName, stackName);
            return undefined;
        }
        if (description.Status === 'CREATE_COMPLETE' || changeSetHasNoChanges(description)) {
            return description;
        }
        // eslint-disable-next-line max-len
        throw new Error(`Failed to create ChangeSet ${changeSetName} on ${stackName}: ${description.Status || 'NO_STATUS'}, ${description.StatusReason || 'no reason provided'}`);
    });
    if (!ret) {
        throw new Error('Change set took too long to be created; aborting');
    }
    return ret;
}
exports.waitForChangeSet = waitForChangeSet;
/**
 * Create a changeset for a diff operation
 */
async function createDiffChangeSet(options) {
    // `options.stack` has been modified to include any nested stack templates directly inline with its own template, under a special `NestedTemplate` property.
    // Thus the parent template's Resources section contains the nested template's CDK metadata check, which uses Fn::Equals.
    // This causes CreateChangeSet to fail with `Template Error: Fn::Equals cannot be partially collapsed`.
    for (const resource of Object.values((options.stack.template.Resources ?? {}))) {
        if (resource.Type === 'AWS::CloudFormation::Stack') {
            // eslint-disable-next-line no-console
            (0, logging_1.debug)('This stack contains one or more nested stacks, falling back to template-only diff...');
            return undefined;
        }
    }
    return uploadBodyParameterAndCreateChangeSet(options);
}
exports.createDiffChangeSet = createDiffChangeSet;
/**
 * Returns all file entries from an AssetManifestArtifact that look like templates.
 *
 * This is used in the `uploadBodyParameterAndCreateChangeSet` function to find
 * all template asset files to build and publish.
 *
 * Returns a tuple of [AssetManifest, FileManifestEntry[]]
 */
function templatesFromAssetManifestArtifact(artifact) {
    const assets = [];
    const fileName = artifact.file;
    const assetManifest = cdk_assets_1.AssetManifest.fromFile(fileName);
    assetManifest.entries.forEach(entry => {
        if (entry.type === 'file') {
            const source = entry.source;
            if (source.path && (source.path.endsWith('.template.json'))) {
                assets.push(entry);
            }
        }
    });
    return [assetManifest, assets];
}
async function uploadBodyParameterAndCreateChangeSet(options) {
    try {
        await uploadStackTemplateAssets(options.stack, options.deployments);
        const preparedSdk = (await options.deployments.prepareSdkWithDeployRole(options.stack));
        const bodyParameter = await (0, template_body_parameter_1.makeBodyParameter)(options.stack, preparedSdk.resolvedEnvironment, new asset_manifest_builder_1.AssetManifestBuilder(), preparedSdk.envResources, preparedSdk.stackSdk);
        const cfn = preparedSdk.stackSdk.cloudFormation();
        const exists = (await CloudFormationStack.lookup(cfn, options.stack.stackName, false)).exists;
        const executionRoleArn = preparedSdk.cloudFormationRoleArn;
        options.stream.write('Hold on while we create a read-only change set to get a diff with accurate replacement information (use --no-change-set to use a less accurate but faster template-only diff)\n');
        return await createChangeSet({
            cfn,
            changeSetName: 'cdk-diff-change-set',
            stack: options.stack,
            exists,
            uuid: options.uuid,
            willExecute: options.willExecute,
            bodyParameter,
            parameters: options.parameters,
            resourcesToImport: options.resourcesToImport,
            role: executionRoleArn,
        });
    }
    catch (e) {
        (0, logging_1.debug)(e.message);
        options.stream.write('Could not create a change set, will base the diff on template differences (run again with -v to see the reason)\n');
        return undefined;
    }
}
/**
 * Uploads the assets that look like templates for this CloudFormation stack
 *
 * This is necessary for any CloudFormation call that needs the template, it may need
 * to be uploaded to an S3 bucket first. We have to follow the instructions in the
 * asset manifest, because technically that is the only place that knows about
 * bucket and assumed roles and such.
 */
async function uploadStackTemplateAssets(stack, deployments) {
    for (const artifact of stack.dependencies) {
        // Skip artifact if it is not an Asset Manifest Artifact
        if (!cxapi.AssetManifestArtifact.isAssetManifestArtifact(artifact)) {
            continue;
        }
        const [assetManifest, file_entries] = templatesFromAssetManifestArtifact(artifact);
        for (const entry of file_entries) {
            await deployments.buildSingleAsset(artifact, assetManifest, entry, {
                stack,
            });
            await deployments.publishSingleAsset(assetManifest, entry, {
                stack,
            });
        }
    }
}
exports.uploadStackTemplateAssets = uploadStackTemplateAssets;
async function createChangeSet(options) {
    await cleanupOldChangeset(options.changeSetName, options.stack.stackName, options.cfn);
    (0, logging_1.debug)(`Attempting to create ChangeSet with name ${options.changeSetName} for stack ${options.stack.stackName}`);
    const templateParams = TemplateParameters.fromTemplate(options.stack.template);
    const stackParams = templateParams.supplyAll(options.parameters);
    const changeSet = await options.cfn.createChangeSet({
        StackName: options.stack.stackName,
        ChangeSetName: options.changeSetName,
        ChangeSetType: options.resourcesToImport ? 'IMPORT' : options.exists ? 'UPDATE' : 'CREATE',
        Description: `CDK Changeset for diff ${options.uuid}`,
        ClientToken: `diff${options.uuid}`,
        TemplateURL: options.bodyParameter.TemplateURL,
        TemplateBody: options.bodyParameter.TemplateBody,
        Parameters: stackParams.apiParameters,
        ResourcesToImport: options.resourcesToImport,
        RoleARN: options.role,
        Capabilities: ['CAPABILITY_IAM', 'CAPABILITY_NAMED_IAM', 'CAPABILITY_AUTO_EXPAND'],
    }).promise();
    (0, logging_1.debug)('Initiated creation of changeset: %s; waiting for it to finish creating...', changeSet.Id);
    // Fetching all pages if we'll execute, so we can have the correct change count when monitoring.
    const createdChangeSet = await waitForChangeSet(options.cfn, options.stack.stackName, options.changeSetName, { fetchAll: options.willExecute });
    await cleanupOldChangeset(options.changeSetName, options.stack.stackName, options.cfn);
    // TODO: Update this once we remove sdkv2 from the rest of this package
    return createdChangeSet;
}
async function cleanupOldChangeset(changeSetName, stackName, cfn) {
    // Delete any existing change sets generated by CDK since change set names must be unique.
    // The delete request is successful as long as the stack exists (even if the change set does not exist).
    (0, logging_1.debug)(`Removing existing change set with name ${changeSetName} if it exists`);
    await cfn.deleteChangeSet({ StackName: stackName, ChangeSetName: changeSetName }).promise();
}
exports.cleanupOldChangeset = cleanupOldChangeset;
/**
 * Return true if the given change set has no changes
 *
 * This must be determined from the status, not the 'Changes' array on the
 * object; the latter can be empty because no resources were changed, but if
 * there are changes to Outputs, the change set can still be executed.
 */
function changeSetHasNoChanges(description) {
    const noChangeErrorPrefixes = [
        // Error message for a regular template
        'The submitted information didn\'t contain changes.',
        // Error message when a Transform is involved (see #10650)
        'No updates are to be performed.',
    ];
    return description.Status === 'FAILED'
        && noChangeErrorPrefixes.some(p => (description.StatusReason ?? '').startsWith(p));
}
exports.changeSetHasNoChanges = changeSetHasNoChanges;
/**
 * Waits for a CloudFormation stack to stabilize in a complete/available state
 * after a delete operation is issued.
 *
 * Fails if the stack is in a FAILED state. Will not fail if the stack was
 * already deleted.
 *
 * @param cfn        a CloudFormation client
 * @param stackName      the name of the stack to wait for after a delete
 *
 * @returns     the CloudFormation description of the stabilized stack after the delete attempt
 */
async function waitForStackDelete(cfn, stackName) {
    const stack = await stabilizeStack(cfn, stackName);
    if (!stack) {
        return undefined;
    }
    const status = stack.stackStatus;
    if (status.isFailure) {
        throw new Error(`The stack named ${stackName} is in a failed state. You may need to delete it from the AWS console : ${status}`);
    }
    else if (status.isDeleted) {
        return undefined;
    }
    return stack;
}
exports.waitForStackDelete = waitForStackDelete;
/**
 * Waits for a CloudFormation stack to stabilize in a complete/available state
 * after an update/create operation is issued.
 *
 * Fails if the stack is in a FAILED state, ROLLBACK state, or DELETED state.
 *
 * @param cfn        a CloudFormation client
 * @param stackName      the name of the stack to wait for after an update
 *
 * @returns     the CloudFormation description of the stabilized stack after the update attempt
 */
async function waitForStackDeploy(cfn, stackName) {
    const stack = await stabilizeStack(cfn, stackName);
    if (!stack) {
        return undefined;
    }
    const status = stack.stackStatus;
    if (status.isCreationFailure) {
        throw new Error(`The stack named ${stackName} failed creation, it may need to be manually deleted from the AWS console: ${status}`);
    }
    else if (!status.isDeploySuccess) {
        throw new Error(`The stack named ${stackName} failed to deploy: ${status}`);
    }
    return stack;
}
exports.waitForStackDeploy = waitForStackDeploy;
/**
 * Wait for a stack to become stable (no longer _IN_PROGRESS), returning it
 */
async function stabilizeStack(cfn, stackName) {
    (0, logging_1.debug)('Waiting for stack %s to finish creating or updating...', stackName);
    return waitFor(async () => {
        const stack = await CloudFormationStack.lookup(cfn, stackName);
        if (!stack.exists) {
            (0, logging_1.debug)('Stack %s does not exist', stackName);
            return null;
        }
        const status = stack.stackStatus;
        if (status.isInProgress) {
            (0, logging_1.debug)('Stack %s has an ongoing operation in progress and is not stable (%s)', stackName, status);
            return undefined;
        }
        else if (status.isReviewInProgress) {
            // This may happen if a stack creation operation is interrupted before the ChangeSet execution starts. Recovering
            // from this would requiring manual intervention (deleting or executing the pending ChangeSet), and failing to do
            // so will result in an endless wait here (the ChangeSet wont delete or execute itself). Instead of blocking
            // "forever" we proceed as if the stack was existing and stable. If there is a concurrent operation that just
            // hasn't finished proceeding just yet, either this operation or the concurrent one may fail due to the other one
            // having made progress. Which is fine. I guess.
            (0, logging_1.debug)('Stack %s is in REVIEW_IN_PROGRESS state. Considering this is a stable status (%s)', stackName, status);
        }
        return stack;
    });
}
exports.stabilizeStack = stabilizeStack;
/**
 * The set of (formal) parameters that have been declared in a template
 */
class TemplateParameters {
    static fromTemplate(template) {
        return new TemplateParameters(template.Parameters || {});
    }
    constructor(params) {
        this.params = params;
    }
    /**
     * Calculate stack parameters to pass from the given desired parameter values
     *
     * Will throw if parameters without a Default value or a Previous value are not
     * supplied.
     */
    supplyAll(updates) {
        return new ParameterValues(this.params, updates);
    }
    /**
     * From the template, the given desired values and the current values, calculate the changes to the stack parameters
     *
     * Will take into account parameters already set on the template (will emit
     * 'UsePreviousValue: true' for those unless the value is changed), and will
     * throw if parameters without a Default value or a Previous value are not
     * supplied.
     */
    updateExisting(updates, previousValues) {
        return new ParameterValues(this.params, updates, previousValues);
    }
}
exports.TemplateParameters = TemplateParameters;
/**
 * The set of parameters we're going to pass to a Stack
 */
class ParameterValues {
    constructor(formalParams, updates, previousValues = {}) {
        this.formalParams = formalParams;
        this.values = {};
        this.apiParameters = [];
        const missingRequired = new Array();
        for (const [key, formalParam] of Object.entries(this.formalParams)) {
            // Check updates first, then use the previous value (if available), then use
            // the default (if available).
            //
            // If we don't find a parameter value using any of these methods, then that's an error.
            const updatedValue = updates[key];
            if (updatedValue !== undefined) {
                this.values[key] = updatedValue;
                this.apiParameters.push({ ParameterKey: key, ParameterValue: updates[key] });
                continue;
            }
            if (key in previousValues) {
                this.values[key] = previousValues[key];
                this.apiParameters.push({ ParameterKey: key, UsePreviousValue: true });
                continue;
            }
            if (formalParam.Default !== undefined) {
                this.values[key] = formalParam.Default;
                continue;
            }
            // Oh no
            missingRequired.push(key);
        }
        if (missingRequired.length > 0) {
            throw new Error(`The following CloudFormation Parameters are missing a value: ${missingRequired.join(', ')}`);
        }
        // Just append all supplied overrides that aren't really expected (this
        // will fail CFN but maybe people made typos that they want to be notified
        // of)
        const unknownParam = ([key, _]) => this.formalParams[key] === undefined;
        const hasValue = ([_, value]) => !!value;
        for (const [key, value] of Object.entries(updates).filter(unknownParam).filter(hasValue)) {
            this.values[key] = value;
            this.apiParameters.push({ ParameterKey: key, ParameterValue: value });
        }
    }
    /**
     * Whether this set of parameter updates will change the actual stack values
     */
    hasChanges(currentValues) {
        // If any of the parameters are SSM parameters, deploying must always happen
        // because we can't predict what the values will be. We will allow some
        // parameters to opt out of this check by having a magic string in their description.
        if (Object.values(this.formalParams).some(p => p.Type.startsWith('AWS::SSM::Parameter::') && !p.Description?.includes(cx_api_1.SSMPARAM_NO_INVALIDATE))) {
            return 'ssm';
        }
        // Otherwise we're dirty if:
        // - any of the existing values are removed, or changed
        if (Object.entries(currentValues).some(([key, value]) => !(key in this.values) || value !== this.values[key])) {
            return true;
        }
        // - any of the values we're setting are new
        if (Object.keys(this.values).some(key => !(key in currentValues))) {
            return true;
        }
        return false;
    }
}
exports.ParameterValues = ParameterValues;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2xvdWRmb3JtYXRpb24uanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJjbG91ZGZvcm1hdGlvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFFQSw0Q0FBeUQ7QUFDekQseUNBQXlDO0FBRXpDLDJDQUE4RDtBQUM5RCxnRUFBNEQ7QUFDNUQsdUVBQXFGO0FBQ3JGLDJDQUFzQztBQUN0QywrQ0FBdUQ7QUFDdkQsOEVBQXlFO0FBb0J6RTs7Ozs7R0FLRztBQUNILE1BQWEsbUJBQW1CO0lBQ3ZCLE1BQU0sQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUN4QixHQUFtQixFQUFFLFNBQWlCLEVBQUUsNEJBQXFDLEtBQUs7UUFFbEYsSUFBSSxDQUFDO1lBQ0gsTUFBTSxRQUFRLEdBQUcsTUFBTSxHQUFHLENBQUMsY0FBYyxDQUFDLEVBQUUsU0FBUyxFQUFFLFNBQVMsRUFBRSxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7WUFDOUUsT0FBTyxJQUFJLG1CQUFtQixDQUFDLEdBQUcsRUFBRSxTQUFTLEVBQUUsUUFBUSxDQUFDLE1BQU0sSUFBSSxRQUFRLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxFQUFFLHlCQUF5QixDQUFDLENBQUM7UUFDbkgsQ0FBQztRQUFDLE9BQU8sQ0FBTSxFQUFFLENBQUM7WUFDaEIsSUFBSSxDQUFDLENBQUMsSUFBSSxLQUFLLGlCQUFpQixJQUFJLENBQUMsQ0FBQyxPQUFPLEtBQUssaUJBQWlCLFNBQVMsaUJBQWlCLEVBQUUsQ0FBQztnQkFDOUYsT0FBTyxJQUFJLG1CQUFtQixDQUFDLEdBQUcsRUFBRSxTQUFTLEVBQUUsU0FBUyxDQUFDLENBQUM7WUFDNUQsQ0FBQztZQUNELE1BQU0sQ0FBQyxDQUFDO1FBQ1YsQ0FBQztJQUNILENBQUM7SUFFRDs7OztPQUlHO0lBQ0ksTUFBTSxDQUFDLFlBQVksQ0FBQyxHQUFtQixFQUFFLFNBQWlCO1FBQy9ELE9BQU8sSUFBSSxtQkFBbUIsQ0FBQyxHQUFHLEVBQUUsU0FBUyxDQUFDLENBQUM7SUFDakQsQ0FBQztJQUVEOztPQUVHO0lBQ0ksTUFBTSxDQUFDLHFCQUFxQixDQUFDLEdBQW1CLEVBQUUsU0FBaUIsRUFBRSxLQUEyQjtRQUNyRyxPQUFPLElBQUksbUJBQW1CLENBQUMsR0FBRyxFQUFFLFNBQVMsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUN4RCxDQUFDO0lBSUQsWUFDbUIsR0FBbUIsRUFBa0IsU0FBaUIsRUFBbUIsS0FBNEIsRUFDckcsNEJBQXFDLEtBQUs7UUFEMUMsUUFBRyxHQUFILEdBQUcsQ0FBZ0I7UUFBa0IsY0FBUyxHQUFULFNBQVMsQ0FBUTtRQUFtQixVQUFLLEdBQUwsS0FBSyxDQUF1QjtRQUNyRyw4QkFBeUIsR0FBekIseUJBQXlCLENBQWlCO0lBRTdELENBQUM7SUFFRDs7Ozs7T0FLRztJQUNJLEtBQUssQ0FBQyxRQUFRO1FBQ25CLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7WUFDakIsT0FBTyxFQUFFLENBQUM7UUFDWixDQUFDO1FBRUQsSUFBSSxJQUFJLENBQUMsU0FBUyxLQUFLLFNBQVMsRUFBRSxDQUFDO1lBQ2pDLE1BQU0sUUFBUSxHQUFHLE1BQU0sSUFBSSxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUM7Z0JBQzFDLFNBQVMsRUFBRSxJQUFJLENBQUMsU0FBUztnQkFDekIsYUFBYSxFQUFFLElBQUksQ0FBQyx5QkFBeUIsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQyxVQUFVO2FBQ3pFLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztZQUNiLElBQUksQ0FBQyxTQUFTLEdBQUcsQ0FBQyxRQUFRLENBQUMsWUFBWSxJQUFJLElBQUEsZ0NBQW9CLEVBQUMsUUFBUSxDQUFDLFlBQVksQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ2hHLENBQUM7UUFDRCxPQUFPLElBQUksQ0FBQyxTQUFTLENBQUM7SUFDeEIsQ0FBQztJQUVEOztPQUVHO0lBQ0gsSUFBVyxNQUFNO1FBQ2YsT0FBTyxJQUFJLENBQUMsS0FBSyxLQUFLLFNBQVMsQ0FBQztJQUNsQyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILElBQVcsT0FBTztRQUNoQixJQUFJLENBQUMsWUFBWSxFQUFFLENBQUM7UUFDcEIsT0FBTyxJQUFJLENBQUMsS0FBTSxDQUFDLE9BQVEsQ0FBQztJQUM5QixDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILElBQVcsT0FBTztRQUNoQixJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1lBQUMsT0FBTyxFQUFFLENBQUM7UUFBQyxDQUFDO1FBQ2hDLE1BQU0sTUFBTSxHQUErQixFQUFFLENBQUM7UUFDOUMsQ0FBQyxJQUFJLENBQUMsS0FBTSxDQUFDLE9BQU8sSUFBSSxFQUFFLENBQUMsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDM0MsTUFBTSxDQUFDLE1BQU0sQ0FBQyxTQUFVLENBQUMsR0FBRyxNQUFNLENBQUMsV0FBWSxDQUFDO1FBQ2xELENBQUMsQ0FBQyxDQUFDO1FBQ0gsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQztJQUVEOzs7O09BSUc7SUFDSCxJQUFXLFdBQVc7UUFDcEIsSUFBSSxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQztZQUNqQixPQUFPLElBQUksMEJBQVcsQ0FBQyxXQUFXLEVBQUUsK0JBQStCLENBQUMsQ0FBQztRQUN2RSxDQUFDO1FBQ0QsT0FBTywwQkFBVyxDQUFDLG9CQUFvQixDQUFDLElBQUksQ0FBQyxLQUFNLENBQUMsQ0FBQztJQUN2RCxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILElBQVcsSUFBSTtRQUNiLE9BQU8sSUFBSSxDQUFDLEtBQUssRUFBRSxJQUFJLElBQUksRUFBRSxDQUFDO0lBQ2hDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsSUFBVyxnQkFBZ0I7UUFDekIsT0FBTyxJQUFJLENBQUMsS0FBSyxFQUFFLGdCQUFnQixJQUFJLEVBQUUsQ0FBQztJQUM1QyxDQUFDO0lBRUQ7Ozs7T0FJRztJQUNILElBQVcsY0FBYztRQUN2QixPQUFPLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQ3RDLENBQUM7SUFFRDs7OztPQUlHO0lBQ0gsSUFBVyxVQUFVO1FBQ25CLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUM7WUFBQyxPQUFPLEVBQUUsQ0FBQztRQUFDLENBQUM7UUFDaEMsTUFBTSxHQUFHLEdBQTJCLEVBQUUsQ0FBQztRQUN2QyxLQUFLLE1BQU0sS0FBSyxJQUFJLElBQUksQ0FBQyxLQUFNLENBQUMsVUFBVSxJQUFJLEVBQUUsRUFBRSxDQUFDO1lBQ2pELEdBQUcsQ0FBQyxLQUFLLENBQUMsWUFBYSxDQUFDLEdBQUcsS0FBSyxDQUFDLGFBQWEsSUFBSSxLQUFLLENBQUMsY0FBZSxDQUFDO1FBQzFFLENBQUM7UUFDRCxPQUFPLEdBQUcsQ0FBQztJQUNiLENBQUM7SUFFRDs7T0FFRztJQUNILElBQVcscUJBQXFCO1FBQzlCLE9BQU8sSUFBSSxDQUFDLEtBQUssRUFBRSwyQkFBMkIsQ0FBQztJQUNqRCxDQUFDO0lBRU8sWUFBWTtRQUNsQixJQUFJLENBQUMsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1lBQ2pCLE1BQU0sSUFBSSxLQUFLLENBQUMsbUJBQW1CLElBQUksQ0FBQyxTQUFTLEdBQUcsQ0FBQyxDQUFDO1FBQ3hELENBQUM7SUFDSCxDQUFDO0NBQ0Y7QUE1SkQsa0RBNEpDO0FBRUQ7Ozs7Ozs7OztHQVNHO0FBQ0gsS0FBSyxVQUFVLGlCQUFpQixDQUM5QixHQUFtQixFQUNuQixTQUFpQixFQUNqQixhQUFxQixFQUNyQixFQUFFLFFBQVEsRUFBeUI7SUFFbkMsTUFBTSxRQUFRLEdBQUcsTUFBTSxHQUFHLENBQUMsaUJBQWlCLENBQUMsRUFBRSxTQUFTLEVBQUUsU0FBUyxFQUFFLGFBQWEsRUFBRSxhQUFhLEVBQUUsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFDO0lBRS9HLDJFQUEyRTtJQUMzRSxPQUFPLFFBQVEsSUFBSSxRQUFRLENBQUMsU0FBUyxJQUFJLElBQUksRUFBRSxDQUFDO1FBQzlDLE1BQU0sUUFBUSxHQUFHLE1BQU0sR0FBRyxDQUFDLGlCQUFpQixDQUFDO1lBQzNDLFNBQVMsRUFBRSxTQUFTO1lBQ3BCLGFBQWEsRUFBRSxRQUFRLENBQUMsV0FBVyxJQUFJLGFBQWE7WUFDcEQsU0FBUyxFQUFFLFFBQVEsQ0FBQyxTQUFTO1NBQzlCLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztRQUViLDBCQUEwQjtRQUMxQixJQUFJLFFBQVEsQ0FBQyxPQUFPLElBQUksSUFBSSxFQUFFLENBQUM7WUFDN0IsUUFBUSxDQUFDLE9BQU8sR0FBRyxRQUFRLENBQUMsT0FBTyxJQUFJLElBQUk7Z0JBQ3pDLENBQUMsQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsT0FBTyxDQUFDO2dCQUMzQyxDQUFDLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQztRQUN2QixDQUFDO1FBRUQsNEJBQTRCO1FBQzVCLFFBQVEsQ0FBQyxTQUFTLEdBQUcsUUFBUSxDQUFDLFNBQVMsQ0FBQztJQUMxQyxDQUFDO0lBRUQsT0FBTyxRQUFRLENBQUM7QUFDbEIsQ0FBQztBQUVEOzs7Ozs7O0dBT0c7QUFDSCxLQUFLLFVBQVUsT0FBTyxDQUFJLGFBQWtELEVBQUUsVUFBa0IsSUFBSTtJQUNsRyxPQUFPLElBQUksRUFBRSxDQUFDO1FBQ1osTUFBTSxNQUFNLEdBQUcsTUFBTSxhQUFhLEVBQUUsQ0FBQztRQUNyQyxJQUFJLE1BQU0sS0FBSyxJQUFJLEVBQUUsQ0FBQztZQUNwQixPQUFPLFNBQVMsQ0FBQztRQUNuQixDQUFDO2FBQU0sSUFBSSxNQUFNLEtBQUssU0FBUyxFQUFFLENBQUM7WUFDaEMsT0FBTyxNQUFNLENBQUM7UUFDaEIsQ0FBQztRQUNELE1BQU0sSUFBSSxPQUFPLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsRUFBRSxFQUFFLE9BQU8sQ0FBQyxDQUFDLENBQUM7SUFDbkQsQ0FBQztBQUNILENBQUM7QUFFRDs7Ozs7Ozs7Ozs7O0dBWUc7QUFDSCxtQ0FBbUM7QUFDNUIsS0FBSyxVQUFVLGdCQUFnQixDQUNwQyxHQUFtQixFQUNuQixTQUFpQixFQUNqQixhQUFxQixFQUNyQixFQUFFLFFBQVEsRUFBeUI7SUFFbkMsSUFBQSxlQUFLLEVBQUMsNERBQTRELEVBQUUsYUFBYSxFQUFFLFNBQVMsQ0FBQyxDQUFDO0lBQzlGLE1BQU0sR0FBRyxHQUFHLE1BQU0sT0FBTyxDQUFDLEtBQUssSUFBSSxFQUFFO1FBQ25DLE1BQU0sV0FBVyxHQUFHLE1BQU0saUJBQWlCLENBQUMsR0FBRyxFQUFFLFNBQVMsRUFBRSxhQUFhLEVBQUUsRUFBRSxRQUFRLEVBQUUsQ0FBQyxDQUFDO1FBQ3pGLGtHQUFrRztRQUNsRyxrRkFBa0Y7UUFDbEYsSUFBSSxXQUFXLENBQUMsTUFBTSxLQUFLLGdCQUFnQixJQUFJLFdBQVcsQ0FBQyxNQUFNLEtBQUssb0JBQW9CLEVBQUUsQ0FBQztZQUMzRixJQUFBLGVBQUssRUFBQyw0Q0FBNEMsRUFBRSxhQUFhLEVBQUUsU0FBUyxDQUFDLENBQUM7WUFDOUUsT0FBTyxTQUFTLENBQUM7UUFDbkIsQ0FBQztRQUVELElBQUksV0FBVyxDQUFDLE1BQU0sS0FBSyxpQkFBaUIsSUFBSSxxQkFBcUIsQ0FBQyxXQUFXLENBQUMsRUFBRSxDQUFDO1lBQ25GLE9BQU8sV0FBVyxDQUFDO1FBQ3JCLENBQUM7UUFFRCxtQ0FBbUM7UUFDbkMsTUFBTSxJQUFJLEtBQUssQ0FBQyw4QkFBOEIsYUFBYSxPQUFPLFNBQVMsS0FBSyxXQUFXLENBQUMsTUFBTSxJQUFJLFdBQVcsS0FBSyxXQUFXLENBQUMsWUFBWSxJQUFJLG9CQUFvQixFQUFFLENBQUMsQ0FBQztJQUM1SyxDQUFDLENBQUMsQ0FBQztJQUVILElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUNULE1BQU0sSUFBSSxLQUFLLENBQUMsa0RBQWtELENBQUMsQ0FBQztJQUN0RSxDQUFDO0lBRUQsT0FBTyxHQUFHLENBQUM7QUFDYixDQUFDO0FBN0JELDRDQTZCQztBQTBCRDs7R0FFRztBQUNJLEtBQUssVUFBVSxtQkFBbUIsQ0FBQyxPQUFnQztJQUN4RSw0SkFBNEo7SUFDNUoseUhBQXlIO0lBQ3pILHVHQUF1RztJQUN2RyxLQUFLLE1BQU0sUUFBUSxJQUFJLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxTQUFTLElBQUksRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDO1FBQy9FLElBQUssUUFBZ0IsQ0FBQyxJQUFJLEtBQUssNEJBQTRCLEVBQUUsQ0FBQztZQUM1RCxzQ0FBc0M7WUFDdEMsSUFBQSxlQUFLLEVBQUMsc0ZBQXNGLENBQUMsQ0FBQztZQUU5RixPQUFPLFNBQVMsQ0FBQztRQUNuQixDQUFDO0lBQ0gsQ0FBQztJQUVELE9BQU8scUNBQXFDLENBQUMsT0FBTyxDQUFDLENBQUM7QUFDeEQsQ0FBQztBQWRELGtEQWNDO0FBRUQ7Ozs7Ozs7R0FPRztBQUNILFNBQVMsa0NBQWtDLENBQUMsUUFBcUM7SUFDL0UsTUFBTSxNQUFNLEdBQTBCLEVBQUUsQ0FBQztJQUN6QyxNQUFNLFFBQVEsR0FBRyxRQUFRLENBQUMsSUFBSSxDQUFDO0lBQy9CLE1BQU0sYUFBYSxHQUFHLDBCQUFhLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBRXZELGFBQWEsQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxFQUFFO1FBQ3BDLElBQUksS0FBSyxDQUFDLElBQUksS0FBSyxNQUFNLEVBQUUsQ0FBQztZQUMxQixNQUFNLE1BQU0sR0FBSSxLQUEyQixDQUFDLE1BQU0sQ0FBQztZQUNuRCxJQUFJLE1BQU0sQ0FBQyxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLEVBQUUsQ0FBQztnQkFDNUQsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUEwQixDQUFDLENBQUM7WUFDMUMsQ0FBQztRQUNILENBQUM7SUFDSCxDQUFDLENBQUMsQ0FBQztJQUNILE9BQU8sQ0FBQyxhQUFhLEVBQUUsTUFBTSxDQUFDLENBQUM7QUFDakMsQ0FBQztBQUVELEtBQUssVUFBVSxxQ0FBcUMsQ0FBQyxPQUFnQztJQUNuRixJQUFJLENBQUM7UUFDSCxNQUFNLHlCQUF5QixDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQ3BFLE1BQU0sV0FBVyxHQUFHLENBQUMsTUFBTSxPQUFPLENBQUMsV0FBVyxDQUFDLHdCQUF3QixDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBRXhGLE1BQU0sYUFBYSxHQUFHLE1BQU0sSUFBQSwyQ0FBaUIsRUFDM0MsT0FBTyxDQUFDLEtBQUssRUFDYixXQUFXLENBQUMsbUJBQW1CLEVBQy9CLElBQUksNkNBQW9CLEVBQUUsRUFDMUIsV0FBVyxDQUFDLFlBQVksRUFDeEIsV0FBVyxDQUFDLFFBQVEsQ0FDckIsQ0FBQztRQUNGLE1BQU0sR0FBRyxHQUFHLFdBQVcsQ0FBQyxRQUFRLENBQUMsY0FBYyxFQUFFLENBQUM7UUFDbEQsTUFBTSxNQUFNLEdBQUcsQ0FBQyxNQUFNLG1CQUFtQixDQUFDLE1BQU0sQ0FBQyxHQUFHLEVBQUUsT0FBTyxDQUFDLEtBQUssQ0FBQyxTQUFTLEVBQUUsS0FBSyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUM7UUFFOUYsTUFBTSxnQkFBZ0IsR0FBRyxXQUFXLENBQUMscUJBQXFCLENBQUM7UUFDM0QsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsaUxBQWlMLENBQUMsQ0FBQztRQUV4TSxPQUFPLE1BQU0sZUFBZSxDQUFDO1lBQzNCLEdBQUc7WUFDSCxhQUFhLEVBQUUscUJBQXFCO1lBQ3BDLEtBQUssRUFBRSxPQUFPLENBQUMsS0FBSztZQUNwQixNQUFNO1lBQ04sSUFBSSxFQUFFLE9BQU8sQ0FBQyxJQUFJO1lBQ2xCLFdBQVcsRUFBRSxPQUFPLENBQUMsV0FBVztZQUNoQyxhQUFhO1lBQ2IsVUFBVSxFQUFFLE9BQU8sQ0FBQyxVQUFVO1lBQzlCLGlCQUFpQixFQUFFLE9BQU8sQ0FBQyxpQkFBaUI7WUFDNUMsSUFBSSxFQUFFLGdCQUFnQjtTQUN2QixDQUFDLENBQUM7SUFDTCxDQUFDO0lBQUMsT0FBTyxDQUFNLEVBQUUsQ0FBQztRQUNoQixJQUFBLGVBQUssRUFBQyxDQUFDLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDakIsT0FBTyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsbUhBQW1ILENBQUMsQ0FBQztRQUUxSSxPQUFPLFNBQVMsQ0FBQztJQUNuQixDQUFDO0FBQ0gsQ0FBQztBQUVEOzs7Ozs7O0dBT0c7QUFDSSxLQUFLLFVBQVUseUJBQXlCLENBQUMsS0FBd0MsRUFBRSxXQUF3QjtJQUNoSCxLQUFLLE1BQU0sUUFBUSxJQUFJLEtBQUssQ0FBQyxZQUFZLEVBQUUsQ0FBQztRQUMxQyx3REFBd0Q7UUFDeEQsSUFBSSxDQUFDLEtBQUssQ0FBQyxxQkFBcUIsQ0FBQyx1QkFBdUIsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDO1lBQ25FLFNBQVM7UUFDWCxDQUFDO1FBRUQsTUFBTSxDQUFDLGFBQWEsRUFBRSxZQUFZLENBQUMsR0FBRyxrQ0FBa0MsQ0FBQyxRQUFRLENBQUMsQ0FBQztRQUNuRixLQUFLLE1BQU0sS0FBSyxJQUFJLFlBQVksRUFBRSxDQUFDO1lBQ2pDLE1BQU0sV0FBVyxDQUFDLGdCQUFnQixDQUFDLFFBQVEsRUFBRSxhQUFhLEVBQUUsS0FBSyxFQUFFO2dCQUNqRSxLQUFLO2FBQ04sQ0FBQyxDQUFDO1lBQ0gsTUFBTSxXQUFXLENBQUMsa0JBQWtCLENBQUMsYUFBYSxFQUFFLEtBQUssRUFBRTtnQkFDekQsS0FBSzthQUNOLENBQUMsQ0FBQztRQUNMLENBQUM7SUFDSCxDQUFDO0FBQ0gsQ0FBQztBQWpCRCw4REFpQkM7QUFFRCxLQUFLLFVBQVUsZUFBZSxDQUFDLE9BQStCO0lBQzVELE1BQU0sbUJBQW1CLENBQUMsT0FBTyxDQUFDLGFBQWEsRUFBRSxPQUFPLENBQUMsS0FBSyxDQUFDLFNBQVMsRUFBRSxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7SUFFdkYsSUFBQSxlQUFLLEVBQUMsNENBQTRDLE9BQU8sQ0FBQyxhQUFhLGNBQWMsT0FBTyxDQUFDLEtBQUssQ0FBQyxTQUFTLEVBQUUsQ0FBQyxDQUFDO0lBRWhILE1BQU0sY0FBYyxHQUFHLGtCQUFrQixDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQy9FLE1BQU0sV0FBVyxHQUFHLGNBQWMsQ0FBQyxTQUFTLENBQUMsT0FBTyxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBRWpFLE1BQU0sU0FBUyxHQUFHLE1BQU0sT0FBTyxDQUFDLEdBQUcsQ0FBQyxlQUFlLENBQUM7UUFDbEQsU0FBUyxFQUFFLE9BQU8sQ0FBQyxLQUFLLENBQUMsU0FBUztRQUNsQyxhQUFhLEVBQUUsT0FBTyxDQUFDLGFBQWE7UUFDcEMsYUFBYSxFQUFFLE9BQU8sQ0FBQyxpQkFBaUIsQ0FBQyxDQUFDLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLFFBQVE7UUFDMUYsV0FBVyxFQUFFLDBCQUEwQixPQUFPLENBQUMsSUFBSSxFQUFFO1FBQ3JELFdBQVcsRUFBRSxPQUFPLE9BQU8sQ0FBQyxJQUFJLEVBQUU7UUFDbEMsV0FBVyxFQUFFLE9BQU8sQ0FBQyxhQUFhLENBQUMsV0FBVztRQUM5QyxZQUFZLEVBQUUsT0FBTyxDQUFDLGFBQWEsQ0FBQyxZQUFZO1FBQ2hELFVBQVUsRUFBRSxXQUFXLENBQUMsYUFBYTtRQUNyQyxpQkFBaUIsRUFBRSxPQUFPLENBQUMsaUJBQWlCO1FBQzVDLE9BQU8sRUFBRSxPQUFPLENBQUMsSUFBSTtRQUNyQixZQUFZLEVBQUUsQ0FBQyxnQkFBZ0IsRUFBRSxzQkFBc0IsRUFBRSx3QkFBd0IsQ0FBQztLQUNuRixDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7SUFFYixJQUFBLGVBQUssRUFBQywyRUFBMkUsRUFBRSxTQUFTLENBQUMsRUFBRSxDQUFDLENBQUM7SUFDakcsZ0dBQWdHO0lBQ2hHLE1BQU0sZ0JBQWdCLEdBQUcsTUFBTSxnQkFBZ0IsQ0FBQyxPQUFPLENBQUMsR0FBRyxFQUFFLE9BQU8sQ0FBQyxLQUFLLENBQUMsU0FBUyxFQUFFLE9BQU8sQ0FBQyxhQUFhLEVBQUUsRUFBRSxRQUFRLEVBQUUsT0FBTyxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUM7SUFDaEosTUFBTSxtQkFBbUIsQ0FBQyxPQUFPLENBQUMsYUFBYSxFQUFFLE9BQU8sQ0FBQyxLQUFLLENBQUMsU0FBUyxFQUFFLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUV2Rix1RUFBdUU7SUFDdkUsT0FBTyxnQkFBMkMsQ0FBQztBQUNyRCxDQUFDO0FBRU0sS0FBSyxVQUFVLG1CQUFtQixDQUFDLGFBQXFCLEVBQUUsU0FBaUIsRUFBRSxHQUFtQjtJQUNyRywwRkFBMEY7SUFDMUYsd0dBQXdHO0lBQ3hHLElBQUEsZUFBSyxFQUFDLDBDQUEwQyxhQUFhLGVBQWUsQ0FBQyxDQUFDO0lBQzlFLE1BQU0sR0FBRyxDQUFDLGVBQWUsQ0FBQyxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsYUFBYSxFQUFFLGFBQWEsRUFBRSxDQUFDLENBQUMsT0FBTyxFQUFFLENBQUM7QUFDOUYsQ0FBQztBQUxELGtEQUtDO0FBRUQ7Ozs7OztHQU1HO0FBQ0gsU0FBZ0IscUJBQXFCLENBQUMsV0FBbUQ7SUFDdkYsTUFBTSxxQkFBcUIsR0FBRztRQUM1Qix1Q0FBdUM7UUFDdkMsb0RBQW9EO1FBQ3BELDBEQUEwRDtRQUMxRCxpQ0FBaUM7S0FDbEMsQ0FBQztJQUVGLE9BQU8sV0FBVyxDQUFDLE1BQU0sS0FBSyxRQUFRO1dBQ2pDLHFCQUFxQixDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsV0FBVyxDQUFDLFlBQVksSUFBSSxFQUFFLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUN2RixDQUFDO0FBVkQsc0RBVUM7QUFFRDs7Ozs7Ozs7Ozs7R0FXRztBQUNJLEtBQUssVUFBVSxrQkFBa0IsQ0FDdEMsR0FBbUIsRUFDbkIsU0FBaUI7SUFFakIsTUFBTSxLQUFLLEdBQUcsTUFBTSxjQUFjLENBQUMsR0FBRyxFQUFFLFNBQVMsQ0FBQyxDQUFDO0lBQ25ELElBQUksQ0FBQyxLQUFLLEVBQUUsQ0FBQztRQUFDLE9BQU8sU0FBUyxDQUFDO0lBQUMsQ0FBQztJQUVqQyxNQUFNLE1BQU0sR0FBRyxLQUFLLENBQUMsV0FBVyxDQUFDO0lBQ2pDLElBQUksTUFBTSxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBQ3JCLE1BQU0sSUFBSSxLQUFLLENBQUMsbUJBQW1CLFNBQVMsMkVBQTJFLE1BQU0sRUFBRSxDQUFDLENBQUM7SUFDbkksQ0FBQztTQUFNLElBQUksTUFBTSxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBQzVCLE9BQU8sU0FBUyxDQUFDO0lBQ25CLENBQUM7SUFDRCxPQUFPLEtBQUssQ0FBQztBQUNmLENBQUM7QUFkRCxnREFjQztBQUVEOzs7Ozs7Ozs7O0dBVUc7QUFDSSxLQUFLLFVBQVUsa0JBQWtCLENBQ3RDLEdBQW1CLEVBQ25CLFNBQWlCO0lBRWpCLE1BQU0sS0FBSyxHQUFHLE1BQU0sY0FBYyxDQUFDLEdBQUcsRUFBRSxTQUFTLENBQUMsQ0FBQztJQUNuRCxJQUFJLENBQUMsS0FBSyxFQUFFLENBQUM7UUFBQyxPQUFPLFNBQVMsQ0FBQztJQUFDLENBQUM7SUFFakMsTUFBTSxNQUFNLEdBQUcsS0FBSyxDQUFDLFdBQVcsQ0FBQztJQUVqQyxJQUFJLE1BQU0sQ0FBQyxpQkFBaUIsRUFBRSxDQUFDO1FBQzdCLE1BQU0sSUFBSSxLQUFLLENBQUMsbUJBQW1CLFNBQVMsOEVBQThFLE1BQU0sRUFBRSxDQUFDLENBQUM7SUFDdEksQ0FBQztTQUFNLElBQUksQ0FBQyxNQUFNLENBQUMsZUFBZSxFQUFFLENBQUM7UUFDbkMsTUFBTSxJQUFJLEtBQUssQ0FBQyxtQkFBbUIsU0FBUyxzQkFBc0IsTUFBTSxFQUFFLENBQUMsQ0FBQztJQUM5RSxDQUFDO0lBRUQsT0FBTyxLQUFLLENBQUM7QUFDZixDQUFDO0FBaEJELGdEQWdCQztBQUVEOztHQUVHO0FBQ0ksS0FBSyxVQUFVLGNBQWMsQ0FBQyxHQUFtQixFQUFFLFNBQWlCO0lBQ3pFLElBQUEsZUFBSyxFQUFDLHdEQUF3RCxFQUFFLFNBQVMsQ0FBQyxDQUFDO0lBQzNFLE9BQU8sT0FBTyxDQUFDLEtBQUssSUFBSSxFQUFFO1FBQ3hCLE1BQU0sS0FBSyxHQUFHLE1BQU0sbUJBQW1CLENBQUMsTUFBTSxDQUFDLEdBQUcsRUFBRSxTQUFTLENBQUMsQ0FBQztRQUMvRCxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sRUFBRSxDQUFDO1lBQ2xCLElBQUEsZUFBSyxFQUFDLHlCQUF5QixFQUFFLFNBQVMsQ0FBQyxDQUFDO1lBQzVDLE9BQU8sSUFBSSxDQUFDO1FBQ2QsQ0FBQztRQUNELE1BQU0sTUFBTSxHQUFHLEtBQUssQ0FBQyxXQUFXLENBQUM7UUFDakMsSUFBSSxNQUFNLENBQUMsWUFBWSxFQUFFLENBQUM7WUFDeEIsSUFBQSxlQUFLLEVBQUMsc0VBQXNFLEVBQUUsU0FBUyxFQUFFLE1BQU0sQ0FBQyxDQUFDO1lBQ2pHLE9BQU8sU0FBUyxDQUFDO1FBQ25CLENBQUM7YUFBTSxJQUFJLE1BQU0sQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO1lBQ3JDLGlIQUFpSDtZQUNqSCxpSEFBaUg7WUFDakgsNEdBQTRHO1lBQzVHLDZHQUE2RztZQUM3RyxpSEFBaUg7WUFDakgsZ0RBQWdEO1lBQ2hELElBQUEsZUFBSyxFQUFDLG1GQUFtRixFQUFFLFNBQVMsRUFBRSxNQUFNLENBQUMsQ0FBQztRQUNoSCxDQUFDO1FBRUQsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDLENBQUMsQ0FBQztBQUNMLENBQUM7QUF4QkQsd0NBd0JDO0FBRUQ7O0dBRUc7QUFDSCxNQUFhLGtCQUFrQjtJQUN0QixNQUFNLENBQUMsWUFBWSxDQUFDLFFBQWtCO1FBQzNDLE9BQU8sSUFBSSxrQkFBa0IsQ0FBQyxRQUFRLENBQUMsVUFBVSxJQUFJLEVBQUUsQ0FBQyxDQUFDO0lBQzNELENBQUM7SUFFRCxZQUE2QixNQUF5QztRQUF6QyxXQUFNLEdBQU4sTUFBTSxDQUFtQztJQUN0RSxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDSSxTQUFTLENBQUMsT0FBMkM7UUFDMUQsT0FBTyxJQUFJLGVBQWUsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLE9BQU8sQ0FBQyxDQUFDO0lBQ25ELENBQUM7SUFFRDs7Ozs7OztPQU9HO0lBQ0ksY0FBYyxDQUFDLE9BQTJDLEVBQUUsY0FBc0M7UUFDdkcsT0FBTyxJQUFJLGVBQWUsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLE9BQU8sRUFBRSxjQUFjLENBQUMsQ0FBQztJQUNuRSxDQUFDO0NBQ0Y7QUE3QkQsZ0RBNkJDO0FBRUQ7O0dBRUc7QUFDSCxNQUFhLGVBQWU7SUFJMUIsWUFDbUIsWUFBK0MsRUFDaEUsT0FBMkMsRUFDM0MsaUJBQXlDLEVBQUU7UUFGMUIsaUJBQVksR0FBWixZQUFZLENBQW1DO1FBSmxELFdBQU0sR0FBMkIsRUFBRSxDQUFDO1FBQ3BDLGtCQUFhLEdBQStCLEVBQUUsQ0FBQztRQU83RCxNQUFNLGVBQWUsR0FBRyxJQUFJLEtBQUssRUFBVSxDQUFDO1FBRTVDLEtBQUssTUFBTSxDQUFDLEdBQUcsRUFBRSxXQUFXLENBQUMsSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDO1lBQ25FLDRFQUE0RTtZQUM1RSw4QkFBOEI7WUFDOUIsRUFBRTtZQUNGLHVGQUF1RjtZQUN2RixNQUFNLFlBQVksR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDbEMsSUFBSSxZQUFZLEtBQUssU0FBUyxFQUFFLENBQUM7Z0JBQy9CLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsWUFBWSxDQUFDO2dCQUNoQyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxFQUFFLFlBQVksRUFBRSxHQUFHLEVBQUUsY0FBYyxFQUFFLE9BQU8sQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLENBQUM7Z0JBQzdFLFNBQVM7WUFDWCxDQUFDO1lBRUQsSUFBSSxHQUFHLElBQUksY0FBYyxFQUFFLENBQUM7Z0JBQzFCLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsY0FBYyxDQUFDLEdBQUcsQ0FBQyxDQUFDO2dCQUN2QyxJQUFJLENBQUMsYUFBYSxDQUFDLElBQUksQ0FBQyxFQUFFLFlBQVksRUFBRSxHQUFHLEVBQUUsZ0JBQWdCLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztnQkFDdkUsU0FBUztZQUNYLENBQUM7WUFFRCxJQUFJLFdBQVcsQ0FBQyxPQUFPLEtBQUssU0FBUyxFQUFFLENBQUM7Z0JBQ3RDLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsV0FBVyxDQUFDLE9BQU8sQ0FBQztnQkFDdkMsU0FBUztZQUNYLENBQUM7WUFFRCxRQUFRO1lBQ1IsZUFBZSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztRQUM1QixDQUFDO1FBRUQsSUFBSSxlQUFlLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRSxDQUFDO1lBQy9CLE1BQU0sSUFBSSxLQUFLLENBQUMsZ0VBQWdFLGVBQWUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBQ2hILENBQUM7UUFFRCx1RUFBdUU7UUFDdkUsMEVBQTBFO1FBQzFFLE1BQU07UUFDTixNQUFNLFlBQVksR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUMsQ0FBZ0IsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxHQUFHLENBQUMsS0FBSyxTQUFTLENBQUM7UUFDdkYsTUFBTSxRQUFRLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQWdCLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUM7UUFDeEQsS0FBSyxNQUFNLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxJQUFJLE1BQU0sQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLENBQUMsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDO1lBQ3pGLElBQUksQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEdBQUcsS0FBTSxDQUFDO1lBQzFCLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLEVBQUUsWUFBWSxFQUFFLEdBQUcsRUFBRSxjQUFjLEVBQUUsS0FBSyxFQUFFLENBQUMsQ0FBQztRQUN4RSxDQUFDO0lBQ0gsQ0FBQztJQUVEOztPQUVHO0lBQ0ksVUFBVSxDQUFDLGFBQXFDO1FBQ3JELDRFQUE0RTtRQUM1RSx1RUFBdUU7UUFDdkUscUZBQXFGO1FBQ3JGLElBQUksTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsdUJBQXVCLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxXQUFXLEVBQUUsUUFBUSxDQUFDLCtCQUFzQixDQUFDLENBQUMsRUFBRSxDQUFDO1lBQy9JLE9BQU8sS0FBSyxDQUFDO1FBQ2YsQ0FBQztRQUVELDRCQUE0QjtRQUM1Qix1REFBdUQ7UUFDdkQsSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLGFBQWEsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxLQUFLLEtBQUssSUFBSSxDQUFDLE1BQU0sQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUM7WUFDOUcsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDO1FBRUQsNENBQTRDO1FBQzVDLElBQUksTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDLEdBQUcsSUFBSSxhQUFhLENBQUMsQ0FBQyxFQUFFLENBQUM7WUFDbEUsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDO1FBRUQsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0NBQ0Y7QUE3RUQsMENBNkVDIiwic291cmNlc0NvbnRlbnQiOlsiLy8gVGVtcG9yYXJpbHkgcHVsbCB0aGlzIGluIHRvIGF2b2lkIGNyZWF0aW5nIGNvbmZsaWN0cyB3aXRoIHRoZSBzZGtzIGluIHRoaXMgcGFja2FnZVxuaW1wb3J0IHsgRGVzY3JpYmVDaGFuZ2VTZXRPdXRwdXQgfSBmcm9tICdAYXdzLWNkay9jbG91ZGZvcm1hdGlvbi1kaWZmJztcbmltcG9ydCB7IFNTTVBBUkFNX05PX0lOVkFMSURBVEUgfSBmcm9tICdAYXdzLWNkay9jeC1hcGknO1xuaW1wb3J0ICogYXMgY3hhcGkgZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCB7IENsb3VkRm9ybWF0aW9uIH0gZnJvbSAnYXdzLXNkayc7XG5pbXBvcnQgeyBBc3NldE1hbmlmZXN0LCBGaWxlTWFuaWZlc3RFbnRyeSB9IGZyb20gJ2Nkay1hc3NldHMnO1xuaW1wb3J0IHsgU3RhY2tTdGF0dXMgfSBmcm9tICcuL2Nsb3VkZm9ybWF0aW9uL3N0YWNrLXN0YXR1cyc7XG5pbXBvcnQgeyBtYWtlQm9keVBhcmFtZXRlciwgVGVtcGxhdGVCb2R5UGFyYW1ldGVyIH0gZnJvbSAnLi90ZW1wbGF0ZS1ib2R5LXBhcmFtZXRlcic7XG5pbXBvcnQgeyBkZWJ1ZyB9IGZyb20gJy4uLy4uL2xvZ2dpbmcnO1xuaW1wb3J0IHsgZGVzZXJpYWxpemVTdHJ1Y3R1cmUgfSBmcm9tICcuLi8uLi9zZXJpYWxpemUnO1xuaW1wb3J0IHsgQXNzZXRNYW5pZmVzdEJ1aWxkZXIgfSBmcm9tICcuLi8uLi91dGlsL2Fzc2V0LW1hbmlmZXN0LWJ1aWxkZXInO1xuaW1wb3J0IHsgU2RrUHJvdmlkZXIgfSBmcm9tICcuLi9hd3MtYXV0aCc7XG5pbXBvcnQgeyBEZXBsb3ltZW50cyB9IGZyb20gJy4uL2RlcGxveW1lbnRzJztcblxuZXhwb3J0IHR5cGUgVGVtcGxhdGUgPSB7XG4gIFBhcmFtZXRlcnM/OiBSZWNvcmQ8c3RyaW5nLCBUZW1wbGF0ZVBhcmFtZXRlcj47XG4gIFtrZXk6IHN0cmluZ106IGFueTtcbn07XG5cbmludGVyZmFjZSBUZW1wbGF0ZVBhcmFtZXRlciB7XG4gIFR5cGU6IHN0cmluZztcbiAgRGVmYXVsdD86IGFueTtcbiAgRGVzY3JpcHRpb24/OiBzdHJpbmc7XG4gIFtrZXk6IHN0cmluZ106IGFueTtcbn1cblxuZXhwb3J0IHR5cGUgUmVzb3VyY2VJZGVudGlmaWVyUHJvcGVydGllcyA9IENsb3VkRm9ybWF0aW9uLlJlc291cmNlSWRlbnRpZmllclByb3BlcnRpZXM7XG5leHBvcnQgdHlwZSBSZXNvdXJjZUlkZW50aWZpZXJTdW1tYXJpZXMgPSBDbG91ZEZvcm1hdGlvbi5SZXNvdXJjZUlkZW50aWZpZXJTdW1tYXJpZXM7XG5leHBvcnQgdHlwZSBSZXNvdXJjZXNUb0ltcG9ydCA9IENsb3VkRm9ybWF0aW9uLlJlc291cmNlc1RvSW1wb3J0O1xuXG4vKipcbiAqIFJlcHJlc2VudHMgYW4gKGV4aXN0aW5nKSBTdGFjayBpbiBDbG91ZEZvcm1hdGlvblxuICpcbiAqIEJ1bmRsZSBhbmQgY2FjaGUgc29tZSBpbmZvcm1hdGlvbiB0aGF0IHdlIG5lZWQgZHVyaW5nIGRlcGxveW1lbnQgKHNvIHdlIGRvbid0IGhhdmUgdG8gbWFrZVxuICogcmVwZWF0ZWQgY2FsbHMgdG8gQ2xvdWRGb3JtYXRpb24pLlxuICovXG5leHBvcnQgY2xhc3MgQ2xvdWRGb3JtYXRpb25TdGFjayB7XG4gIHB1YmxpYyBzdGF0aWMgYXN5bmMgbG9va3VwKFxuICAgIGNmbjogQ2xvdWRGb3JtYXRpb24sIHN0YWNrTmFtZTogc3RyaW5nLCByZXRyaWV2ZVByb2Nlc3NlZFRlbXBsYXRlOiBib29sZWFuID0gZmFsc2UsXG4gICk6IFByb21pc2U8Q2xvdWRGb3JtYXRpb25TdGFjaz4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNmbi5kZXNjcmliZVN0YWNrcyh7IFN0YWNrTmFtZTogc3RhY2tOYW1lIH0pLnByb21pc2UoKTtcbiAgICAgIHJldHVybiBuZXcgQ2xvdWRGb3JtYXRpb25TdGFjayhjZm4sIHN0YWNrTmFtZSwgcmVzcG9uc2UuU3RhY2tzICYmIHJlc3BvbnNlLlN0YWNrc1swXSwgcmV0cmlldmVQcm9jZXNzZWRUZW1wbGF0ZSk7XG4gICAgfSBjYXRjaCAoZTogYW55KSB7XG4gICAgICBpZiAoZS5jb2RlID09PSAnVmFsaWRhdGlvbkVycm9yJyAmJiBlLm1lc3NhZ2UgPT09IGBTdGFjayB3aXRoIGlkICR7c3RhY2tOYW1lfSBkb2VzIG5vdCBleGlzdGApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDbG91ZEZvcm1hdGlvblN0YWNrKGNmbiwgc3RhY2tOYW1lLCB1bmRlZmluZWQpO1xuICAgICAgfVxuICAgICAgdGhyb3cgZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgY29weSBvZiB0aGUgZ2l2ZW4gc3RhY2sgdGhhdCBkb2VzIG5vdCBleGlzdFxuICAgKlxuICAgKiBJdCdzIGEgbGl0dGxlIHNpbGx5IHRoYXQgaXQgbmVlZHMgYXJndW1lbnRzIHRvIGRvIHRoYXQsIGJ1dCB0aGVyZSB3ZSBnby5cbiAgICovXG4gIHB1YmxpYyBzdGF0aWMgZG9lc05vdEV4aXN0KGNmbjogQ2xvdWRGb3JtYXRpb24sIHN0YWNrTmFtZTogc3RyaW5nKSB7XG4gICAgcmV0dXJuIG5ldyBDbG91ZEZvcm1hdGlvblN0YWNrKGNmbiwgc3RhY2tOYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGcm9tIHN0YXRpYyBpbmZvcm1hdGlvbiAoZm9yIHRlc3RpbmcpXG4gICAqL1xuICBwdWJsaWMgc3RhdGljIGZyb21TdGF0aWNJbmZvcm1hdGlvbihjZm46IENsb3VkRm9ybWF0aW9uLCBzdGFja05hbWU6IHN0cmluZywgc3RhY2s6IENsb3VkRm9ybWF0aW9uLlN0YWNrKSB7XG4gICAgcmV0dXJuIG5ldyBDbG91ZEZvcm1hdGlvblN0YWNrKGNmbiwgc3RhY2tOYW1lLCBzdGFjayk7XG4gIH1cblxuICBwcml2YXRlIF90ZW1wbGF0ZTogYW55O1xuXG4gIHByb3RlY3RlZCBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHJlYWRvbmx5IGNmbjogQ2xvdWRGb3JtYXRpb24sIHB1YmxpYyByZWFkb25seSBzdGFja05hbWU6IHN0cmluZywgcHJpdmF0ZSByZWFkb25seSBzdGFjaz86IENsb3VkRm9ybWF0aW9uLlN0YWNrLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgcmV0cmlldmVQcm9jZXNzZWRUZW1wbGF0ZTogYm9vbGVhbiA9IGZhbHNlLFxuICApIHtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSB0aGUgc3RhY2sncyBkZXBsb3llZCB0ZW1wbGF0ZVxuICAgKlxuICAgKiBDYWNoZWQsIHNvIHdpbGwgb25seSBiZSByZXRyaWV2ZWQgb25jZS4gV2lsbCByZXR1cm4gYW4gZW1wdHlcbiAgICogc3RydWN0dXJlIGlmIHRoZSBzdGFjayBkb2VzIG5vdCBleGlzdC5cbiAgICovXG4gIHB1YmxpYyBhc3luYyB0ZW1wbGF0ZSgpOiBQcm9taXNlPFRlbXBsYXRlPiB7XG4gICAgaWYgKCF0aGlzLmV4aXN0cykge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICAgIGlmICh0aGlzLl90ZW1wbGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuY2ZuLmdldFRlbXBsYXRlKHtcbiAgICAgICAgU3RhY2tOYW1lOiB0aGlzLnN0YWNrTmFtZSxcbiAgICAgICAgVGVtcGxhdGVTdGFnZTogdGhpcy5yZXRyaWV2ZVByb2Nlc3NlZFRlbXBsYXRlID8gJ1Byb2Nlc3NlZCcgOiAnT3JpZ2luYWwnLFxuICAgICAgfSkucHJvbWlzZSgpO1xuICAgICAgdGhpcy5fdGVtcGxhdGUgPSAocmVzcG9uc2UuVGVtcGxhdGVCb2R5ICYmIGRlc2VyaWFsaXplU3RydWN0dXJlKHJlc3BvbnNlLlRlbXBsYXRlQm9keSkpIHx8IHt9O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fdGVtcGxhdGU7XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciB0aGUgc3RhY2sgZXhpc3RzXG4gICAqL1xuICBwdWJsaWMgZ2V0IGV4aXN0cygpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFjayAhPT0gdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBzdGFjaydzIElEXG4gICAqXG4gICAqIFRocm93cyBpZiB0aGUgc3RhY2sgZG9lc24ndCBleGlzdC5cbiAgICovXG4gIHB1YmxpYyBnZXQgc3RhY2tJZCgpIHtcbiAgICB0aGlzLmFzc2VydEV4aXN0cygpO1xuICAgIHJldHVybiB0aGlzLnN0YWNrIS5TdGFja0lkITtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgc3RhY2sncyBjdXJyZW50IG91dHB1dHNcbiAgICpcbiAgICogRW1wdHkgb2JqZWN0IGlmIHRoZSBzdGFjayBkb2Vzbid0IGV4aXN0XG4gICAqL1xuICBwdWJsaWMgZ2V0IG91dHB1dHMoKTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB7XG4gICAgaWYgKCF0aGlzLmV4aXN0cykgeyByZXR1cm4ge307IH1cbiAgICBjb25zdCByZXN1bHQ6IHsgW25hbWU6IHN0cmluZ106IHN0cmluZyB9ID0ge307XG4gICAgKHRoaXMuc3RhY2shLk91dHB1dHMgfHwgW10pLmZvckVhY2gob3V0cHV0ID0+IHtcbiAgICAgIHJlc3VsdFtvdXRwdXQuT3V0cHV0S2V5IV0gPSBvdXRwdXQuT3V0cHV0VmFsdWUhO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIHN0YWNrJ3Mgc3RhdHVzXG4gICAqXG4gICAqIFNwZWNpYWwgc3RhdHVzIE5PVF9GT1VORCBpZiB0aGUgc3RhY2sgZG9lcyBub3QgZXhpc3QuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHN0YWNrU3RhdHVzKCk6IFN0YWNrU3RhdHVzIHtcbiAgICBpZiAoIXRoaXMuZXhpc3RzKSB7XG4gICAgICByZXR1cm4gbmV3IFN0YWNrU3RhdHVzKCdOT1RfRk9VTkQnLCAnU3RhY2sgbm90IGZvdW5kIGR1cmluZyBsb29rdXAnKTtcbiAgICB9XG4gICAgcmV0dXJuIFN0YWNrU3RhdHVzLmZyb21TdGFja0Rlc2NyaXB0aW9uKHRoaXMuc3RhY2shKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgc3RhY2sncyBjdXJyZW50IHRhZ3NcbiAgICpcbiAgICogRW1wdHkgbGlzdCBpZiB0aGUgc3RhY2sgZG9lcyBub3QgZXhpc3RcbiAgICovXG4gIHB1YmxpYyBnZXQgdGFncygpOiBDbG91ZEZvcm1hdGlvbi5UYWdzIHtcbiAgICByZXR1cm4gdGhpcy5zdGFjaz8uVGFncyB8fCBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTTlMgVG9waWMgQVJOcyB0aGF0IHdpbGwgcmVjZWl2ZSBzdGFjayBldmVudHMuXG4gICAqXG4gICAqIEVtcHR5IGxpc3QgaWYgdGhlIHN0YWNrIGRvZXMgbm90IGV4aXN0XG4gICAqL1xuICBwdWJsaWMgZ2V0IG5vdGlmaWNhdGlvbkFybnMoKTogQ2xvdWRGb3JtYXRpb24uTm90aWZpY2F0aW9uQVJOcyB7XG4gICAgcmV0dXJuIHRoaXMuc3RhY2s/Lk5vdGlmaWNhdGlvbkFSTnMgPz8gW107XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBuYW1lcyBvZiBhbGwgY3VycmVudCBwYXJhbWV0ZXJzIHRvIHRoZSBzdGFja1xuICAgKlxuICAgKiBFbXB0eSBsaXN0IGlmIHRoZSBzdGFjayBkb2VzIG5vdCBleGlzdC5cbiAgICovXG4gIHB1YmxpYyBnZXQgcGFyYW1ldGVyTmFtZXMoKTogc3RyaW5nW10ge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnBhcmFtZXRlcnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybiB0aGUgbmFtZXMgYW5kIHZhbHVlcyBvZiBhbGwgY3VycmVudCBwYXJhbWV0ZXJzIHRvIHRoZSBzdGFja1xuICAgKlxuICAgKiBFbXB0eSBvYmplY3QgaWYgdGhlIHN0YWNrIGRvZXMgbm90IGV4aXN0LlxuICAgKi9cbiAgcHVibGljIGdldCBwYXJhbWV0ZXJzKCk6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4ge1xuICAgIGlmICghdGhpcy5leGlzdHMpIHsgcmV0dXJuIHt9OyB9XG4gICAgY29uc3QgcmV0OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge307XG4gICAgZm9yIChjb25zdCBwYXJhbSBvZiB0aGlzLnN0YWNrIS5QYXJhbWV0ZXJzID8/IFtdKSB7XG4gICAgICByZXRbcGFyYW0uUGFyYW1ldGVyS2V5IV0gPSBwYXJhbS5SZXNvbHZlZFZhbHVlID8/IHBhcmFtLlBhcmFtZXRlclZhbHVlITtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHRlcm1pbmF0aW9uIHByb3RlY3Rpb24gb2YgdGhlIHN0YWNrXG4gICAqL1xuICBwdWJsaWMgZ2V0IHRlcm1pbmF0aW9uUHJvdGVjdGlvbigpOiBib29sZWFuIHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5zdGFjaz8uRW5hYmxlVGVybWluYXRpb25Qcm90ZWN0aW9uO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3NlcnRFeGlzdHMoKSB7XG4gICAgaWYgKCF0aGlzLmV4aXN0cykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBObyBzdGFjayBuYW1lZCAnJHt0aGlzLnN0YWNrTmFtZX0nYCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRGVzY3JpYmUgYSBjaGFuZ2VzZXQgaW4gQ2xvdWRGb3JtYXRpb24sIHJlZ2FyZGxlc3Mgb2YgaXRzIGN1cnJlbnQgc3RhdGUuXG4gKlxuICogQHBhcmFtIGNmbiAgICAgICAgICAgYSBDbG91ZEZvcm1hdGlvbiBjbGllbnRcbiAqIEBwYXJhbSBzdGFja05hbWUgICAgIHRoZSBuYW1lIG9mIHRoZSBTdGFjayB0aGUgQ2hhbmdlU2V0IGJlbG9uZ3MgdG9cbiAqIEBwYXJhbSBjaGFuZ2VTZXROYW1lIHRoZSBuYW1lIG9mIHRoZSBDaGFuZ2VTZXRcbiAqIEBwYXJhbSBmZXRjaEFsbCAgICAgIGlmIHRydWUsIGZldGNoZXMgYWxsIHBhZ2VzIG9mIHRoZSBjaGFuZ2Ugc2V0IGRlc2NyaXB0aW9uLlxuICpcbiAqIEByZXR1cm5zICAgICAgIENsb3VkRm9ybWF0aW9uIGluZm9ybWF0aW9uIGFib3V0IHRoZSBDaGFuZ2VTZXRcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZGVzY3JpYmVDaGFuZ2VTZXQoXG4gIGNmbjogQ2xvdWRGb3JtYXRpb24sXG4gIHN0YWNrTmFtZTogc3RyaW5nLFxuICBjaGFuZ2VTZXROYW1lOiBzdHJpbmcsXG4gIHsgZmV0Y2hBbGwgfTogeyBmZXRjaEFsbDogYm9vbGVhbiB9LFxuKTogUHJvbWlzZTxDbG91ZEZvcm1hdGlvbi5EZXNjcmliZUNoYW5nZVNldE91dHB1dD4ge1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGNmbi5kZXNjcmliZUNoYW5nZVNldCh7IFN0YWNrTmFtZTogc3RhY2tOYW1lLCBDaGFuZ2VTZXROYW1lOiBjaGFuZ2VTZXROYW1lIH0pLnByb21pc2UoKTtcblxuICAvLyBJZiBmZXRjaEFsbCBpcyB0cnVlLCB0cmF2ZXJzZSBhbGwgcGFnZXMgZnJvbSB0aGUgY2hhbmdlIHNldCBkZXNjcmlwdGlvbi5cbiAgd2hpbGUgKGZldGNoQWxsICYmIHJlc3BvbnNlLk5leHRUb2tlbiAhPSBudWxsKSB7XG4gICAgY29uc3QgbmV4dFBhZ2UgPSBhd2FpdCBjZm4uZGVzY3JpYmVDaGFuZ2VTZXQoe1xuICAgICAgU3RhY2tOYW1lOiBzdGFja05hbWUsXG4gICAgICBDaGFuZ2VTZXROYW1lOiByZXNwb25zZS5DaGFuZ2VTZXRJZCA/PyBjaGFuZ2VTZXROYW1lLFxuICAgICAgTmV4dFRva2VuOiByZXNwb25zZS5OZXh0VG9rZW4sXG4gICAgfSkucHJvbWlzZSgpO1xuXG4gICAgLy8gQ29uc29saWRhdGUgdGhlIGNoYW5nZXNcbiAgICBpZiAobmV4dFBhZ2UuQ2hhbmdlcyAhPSBudWxsKSB7XG4gICAgICByZXNwb25zZS5DaGFuZ2VzID0gcmVzcG9uc2UuQ2hhbmdlcyAhPSBudWxsXG4gICAgICAgID8gcmVzcG9uc2UuQ2hhbmdlcy5jb25jYXQobmV4dFBhZ2UuQ2hhbmdlcylcbiAgICAgICAgOiBuZXh0UGFnZS5DaGFuZ2VzO1xuICAgIH1cblxuICAgIC8vIEZvcndhcmQgdGhlIG5ldyBOZXh0VG9rZW5cbiAgICByZXNwb25zZS5OZXh0VG9rZW4gPSBuZXh0UGFnZS5OZXh0VG9rZW47XG4gIH1cblxuICByZXR1cm4gcmVzcG9uc2U7XG59XG5cbi8qKlxuICogV2FpdHMgZm9yIGEgZnVuY3Rpb24gdG8gcmV0dXJuIG5vbi0rdW5kZWZpbmVkKyBiZWZvcmUgcmV0dXJuaW5nLlxuICpcbiAqIEBwYXJhbSB2YWx1ZVByb3ZpZGVyIGEgZnVuY3Rpb24gdGhhdCB3aWxsIHJldHVybiBhIHZhbHVlIHRoYXQgaXMgbm90ICt1bmRlZmluZWQrIG9uY2UgdGhlIHdhaXQgc2hvdWxkIGJlIG92ZXJcbiAqIEBwYXJhbSB0aW1lb3V0ICAgICB0aGUgdGltZSB0byB3YWl0IGJldHdlZW4gdHdvIGNhbGxzIHRvICt2YWx1ZVByb3ZpZGVyK1xuICpcbiAqIEByZXR1cm5zICAgICAgIHRoZSB2YWx1ZSB0aGF0IHdhcyByZXR1cm5lZCBieSArdmFsdWVQcm92aWRlcitcbiAqL1xuYXN5bmMgZnVuY3Rpb24gd2FpdEZvcjxUPih2YWx1ZVByb3ZpZGVyOiAoKSA9PiBQcm9taXNlPFQgfCBudWxsIHwgdW5kZWZpbmVkPiwgdGltZW91dDogbnVtYmVyID0gNTAwMCk6IFByb21pc2U8VCB8IHVuZGVmaW5lZD4ge1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHZhbHVlUHJvdmlkZXIoKTtcbiAgICBpZiAocmVzdWx0ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAocmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGF3YWl0IG5ldyBQcm9taXNlKGNiID0+IHNldFRpbWVvdXQoY2IsIHRpbWVvdXQpKTtcbiAgfVxufVxuXG4vKipcbiAqIFdhaXRzIGZvciBhIENoYW5nZVNldCB0byBiZSBhdmFpbGFibGUgZm9yIHRyaWdnZXJpbmcgYSBTdGFja1VwZGF0ZS5cbiAqXG4gKiBXaWxsIHJldHVybiBhIGNoYW5nZXNldCB0aGF0IGlzIGVpdGhlciByZWFkeSB0byBiZSBleGVjdXRlZCBvciBoYXMgbm8gY2hhbmdlcy5cbiAqIFdpbGwgdGhyb3cgaW4gb3RoZXIgY2FzZXMuXG4gKlxuICogQHBhcmFtIGNmbiAgICAgICAgICAgYSBDbG91ZEZvcm1hdGlvbiBjbGllbnRcbiAqIEBwYXJhbSBzdGFja05hbWUgICAgIHRoZSBuYW1lIG9mIHRoZSBTdGFjayB0aGF0IHRoZSBDaGFuZ2VTZXQgYmVsb25ncyB0b1xuICogQHBhcmFtIGNoYW5nZVNldE5hbWUgdGhlIG5hbWUgb2YgdGhlIENoYW5nZVNldFxuICogQHBhcmFtIGZldGNoQWxsICAgICAgaWYgdHJ1ZSwgZmV0Y2hlcyBhbGwgcGFnZXMgb2YgdGhlIENoYW5nZVNldCBiZWZvcmUgcmV0dXJuaW5nLlxuICpcbiAqIEByZXR1cm5zICAgICAgIHRoZSBDbG91ZEZvcm1hdGlvbiBkZXNjcmlwdGlvbiBvZiB0aGUgQ2hhbmdlU2V0XG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBtYXgtbGVuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gd2FpdEZvckNoYW5nZVNldChcbiAgY2ZuOiBDbG91ZEZvcm1hdGlvbixcbiAgc3RhY2tOYW1lOiBzdHJpbmcsXG4gIGNoYW5nZVNldE5hbWU6IHN0cmluZyxcbiAgeyBmZXRjaEFsbCB9OiB7IGZldGNoQWxsOiBib29sZWFuIH0sXG4pOiBQcm9taXNlPENsb3VkRm9ybWF0aW9uLkRlc2NyaWJlQ2hhbmdlU2V0T3V0cHV0PiB7XG4gIGRlYnVnKCdXYWl0aW5nIGZvciBjaGFuZ2VzZXQgJXMgb24gc3RhY2sgJXMgdG8gZmluaXNoIGNyZWF0aW5nLi4uJywgY2hhbmdlU2V0TmFtZSwgc3RhY2tOYW1lKTtcbiAgY29uc3QgcmV0ID0gYXdhaXQgd2FpdEZvcihhc3luYyAoKSA9PiB7XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSBhd2FpdCBkZXNjcmliZUNoYW5nZVNldChjZm4sIHN0YWNrTmFtZSwgY2hhbmdlU2V0TmFtZSwgeyBmZXRjaEFsbCB9KTtcbiAgICAvLyBUaGUgZm9sbG93aW5nIGRvZXNuJ3QgdXNlIGEgc3dpdGNoIGJlY2F1c2UgdHNjIHdpbGwgbm90IGFsbG93IGZhbGwtdGhyb3VnaCwgVU5MRVNTIGl0IGlzIGFsbG93c1xuICAgIC8vIEVWRVJZV0hFUkUgdGhhdCB1c2VzIHRoaXMgbGlicmFyeSBkaXJlY3RseSBvciBpbmRpcmVjdGx5LCB3aGljaCBpcyB1bmRlc2lyYWJsZS5cbiAgICBpZiAoZGVzY3JpcHRpb24uU3RhdHVzID09PSAnQ1JFQVRFX1BFTkRJTkcnIHx8IGRlc2NyaXB0aW9uLlN0YXR1cyA9PT0gJ0NSRUFURV9JTl9QUk9HUkVTUycpIHtcbiAgICAgIGRlYnVnKCdDaGFuZ2VzZXQgJXMgb24gc3RhY2sgJXMgaXMgc3RpbGwgY3JlYXRpbmcnLCBjaGFuZ2VTZXROYW1lLCBzdGFja05hbWUpO1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoZGVzY3JpcHRpb24uU3RhdHVzID09PSAnQ1JFQVRFX0NPTVBMRVRFJyB8fCBjaGFuZ2VTZXRIYXNOb0NoYW5nZXMoZGVzY3JpcHRpb24pKSB7XG4gICAgICByZXR1cm4gZGVzY3JpcHRpb247XG4gICAgfVxuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgQ2hhbmdlU2V0ICR7Y2hhbmdlU2V0TmFtZX0gb24gJHtzdGFja05hbWV9OiAke2Rlc2NyaXB0aW9uLlN0YXR1cyB8fCAnTk9fU1RBVFVTJ30sICR7ZGVzY3JpcHRpb24uU3RhdHVzUmVhc29uIHx8ICdubyByZWFzb24gcHJvdmlkZWQnfWApO1xuICB9KTtcblxuICBpZiAoIXJldCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2hhbmdlIHNldCB0b29rIHRvbyBsb25nIHRvIGJlIGNyZWF0ZWQ7IGFib3J0aW5nJyk7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5leHBvcnQgdHlwZSBQcmVwYXJlQ2hhbmdlU2V0T3B0aW9ucyA9IHtcbiAgc3RhY2s6IGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdDtcbiAgZGVwbG95bWVudHM6IERlcGxveW1lbnRzO1xuICB1dWlkOiBzdHJpbmc7XG4gIHdpbGxFeGVjdXRlOiBib29sZWFuO1xuICBzZGtQcm92aWRlcjogU2RrUHJvdmlkZXI7XG4gIHN0cmVhbTogTm9kZUpTLldyaXRhYmxlU3RyZWFtO1xuICBwYXJhbWV0ZXJzOiB7IFtuYW1lOiBzdHJpbmddOiBzdHJpbmcgfCB1bmRlZmluZWQgfTtcbiAgcmVzb3VyY2VzVG9JbXBvcnQ/OiBSZXNvdXJjZXNUb0ltcG9ydDtcbn1cblxuZXhwb3J0IHR5cGUgQ3JlYXRlQ2hhbmdlU2V0T3B0aW9ucyA9IHtcbiAgY2ZuOiBDbG91ZEZvcm1hdGlvbjtcbiAgY2hhbmdlU2V0TmFtZTogc3RyaW5nO1xuICB3aWxsRXhlY3V0ZTogYm9vbGVhbjtcbiAgZXhpc3RzOiBib29sZWFuO1xuICB1dWlkOiBzdHJpbmc7XG4gIHN0YWNrOiBjeGFwaS5DbG91ZEZvcm1hdGlvblN0YWNrQXJ0aWZhY3Q7XG4gIGJvZHlQYXJhbWV0ZXI6IFRlbXBsYXRlQm9keVBhcmFtZXRlcjtcbiAgcGFyYW1ldGVyczogeyBbbmFtZTogc3RyaW5nXTogc3RyaW5nIHwgdW5kZWZpbmVkIH07XG4gIHJlc291cmNlc1RvSW1wb3J0PzogUmVzb3VyY2VzVG9JbXBvcnQ7XG4gIHJvbGU/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgY2hhbmdlc2V0IGZvciBhIGRpZmYgb3BlcmF0aW9uXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBjcmVhdGVEaWZmQ2hhbmdlU2V0KG9wdGlvbnM6IFByZXBhcmVDaGFuZ2VTZXRPcHRpb25zKTogUHJvbWlzZTxEZXNjcmliZUNoYW5nZVNldE91dHB1dCB8IHVuZGVmaW5lZD4ge1xuICAvLyBgb3B0aW9ucy5zdGFja2AgaGFzIGJlZW4gbW9kaWZpZWQgdG8gaW5jbHVkZSBhbnkgbmVzdGVkIHN0YWNrIHRlbXBsYXRlcyBkaXJlY3RseSBpbmxpbmUgd2l0aCBpdHMgb3duIHRlbXBsYXRlLCB1bmRlciBhIHNwZWNpYWwgYE5lc3RlZFRlbXBsYXRlYCBwcm9wZXJ0eS5cbiAgLy8gVGh1cyB0aGUgcGFyZW50IHRlbXBsYXRlJ3MgUmVzb3VyY2VzIHNlY3Rpb24gY29udGFpbnMgdGhlIG5lc3RlZCB0ZW1wbGF0ZSdzIENESyBtZXRhZGF0YSBjaGVjaywgd2hpY2ggdXNlcyBGbjo6RXF1YWxzLlxuICAvLyBUaGlzIGNhdXNlcyBDcmVhdGVDaGFuZ2VTZXQgdG8gZmFpbCB3aXRoIGBUZW1wbGF0ZSBFcnJvcjogRm46OkVxdWFscyBjYW5ub3QgYmUgcGFydGlhbGx5IGNvbGxhcHNlZGAuXG4gIGZvciAoY29uc3QgcmVzb3VyY2Ugb2YgT2JqZWN0LnZhbHVlcygob3B0aW9ucy5zdGFjay50ZW1wbGF0ZS5SZXNvdXJjZXMgPz8ge30pKSkge1xuICAgIGlmICgocmVzb3VyY2UgYXMgYW55KS5UeXBlID09PSAnQVdTOjpDbG91ZEZvcm1hdGlvbjo6U3RhY2snKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgZGVidWcoJ1RoaXMgc3RhY2sgY29udGFpbnMgb25lIG9yIG1vcmUgbmVzdGVkIHN0YWNrcywgZmFsbGluZyBiYWNrIHRvIHRlbXBsYXRlLW9ubHkgZGlmZi4uLicpO1xuXG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1cGxvYWRCb2R5UGFyYW1ldGVyQW5kQ3JlYXRlQ2hhbmdlU2V0KG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIFJldHVybnMgYWxsIGZpbGUgZW50cmllcyBmcm9tIGFuIEFzc2V0TWFuaWZlc3RBcnRpZmFjdCB0aGF0IGxvb2sgbGlrZSB0ZW1wbGF0ZXMuXG4gKlxuICogVGhpcyBpcyB1c2VkIGluIHRoZSBgdXBsb2FkQm9keVBhcmFtZXRlckFuZENyZWF0ZUNoYW5nZVNldGAgZnVuY3Rpb24gdG8gZmluZFxuICogYWxsIHRlbXBsYXRlIGFzc2V0IGZpbGVzIHRvIGJ1aWxkIGFuZCBwdWJsaXNoLlxuICpcbiAqIFJldHVybnMgYSB0dXBsZSBvZiBbQXNzZXRNYW5pZmVzdCwgRmlsZU1hbmlmZXN0RW50cnlbXV1cbiAqL1xuZnVuY3Rpb24gdGVtcGxhdGVzRnJvbUFzc2V0TWFuaWZlc3RBcnRpZmFjdChhcnRpZmFjdDogY3hhcGkuQXNzZXRNYW5pZmVzdEFydGlmYWN0KTogW0Fzc2V0TWFuaWZlc3QsIEZpbGVNYW5pZmVzdEVudHJ5W11dIHtcbiAgY29uc3QgYXNzZXRzOiAoRmlsZU1hbmlmZXN0RW50cnkpW10gPSBbXTtcbiAgY29uc3QgZmlsZU5hbWUgPSBhcnRpZmFjdC5maWxlO1xuICBjb25zdCBhc3NldE1hbmlmZXN0ID0gQXNzZXRNYW5pZmVzdC5mcm9tRmlsZShmaWxlTmFtZSk7XG5cbiAgYXNzZXRNYW5pZmVzdC5lbnRyaWVzLmZvckVhY2goZW50cnkgPT4ge1xuICAgIGlmIChlbnRyeS50eXBlID09PSAnZmlsZScpIHtcbiAgICAgIGNvbnN0IHNvdXJjZSA9IChlbnRyeSBhcyBGaWxlTWFuaWZlc3RFbnRyeSkuc291cmNlO1xuICAgICAgaWYgKHNvdXJjZS5wYXRoICYmIChzb3VyY2UucGF0aC5lbmRzV2l0aCgnLnRlbXBsYXRlLmpzb24nKSkpIHtcbiAgICAgICAgYXNzZXRzLnB1c2goZW50cnkgYXMgRmlsZU1hbmlmZXN0RW50cnkpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBbYXNzZXRNYW5pZmVzdCwgYXNzZXRzXTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gdXBsb2FkQm9keVBhcmFtZXRlckFuZENyZWF0ZUNoYW5nZVNldChvcHRpb25zOiBQcmVwYXJlQ2hhbmdlU2V0T3B0aW9ucyk6IFByb21pc2U8RGVzY3JpYmVDaGFuZ2VTZXRPdXRwdXQgfCB1bmRlZmluZWQ+IHtcbiAgdHJ5IHtcbiAgICBhd2FpdCB1cGxvYWRTdGFja1RlbXBsYXRlQXNzZXRzKG9wdGlvbnMuc3RhY2ssIG9wdGlvbnMuZGVwbG95bWVudHMpO1xuICAgIGNvbnN0IHByZXBhcmVkU2RrID0gKGF3YWl0IG9wdGlvbnMuZGVwbG95bWVudHMucHJlcGFyZVNka1dpdGhEZXBsb3lSb2xlKG9wdGlvbnMuc3RhY2spKTtcblxuICAgIGNvbnN0IGJvZHlQYXJhbWV0ZXIgPSBhd2FpdCBtYWtlQm9keVBhcmFtZXRlcihcbiAgICAgIG9wdGlvbnMuc3RhY2ssXG4gICAgICBwcmVwYXJlZFNkay5yZXNvbHZlZEVudmlyb25tZW50LFxuICAgICAgbmV3IEFzc2V0TWFuaWZlc3RCdWlsZGVyKCksXG4gICAgICBwcmVwYXJlZFNkay5lbnZSZXNvdXJjZXMsXG4gICAgICBwcmVwYXJlZFNkay5zdGFja1NkayxcbiAgICApO1xuICAgIGNvbnN0IGNmbiA9IHByZXBhcmVkU2RrLnN0YWNrU2RrLmNsb3VkRm9ybWF0aW9uKCk7XG4gICAgY29uc3QgZXhpc3RzID0gKGF3YWl0IENsb3VkRm9ybWF0aW9uU3RhY2subG9va3VwKGNmbiwgb3B0aW9ucy5zdGFjay5zdGFja05hbWUsIGZhbHNlKSkuZXhpc3RzO1xuXG4gICAgY29uc3QgZXhlY3V0aW9uUm9sZUFybiA9IHByZXBhcmVkU2RrLmNsb3VkRm9ybWF0aW9uUm9sZUFybjtcbiAgICBvcHRpb25zLnN0cmVhbS53cml0ZSgnSG9sZCBvbiB3aGlsZSB3ZSBjcmVhdGUgYSByZWFkLW9ubHkgY2hhbmdlIHNldCB0byBnZXQgYSBkaWZmIHdpdGggYWNjdXJhdGUgcmVwbGFjZW1lbnQgaW5mb3JtYXRpb24gKHVzZSAtLW5vLWNoYW5nZS1zZXQgdG8gdXNlIGEgbGVzcyBhY2N1cmF0ZSBidXQgZmFzdGVyIHRlbXBsYXRlLW9ubHkgZGlmZilcXG4nKTtcblxuICAgIHJldHVybiBhd2FpdCBjcmVhdGVDaGFuZ2VTZXQoe1xuICAgICAgY2ZuLFxuICAgICAgY2hhbmdlU2V0TmFtZTogJ2Nkay1kaWZmLWNoYW5nZS1zZXQnLFxuICAgICAgc3RhY2s6IG9wdGlvbnMuc3RhY2ssXG4gICAgICBleGlzdHMsXG4gICAgICB1dWlkOiBvcHRpb25zLnV1aWQsXG4gICAgICB3aWxsRXhlY3V0ZTogb3B0aW9ucy53aWxsRXhlY3V0ZSxcbiAgICAgIGJvZHlQYXJhbWV0ZXIsXG4gICAgICBwYXJhbWV0ZXJzOiBvcHRpb25zLnBhcmFtZXRlcnMsXG4gICAgICByZXNvdXJjZXNUb0ltcG9ydDogb3B0aW9ucy5yZXNvdXJjZXNUb0ltcG9ydCxcbiAgICAgIHJvbGU6IGV4ZWN1dGlvblJvbGVBcm4sXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGU6IGFueSkge1xuICAgIGRlYnVnKGUubWVzc2FnZSk7XG4gICAgb3B0aW9ucy5zdHJlYW0ud3JpdGUoJ0NvdWxkIG5vdCBjcmVhdGUgYSBjaGFuZ2Ugc2V0LCB3aWxsIGJhc2UgdGhlIGRpZmYgb24gdGVtcGxhdGUgZGlmZmVyZW5jZXMgKHJ1biBhZ2FpbiB3aXRoIC12IHRvIHNlZSB0aGUgcmVhc29uKVxcbicpO1xuXG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFVwbG9hZHMgdGhlIGFzc2V0cyB0aGF0IGxvb2sgbGlrZSB0ZW1wbGF0ZXMgZm9yIHRoaXMgQ2xvdWRGb3JtYXRpb24gc3RhY2tcbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBmb3IgYW55IENsb3VkRm9ybWF0aW9uIGNhbGwgdGhhdCBuZWVkcyB0aGUgdGVtcGxhdGUsIGl0IG1heSBuZWVkXG4gKiB0byBiZSB1cGxvYWRlZCB0byBhbiBTMyBidWNrZXQgZmlyc3QuIFdlIGhhdmUgdG8gZm9sbG93IHRoZSBpbnN0cnVjdGlvbnMgaW4gdGhlXG4gKiBhc3NldCBtYW5pZmVzdCwgYmVjYXVzZSB0ZWNobmljYWxseSB0aGF0IGlzIHRoZSBvbmx5IHBsYWNlIHRoYXQga25vd3MgYWJvdXRcbiAqIGJ1Y2tldCBhbmQgYXNzdW1lZCByb2xlcyBhbmQgc3VjaC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwbG9hZFN0YWNrVGVtcGxhdGVBc3NldHMoc3RhY2s6IGN4YXBpLkNsb3VkRm9ybWF0aW9uU3RhY2tBcnRpZmFjdCwgZGVwbG95bWVudHM6IERlcGxveW1lbnRzKSB7XG4gIGZvciAoY29uc3QgYXJ0aWZhY3Qgb2Ygc3RhY2suZGVwZW5kZW5jaWVzKSB7XG4gICAgLy8gU2tpcCBhcnRpZmFjdCBpZiBpdCBpcyBub3QgYW4gQXNzZXQgTWFuaWZlc3QgQXJ0aWZhY3RcbiAgICBpZiAoIWN4YXBpLkFzc2V0TWFuaWZlc3RBcnRpZmFjdC5pc0Fzc2V0TWFuaWZlc3RBcnRpZmFjdChhcnRpZmFjdCkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGNvbnN0IFthc3NldE1hbmlmZXN0LCBmaWxlX2VudHJpZXNdID0gdGVtcGxhdGVzRnJvbUFzc2V0TWFuaWZlc3RBcnRpZmFjdChhcnRpZmFjdCk7XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBmaWxlX2VudHJpZXMpIHtcbiAgICAgIGF3YWl0IGRlcGxveW1lbnRzLmJ1aWxkU2luZ2xlQXNzZXQoYXJ0aWZhY3QsIGFzc2V0TWFuaWZlc3QsIGVudHJ5LCB7XG4gICAgICAgIHN0YWNrLFxuICAgICAgfSk7XG4gICAgICBhd2FpdCBkZXBsb3ltZW50cy5wdWJsaXNoU2luZ2xlQXNzZXQoYXNzZXRNYW5pZmVzdCwgZW50cnksIHtcbiAgICAgICAgc3RhY2ssXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuYXN5bmMgZnVuY3Rpb24gY3JlYXRlQ2hhbmdlU2V0KG9wdGlvbnM6IENyZWF0ZUNoYW5nZVNldE9wdGlvbnMpOiBQcm9taXNlPERlc2NyaWJlQ2hhbmdlU2V0T3V0cHV0PiB7XG4gIGF3YWl0IGNsZWFudXBPbGRDaGFuZ2VzZXQob3B0aW9ucy5jaGFuZ2VTZXROYW1lLCBvcHRpb25zLnN0YWNrLnN0YWNrTmFtZSwgb3B0aW9ucy5jZm4pO1xuXG4gIGRlYnVnKGBBdHRlbXB0aW5nIHRvIGNyZWF0ZSBDaGFuZ2VTZXQgd2l0aCBuYW1lICR7b3B0aW9ucy5jaGFuZ2VTZXROYW1lfSBmb3Igc3RhY2sgJHtvcHRpb25zLnN0YWNrLnN0YWNrTmFtZX1gKTtcblxuICBjb25zdCB0ZW1wbGF0ZVBhcmFtcyA9IFRlbXBsYXRlUGFyYW1ldGVycy5mcm9tVGVtcGxhdGUob3B0aW9ucy5zdGFjay50ZW1wbGF0ZSk7XG4gIGNvbnN0IHN0YWNrUGFyYW1zID0gdGVtcGxhdGVQYXJhbXMuc3VwcGx5QWxsKG9wdGlvbnMucGFyYW1ldGVycyk7XG5cbiAgY29uc3QgY2hhbmdlU2V0ID0gYXdhaXQgb3B0aW9ucy5jZm4uY3JlYXRlQ2hhbmdlU2V0KHtcbiAgICBTdGFja05hbWU6IG9wdGlvbnMuc3RhY2suc3RhY2tOYW1lLFxuICAgIENoYW5nZVNldE5hbWU6IG9wdGlvbnMuY2hhbmdlU2V0TmFtZSxcbiAgICBDaGFuZ2VTZXRUeXBlOiBvcHRpb25zLnJlc291cmNlc1RvSW1wb3J0ID8gJ0lNUE9SVCcgOiBvcHRpb25zLmV4aXN0cyA/ICdVUERBVEUnIDogJ0NSRUFURScsXG4gICAgRGVzY3JpcHRpb246IGBDREsgQ2hhbmdlc2V0IGZvciBkaWZmICR7b3B0aW9ucy51dWlkfWAsXG4gICAgQ2xpZW50VG9rZW46IGBkaWZmJHtvcHRpb25zLnV1aWR9YCxcbiAgICBUZW1wbGF0ZVVSTDogb3B0aW9ucy5ib2R5UGFyYW1ldGVyLlRlbXBsYXRlVVJMLFxuICAgIFRlbXBsYXRlQm9keTogb3B0aW9ucy5ib2R5UGFyYW1ldGVyLlRlbXBsYXRlQm9keSxcbiAgICBQYXJhbWV0ZXJzOiBzdGFja1BhcmFtcy5hcGlQYXJhbWV0ZXJzLFxuICAgIFJlc291cmNlc1RvSW1wb3J0OiBvcHRpb25zLnJlc291cmNlc1RvSW1wb3J0LFxuICAgIFJvbGVBUk46IG9wdGlvbnMucm9sZSxcbiAgICBDYXBhYmlsaXRpZXM6IFsnQ0FQQUJJTElUWV9JQU0nLCAnQ0FQQUJJTElUWV9OQU1FRF9JQU0nLCAnQ0FQQUJJTElUWV9BVVRPX0VYUEFORCddLFxuICB9KS5wcm9taXNlKCk7XG5cbiAgZGVidWcoJ0luaXRpYXRlZCBjcmVhdGlvbiBvZiBjaGFuZ2VzZXQ6ICVzOyB3YWl0aW5nIGZvciBpdCB0byBmaW5pc2ggY3JlYXRpbmcuLi4nLCBjaGFuZ2VTZXQuSWQpO1xuICAvLyBGZXRjaGluZyBhbGwgcGFnZXMgaWYgd2UnbGwgZXhlY3V0ZSwgc28gd2UgY2FuIGhhdmUgdGhlIGNvcnJlY3QgY2hhbmdlIGNvdW50IHdoZW4gbW9uaXRvcmluZy5cbiAgY29uc3QgY3JlYXRlZENoYW5nZVNldCA9IGF3YWl0IHdhaXRGb3JDaGFuZ2VTZXQob3B0aW9ucy5jZm4sIG9wdGlvbnMuc3RhY2suc3RhY2tOYW1lLCBvcHRpb25zLmNoYW5nZVNldE5hbWUsIHsgZmV0Y2hBbGw6IG9wdGlvbnMud2lsbEV4ZWN1dGUgfSk7XG4gIGF3YWl0IGNsZWFudXBPbGRDaGFuZ2VzZXQob3B0aW9ucy5jaGFuZ2VTZXROYW1lLCBvcHRpb25zLnN0YWNrLnN0YWNrTmFtZSwgb3B0aW9ucy5jZm4pO1xuXG4gIC8vIFRPRE86IFVwZGF0ZSB0aGlzIG9uY2Ugd2UgcmVtb3ZlIHNka3YyIGZyb20gdGhlIHJlc3Qgb2YgdGhpcyBwYWNrYWdlXG4gIHJldHVybiBjcmVhdGVkQ2hhbmdlU2V0IGFzIERlc2NyaWJlQ2hhbmdlU2V0T3V0cHV0O1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY2xlYW51cE9sZENoYW5nZXNldChjaGFuZ2VTZXROYW1lOiBzdHJpbmcsIHN0YWNrTmFtZTogc3RyaW5nLCBjZm46IENsb3VkRm9ybWF0aW9uKSB7XG4gIC8vIERlbGV0ZSBhbnkgZXhpc3RpbmcgY2hhbmdlIHNldHMgZ2VuZXJhdGVkIGJ5IENESyBzaW5jZSBjaGFuZ2Ugc2V0IG5hbWVzIG11c3QgYmUgdW5pcXVlLlxuICAvLyBUaGUgZGVsZXRlIHJlcXVlc3QgaXMgc3VjY2Vzc2Z1bCBhcyBsb25nIGFzIHRoZSBzdGFjayBleGlzdHMgKGV2ZW4gaWYgdGhlIGNoYW5nZSBzZXQgZG9lcyBub3QgZXhpc3QpLlxuICBkZWJ1ZyhgUmVtb3ZpbmcgZXhpc3RpbmcgY2hhbmdlIHNldCB3aXRoIG5hbWUgJHtjaGFuZ2VTZXROYW1lfSBpZiBpdCBleGlzdHNgKTtcbiAgYXdhaXQgY2ZuLmRlbGV0ZUNoYW5nZVNldCh7IFN0YWNrTmFtZTogc3RhY2tOYW1lLCBDaGFuZ2VTZXROYW1lOiBjaGFuZ2VTZXROYW1lIH0pLnByb21pc2UoKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgZ2l2ZW4gY2hhbmdlIHNldCBoYXMgbm8gY2hhbmdlc1xuICpcbiAqIFRoaXMgbXVzdCBiZSBkZXRlcm1pbmVkIGZyb20gdGhlIHN0YXR1cywgbm90IHRoZSAnQ2hhbmdlcycgYXJyYXkgb24gdGhlXG4gKiBvYmplY3Q7IHRoZSBsYXR0ZXIgY2FuIGJlIGVtcHR5IGJlY2F1c2Ugbm8gcmVzb3VyY2VzIHdlcmUgY2hhbmdlZCwgYnV0IGlmXG4gKiB0aGVyZSBhcmUgY2hhbmdlcyB0byBPdXRwdXRzLCB0aGUgY2hhbmdlIHNldCBjYW4gc3RpbGwgYmUgZXhlY3V0ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGFuZ2VTZXRIYXNOb0NoYW5nZXMoZGVzY3JpcHRpb246IENsb3VkRm9ybWF0aW9uLkRlc2NyaWJlQ2hhbmdlU2V0T3V0cHV0KSB7XG4gIGNvbnN0IG5vQ2hhbmdlRXJyb3JQcmVmaXhlcyA9IFtcbiAgICAvLyBFcnJvciBtZXNzYWdlIGZvciBhIHJlZ3VsYXIgdGVtcGxhdGVcbiAgICAnVGhlIHN1Ym1pdHRlZCBpbmZvcm1hdGlvbiBkaWRuXFwndCBjb250YWluIGNoYW5nZXMuJyxcbiAgICAvLyBFcnJvciBtZXNzYWdlIHdoZW4gYSBUcmFuc2Zvcm0gaXMgaW52b2x2ZWQgKHNlZSAjMTA2NTApXG4gICAgJ05vIHVwZGF0ZXMgYXJlIHRvIGJlIHBlcmZvcm1lZC4nLFxuICBdO1xuXG4gIHJldHVybiBkZXNjcmlwdGlvbi5TdGF0dXMgPT09ICdGQUlMRUQnXG4gICAgJiYgbm9DaGFuZ2VFcnJvclByZWZpeGVzLnNvbWUocCA9PiAoZGVzY3JpcHRpb24uU3RhdHVzUmVhc29uID8/ICcnKS5zdGFydHNXaXRoKHApKTtcbn1cblxuLyoqXG4gKiBXYWl0cyBmb3IgYSBDbG91ZEZvcm1hdGlvbiBzdGFjayB0byBzdGFiaWxpemUgaW4gYSBjb21wbGV0ZS9hdmFpbGFibGUgc3RhdGVcbiAqIGFmdGVyIGEgZGVsZXRlIG9wZXJhdGlvbiBpcyBpc3N1ZWQuXG4gKlxuICogRmFpbHMgaWYgdGhlIHN0YWNrIGlzIGluIGEgRkFJTEVEIHN0YXRlLiBXaWxsIG5vdCBmYWlsIGlmIHRoZSBzdGFjayB3YXNcbiAqIGFscmVhZHkgZGVsZXRlZC5cbiAqXG4gKiBAcGFyYW0gY2ZuICAgICAgICBhIENsb3VkRm9ybWF0aW9uIGNsaWVudFxuICogQHBhcmFtIHN0YWNrTmFtZSAgICAgIHRoZSBuYW1lIG9mIHRoZSBzdGFjayB0byB3YWl0IGZvciBhZnRlciBhIGRlbGV0ZVxuICpcbiAqIEByZXR1cm5zICAgICB0aGUgQ2xvdWRGb3JtYXRpb24gZGVzY3JpcHRpb24gb2YgdGhlIHN0YWJpbGl6ZWQgc3RhY2sgYWZ0ZXIgdGhlIGRlbGV0ZSBhdHRlbXB0XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB3YWl0Rm9yU3RhY2tEZWxldGUoXG4gIGNmbjogQ2xvdWRGb3JtYXRpb24sXG4gIHN0YWNrTmFtZTogc3RyaW5nKTogUHJvbWlzZTxDbG91ZEZvcm1hdGlvblN0YWNrIHwgdW5kZWZpbmVkPiB7XG5cbiAgY29uc3Qgc3RhY2sgPSBhd2FpdCBzdGFiaWxpemVTdGFjayhjZm4sIHN0YWNrTmFtZSk7XG4gIGlmICghc3RhY2spIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuXG4gIGNvbnN0IHN0YXR1cyA9IHN0YWNrLnN0YWNrU3RhdHVzO1xuICBpZiAoc3RhdHVzLmlzRmFpbHVyZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHN0YWNrIG5hbWVkICR7c3RhY2tOYW1lfSBpcyBpbiBhIGZhaWxlZCBzdGF0ZS4gWW91IG1heSBuZWVkIHRvIGRlbGV0ZSBpdCBmcm9tIHRoZSBBV1MgY29uc29sZSA6ICR7c3RhdHVzfWApO1xuICB9IGVsc2UgaWYgKHN0YXR1cy5pc0RlbGV0ZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBzdGFjaztcbn1cblxuLyoqXG4gKiBXYWl0cyBmb3IgYSBDbG91ZEZvcm1hdGlvbiBzdGFjayB0byBzdGFiaWxpemUgaW4gYSBjb21wbGV0ZS9hdmFpbGFibGUgc3RhdGVcbiAqIGFmdGVyIGFuIHVwZGF0ZS9jcmVhdGUgb3BlcmF0aW9uIGlzIGlzc3VlZC5cbiAqXG4gKiBGYWlscyBpZiB0aGUgc3RhY2sgaXMgaW4gYSBGQUlMRUQgc3RhdGUsIFJPTExCQUNLIHN0YXRlLCBvciBERUxFVEVEIHN0YXRlLlxuICpcbiAqIEBwYXJhbSBjZm4gICAgICAgIGEgQ2xvdWRGb3JtYXRpb24gY2xpZW50XG4gKiBAcGFyYW0gc3RhY2tOYW1lICAgICAgdGhlIG5hbWUgb2YgdGhlIHN0YWNrIHRvIHdhaXQgZm9yIGFmdGVyIGFuIHVwZGF0ZVxuICpcbiAqIEByZXR1cm5zICAgICB0aGUgQ2xvdWRGb3JtYXRpb24gZGVzY3JpcHRpb24gb2YgdGhlIHN0YWJpbGl6ZWQgc3RhY2sgYWZ0ZXIgdGhlIHVwZGF0ZSBhdHRlbXB0XG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB3YWl0Rm9yU3RhY2tEZXBsb3koXG4gIGNmbjogQ2xvdWRGb3JtYXRpb24sXG4gIHN0YWNrTmFtZTogc3RyaW5nKTogUHJvbWlzZTxDbG91ZEZvcm1hdGlvblN0YWNrIHwgdW5kZWZpbmVkPiB7XG5cbiAgY29uc3Qgc3RhY2sgPSBhd2FpdCBzdGFiaWxpemVTdGFjayhjZm4sIHN0YWNrTmFtZSk7XG4gIGlmICghc3RhY2spIHsgcmV0dXJuIHVuZGVmaW5lZDsgfVxuXG4gIGNvbnN0IHN0YXR1cyA9IHN0YWNrLnN0YWNrU3RhdHVzO1xuXG4gIGlmIChzdGF0dXMuaXNDcmVhdGlvbkZhaWx1cmUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBzdGFjayBuYW1lZCAke3N0YWNrTmFtZX0gZmFpbGVkIGNyZWF0aW9uLCBpdCBtYXkgbmVlZCB0byBiZSBtYW51YWxseSBkZWxldGVkIGZyb20gdGhlIEFXUyBjb25zb2xlOiAke3N0YXR1c31gKTtcbiAgfSBlbHNlIGlmICghc3RhdHVzLmlzRGVwbG95U3VjY2Vzcykge1xuICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHN0YWNrIG5hbWVkICR7c3RhY2tOYW1lfSBmYWlsZWQgdG8gZGVwbG95OiAke3N0YXR1c31gKTtcbiAgfVxuXG4gIHJldHVybiBzdGFjaztcbn1cblxuLyoqXG4gKiBXYWl0IGZvciBhIHN0YWNrIHRvIGJlY29tZSBzdGFibGUgKG5vIGxvbmdlciBfSU5fUFJPR1JFU1MpLCByZXR1cm5pbmcgaXRcbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHN0YWJpbGl6ZVN0YWNrKGNmbjogQ2xvdWRGb3JtYXRpb24sIHN0YWNrTmFtZTogc3RyaW5nKSB7XG4gIGRlYnVnKCdXYWl0aW5nIGZvciBzdGFjayAlcyB0byBmaW5pc2ggY3JlYXRpbmcgb3IgdXBkYXRpbmcuLi4nLCBzdGFja05hbWUpO1xuICByZXR1cm4gd2FpdEZvcihhc3luYyAoKSA9PiB7XG4gICAgY29uc3Qgc3RhY2sgPSBhd2FpdCBDbG91ZEZvcm1hdGlvblN0YWNrLmxvb2t1cChjZm4sIHN0YWNrTmFtZSk7XG4gICAgaWYgKCFzdGFjay5leGlzdHMpIHtcbiAgICAgIGRlYnVnKCdTdGFjayAlcyBkb2VzIG5vdCBleGlzdCcsIHN0YWNrTmFtZSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3Qgc3RhdHVzID0gc3RhY2suc3RhY2tTdGF0dXM7XG4gICAgaWYgKHN0YXR1cy5pc0luUHJvZ3Jlc3MpIHtcbiAgICAgIGRlYnVnKCdTdGFjayAlcyBoYXMgYW4gb25nb2luZyBvcGVyYXRpb24gaW4gcHJvZ3Jlc3MgYW5kIGlzIG5vdCBzdGFibGUgKCVzKScsIHN0YWNrTmFtZSwgc3RhdHVzKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmIChzdGF0dXMuaXNSZXZpZXdJblByb2dyZXNzKSB7XG4gICAgICAvLyBUaGlzIG1heSBoYXBwZW4gaWYgYSBzdGFjayBjcmVhdGlvbiBvcGVyYXRpb24gaXMgaW50ZXJydXB0ZWQgYmVmb3JlIHRoZSBDaGFuZ2VTZXQgZXhlY3V0aW9uIHN0YXJ0cy4gUmVjb3ZlcmluZ1xuICAgICAgLy8gZnJvbSB0aGlzIHdvdWxkIHJlcXVpcmluZyBtYW51YWwgaW50ZXJ2ZW50aW9uIChkZWxldGluZyBvciBleGVjdXRpbmcgdGhlIHBlbmRpbmcgQ2hhbmdlU2V0KSwgYW5kIGZhaWxpbmcgdG8gZG9cbiAgICAgIC8vIHNvIHdpbGwgcmVzdWx0IGluIGFuIGVuZGxlc3Mgd2FpdCBoZXJlICh0aGUgQ2hhbmdlU2V0IHdvbnQgZGVsZXRlIG9yIGV4ZWN1dGUgaXRzZWxmKS4gSW5zdGVhZCBvZiBibG9ja2luZ1xuICAgICAgLy8gXCJmb3JldmVyXCIgd2UgcHJvY2VlZCBhcyBpZiB0aGUgc3RhY2sgd2FzIGV4aXN0aW5nIGFuZCBzdGFibGUuIElmIHRoZXJlIGlzIGEgY29uY3VycmVudCBvcGVyYXRpb24gdGhhdCBqdXN0XG4gICAgICAvLyBoYXNuJ3QgZmluaXNoZWQgcHJvY2VlZGluZyBqdXN0IHlldCwgZWl0aGVyIHRoaXMgb3BlcmF0aW9uIG9yIHRoZSBjb25jdXJyZW50IG9uZSBtYXkgZmFpbCBkdWUgdG8gdGhlIG90aGVyIG9uZVxuICAgICAgLy8gaGF2aW5nIG1hZGUgcHJvZ3Jlc3MuIFdoaWNoIGlzIGZpbmUuIEkgZ3Vlc3MuXG4gICAgICBkZWJ1ZygnU3RhY2sgJXMgaXMgaW4gUkVWSUVXX0lOX1BST0dSRVNTIHN0YXRlLiBDb25zaWRlcmluZyB0aGlzIGlzIGEgc3RhYmxlIHN0YXR1cyAoJXMpJywgc3RhY2tOYW1lLCBzdGF0dXMpO1xuICAgIH1cblxuICAgIHJldHVybiBzdGFjaztcbiAgfSk7XG59XG5cbi8qKlxuICogVGhlIHNldCBvZiAoZm9ybWFsKSBwYXJhbWV0ZXJzIHRoYXQgaGF2ZSBiZWVuIGRlY2xhcmVkIGluIGEgdGVtcGxhdGVcbiAqL1xuZXhwb3J0IGNsYXNzIFRlbXBsYXRlUGFyYW1ldGVycyB7XG4gIHB1YmxpYyBzdGF0aWMgZnJvbVRlbXBsYXRlKHRlbXBsYXRlOiBUZW1wbGF0ZSkge1xuICAgIHJldHVybiBuZXcgVGVtcGxhdGVQYXJhbWV0ZXJzKHRlbXBsYXRlLlBhcmFtZXRlcnMgfHwge30pO1xuICB9XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSBwYXJhbXM6IFJlY29yZDxzdHJpbmcsIFRlbXBsYXRlUGFyYW1ldGVyPikge1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZSBzdGFjayBwYXJhbWV0ZXJzIHRvIHBhc3MgZnJvbSB0aGUgZ2l2ZW4gZGVzaXJlZCBwYXJhbWV0ZXIgdmFsdWVzXG4gICAqXG4gICAqIFdpbGwgdGhyb3cgaWYgcGFyYW1ldGVycyB3aXRob3V0IGEgRGVmYXVsdCB2YWx1ZSBvciBhIFByZXZpb3VzIHZhbHVlIGFyZSBub3RcbiAgICogc3VwcGxpZWQuXG4gICAqL1xuICBwdWJsaWMgc3VwcGx5QWxsKHVwZGF0ZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZyB8IHVuZGVmaW5lZD4pOiBQYXJhbWV0ZXJWYWx1ZXMge1xuICAgIHJldHVybiBuZXcgUGFyYW1ldGVyVmFsdWVzKHRoaXMucGFyYW1zLCB1cGRhdGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGcm9tIHRoZSB0ZW1wbGF0ZSwgdGhlIGdpdmVuIGRlc2lyZWQgdmFsdWVzIGFuZCB0aGUgY3VycmVudCB2YWx1ZXMsIGNhbGN1bGF0ZSB0aGUgY2hhbmdlcyB0byB0aGUgc3RhY2sgcGFyYW1ldGVyc1xuICAgKlxuICAgKiBXaWxsIHRha2UgaW50byBhY2NvdW50IHBhcmFtZXRlcnMgYWxyZWFkeSBzZXQgb24gdGhlIHRlbXBsYXRlICh3aWxsIGVtaXRcbiAgICogJ1VzZVByZXZpb3VzVmFsdWU6IHRydWUnIGZvciB0aG9zZSB1bmxlc3MgdGhlIHZhbHVlIGlzIGNoYW5nZWQpLCBhbmQgd2lsbFxuICAgKiB0aHJvdyBpZiBwYXJhbWV0ZXJzIHdpdGhvdXQgYSBEZWZhdWx0IHZhbHVlIG9yIGEgUHJldmlvdXMgdmFsdWUgYXJlIG5vdFxuICAgKiBzdXBwbGllZC5cbiAgICovXG4gIHB1YmxpYyB1cGRhdGVFeGlzdGluZyh1cGRhdGVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCB1bmRlZmluZWQ+LCBwcmV2aW91c1ZhbHVlczogUmVjb3JkPHN0cmluZywgc3RyaW5nPik6IFBhcmFtZXRlclZhbHVlcyB7XG4gICAgcmV0dXJuIG5ldyBQYXJhbWV0ZXJWYWx1ZXModGhpcy5wYXJhbXMsIHVwZGF0ZXMsIHByZXZpb3VzVmFsdWVzKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBzZXQgb2YgcGFyYW1ldGVycyB3ZSdyZSBnb2luZyB0byBwYXNzIHRvIGEgU3RhY2tcbiAqL1xuZXhwb3J0IGNsYXNzIFBhcmFtZXRlclZhbHVlcyB7XG4gIHB1YmxpYyByZWFkb25seSB2YWx1ZXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7fTtcbiAgcHVibGljIHJlYWRvbmx5IGFwaVBhcmFtZXRlcnM6IENsb3VkRm9ybWF0aW9uLlBhcmFtZXRlcltdID0gW107XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBmb3JtYWxQYXJhbXM6IFJlY29yZDxzdHJpbmcsIFRlbXBsYXRlUGFyYW1ldGVyPixcbiAgICB1cGRhdGVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCB1bmRlZmluZWQ+LFxuICAgIHByZXZpb3VzVmFsdWVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+ID0ge30pIHtcblxuICAgIGNvbnN0IG1pc3NpbmdSZXF1aXJlZCA9IG5ldyBBcnJheTxzdHJpbmc+KCk7XG5cbiAgICBmb3IgKGNvbnN0IFtrZXksIGZvcm1hbFBhcmFtXSBvZiBPYmplY3QuZW50cmllcyh0aGlzLmZvcm1hbFBhcmFtcykpIHtcbiAgICAgIC8vIENoZWNrIHVwZGF0ZXMgZmlyc3QsIHRoZW4gdXNlIHRoZSBwcmV2aW91cyB2YWx1ZSAoaWYgYXZhaWxhYmxlKSwgdGhlbiB1c2VcbiAgICAgIC8vIHRoZSBkZWZhdWx0IChpZiBhdmFpbGFibGUpLlxuICAgICAgLy9cbiAgICAgIC8vIElmIHdlIGRvbid0IGZpbmQgYSBwYXJhbWV0ZXIgdmFsdWUgdXNpbmcgYW55IG9mIHRoZXNlIG1ldGhvZHMsIHRoZW4gdGhhdCdzIGFuIGVycm9yLlxuICAgICAgY29uc3QgdXBkYXRlZFZhbHVlID0gdXBkYXRlc1trZXldO1xuICAgICAgaWYgKHVwZGF0ZWRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMudmFsdWVzW2tleV0gPSB1cGRhdGVkVmFsdWU7XG4gICAgICAgIHRoaXMuYXBpUGFyYW1ldGVycy5wdXNoKHsgUGFyYW1ldGVyS2V5OiBrZXksIFBhcmFtZXRlclZhbHVlOiB1cGRhdGVzW2tleV0gfSk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoa2V5IGluIHByZXZpb3VzVmFsdWVzKSB7XG4gICAgICAgIHRoaXMudmFsdWVzW2tleV0gPSBwcmV2aW91c1ZhbHVlc1trZXldO1xuICAgICAgICB0aGlzLmFwaVBhcmFtZXRlcnMucHVzaCh7IFBhcmFtZXRlcktleToga2V5LCBVc2VQcmV2aW91c1ZhbHVlOiB0cnVlIH0pO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGZvcm1hbFBhcmFtLkRlZmF1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnZhbHVlc1trZXldID0gZm9ybWFsUGFyYW0uRGVmYXVsdDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIE9oIG5vXG4gICAgICBtaXNzaW5nUmVxdWlyZWQucHVzaChrZXkpO1xuICAgIH1cblxuICAgIGlmIChtaXNzaW5nUmVxdWlyZWQubGVuZ3RoID4gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgZm9sbG93aW5nIENsb3VkRm9ybWF0aW9uIFBhcmFtZXRlcnMgYXJlIG1pc3NpbmcgYSB2YWx1ZTogJHttaXNzaW5nUmVxdWlyZWQuam9pbignLCAnKX1gKTtcbiAgICB9XG5cbiAgICAvLyBKdXN0IGFwcGVuZCBhbGwgc3VwcGxpZWQgb3ZlcnJpZGVzIHRoYXQgYXJlbid0IHJlYWxseSBleHBlY3RlZCAodGhpc1xuICAgIC8vIHdpbGwgZmFpbCBDRk4gYnV0IG1heWJlIHBlb3BsZSBtYWRlIHR5cG9zIHRoYXQgdGhleSB3YW50IHRvIGJlIG5vdGlmaWVkXG4gICAgLy8gb2YpXG4gICAgY29uc3QgdW5rbm93blBhcmFtID0gKFtrZXksIF9dOiBbc3RyaW5nLCBhbnldKSA9PiB0aGlzLmZvcm1hbFBhcmFtc1trZXldID09PSB1bmRlZmluZWQ7XG4gICAgY29uc3QgaGFzVmFsdWUgPSAoW18sIHZhbHVlXTogW3N0cmluZywgYW55XSkgPT4gISF2YWx1ZTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyh1cGRhdGVzKS5maWx0ZXIodW5rbm93blBhcmFtKS5maWx0ZXIoaGFzVmFsdWUpKSB7XG4gICAgICB0aGlzLnZhbHVlc1trZXldID0gdmFsdWUhO1xuICAgICAgdGhpcy5hcGlQYXJhbWV0ZXJzLnB1c2goeyBQYXJhbWV0ZXJLZXk6IGtleSwgUGFyYW1ldGVyVmFsdWU6IHZhbHVlIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoaXMgc2V0IG9mIHBhcmFtZXRlciB1cGRhdGVzIHdpbGwgY2hhbmdlIHRoZSBhY3R1YWwgc3RhY2sgdmFsdWVzXG4gICAqL1xuICBwdWJsaWMgaGFzQ2hhbmdlcyhjdXJyZW50VmFsdWVzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+KTogUGFyYW1ldGVyQ2hhbmdlcyB7XG4gICAgLy8gSWYgYW55IG9mIHRoZSBwYXJhbWV0ZXJzIGFyZSBTU00gcGFyYW1ldGVycywgZGVwbG95aW5nIG11c3QgYWx3YXlzIGhhcHBlblxuICAgIC8vIGJlY2F1c2Ugd2UgY2FuJ3QgcHJlZGljdCB3aGF0IHRoZSB2YWx1ZXMgd2lsbCBiZS4gV2Ugd2lsbCBhbGxvdyBzb21lXG4gICAgLy8gcGFyYW1ldGVycyB0byBvcHQgb3V0IG9mIHRoaXMgY2hlY2sgYnkgaGF2aW5nIGEgbWFnaWMgc3RyaW5nIGluIHRoZWlyIGRlc2NyaXB0aW9uLlxuICAgIGlmIChPYmplY3QudmFsdWVzKHRoaXMuZm9ybWFsUGFyYW1zKS5zb21lKHAgPT4gcC5UeXBlLnN0YXJ0c1dpdGgoJ0FXUzo6U1NNOjpQYXJhbWV0ZXI6OicpICYmICFwLkRlc2NyaXB0aW9uPy5pbmNsdWRlcyhTU01QQVJBTV9OT19JTlZBTElEQVRFKSkpIHtcbiAgICAgIHJldHVybiAnc3NtJztcbiAgICB9XG5cbiAgICAvLyBPdGhlcndpc2Ugd2UncmUgZGlydHkgaWY6XG4gICAgLy8gLSBhbnkgb2YgdGhlIGV4aXN0aW5nIHZhbHVlcyBhcmUgcmVtb3ZlZCwgb3IgY2hhbmdlZFxuICAgIGlmIChPYmplY3QuZW50cmllcyhjdXJyZW50VmFsdWVzKS5zb21lKChba2V5LCB2YWx1ZV0pID0+ICEoa2V5IGluIHRoaXMudmFsdWVzKSB8fCB2YWx1ZSAhPT0gdGhpcy52YWx1ZXNba2V5XSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIC0gYW55IG9mIHRoZSB2YWx1ZXMgd2UncmUgc2V0dGluZyBhcmUgbmV3XG4gICAgaWYgKE9iamVjdC5rZXlzKHRoaXMudmFsdWVzKS5zb21lKGtleSA9PiAhKGtleSBpbiBjdXJyZW50VmFsdWVzKSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBQYXJhbWV0ZXJDaGFuZ2VzID0gYm9vbGVhbiB8ICdzc20nO1xuIl19