"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isHotswappableEcsServiceChange = void 0;
const AWS = require("aws-sdk");
const common_1 = require("./common");
async function isHotswappableEcsServiceChange(logicalId, change, evaluateCfnTemplate) {
    // the only resource change we can evaluate here is an ECS TaskDefinition
    if (change.newValue.Type !== 'AWS::ECS::TaskDefinition') {
        return [];
    }
    const ret = [];
    // We only allow a change in the ContainerDefinitions of the TaskDefinition for now -
    // it contains the image and environment variables, so seems like a safe bet for now.
    // We might revisit this decision in the future though!
    const classifiedChanges = (0, common_1.classifyChanges)(change, ['ContainerDefinitions']);
    classifiedChanges.reportNonHotswappablePropertyChanges(ret);
    // find all ECS Services that reference the TaskDefinition that changed
    const resourcesReferencingTaskDef = evaluateCfnTemplate.findReferencesTo(logicalId);
    const ecsServiceResourcesReferencingTaskDef = resourcesReferencingTaskDef.filter(r => r.Type === 'AWS::ECS::Service');
    const ecsServicesReferencingTaskDef = new Array();
    for (const ecsServiceResource of ecsServiceResourcesReferencingTaskDef) {
        const serviceArn = await evaluateCfnTemplate.findPhysicalNameFor(ecsServiceResource.LogicalId);
        if (serviceArn) {
            ecsServicesReferencingTaskDef.push({ serviceArn });
        }
    }
    if (ecsServicesReferencingTaskDef.length === 0) {
        // if there are no resources referencing the TaskDefinition,
        // hotswap is not possible in FALL_BACK mode
        (0, common_1.reportNonHotswappableChange)(ret, change, undefined, 'No ECS services reference the changed task definition', false);
    }
    if (resourcesReferencingTaskDef.length > ecsServicesReferencingTaskDef.length) {
        // if something besides an ECS Service is referencing the TaskDefinition,
        // hotswap is not possible in FALL_BACK mode
        const nonEcsServiceTaskDefRefs = resourcesReferencingTaskDef.filter(r => r.Type !== 'AWS::ECS::Service');
        for (const taskRef of nonEcsServiceTaskDefRefs) {
            (0, common_1.reportNonHotswappableChange)(ret, change, undefined, `A resource '${taskRef.LogicalId}' with Type '${taskRef.Type}' that is not an ECS Service was found referencing the changed TaskDefinition '${logicalId}'`);
        }
    }
    const namesOfHotswappableChanges = Object.keys(classifiedChanges.hotswappableProps);
    if (namesOfHotswappableChanges.length > 0) {
        const taskDefinitionResource = await prepareTaskDefinitionChange(evaluateCfnTemplate, logicalId, change);
        ret.push({
            hotswappable: true,
            resourceType: change.newValue.Type,
            propsChanged: namesOfHotswappableChanges,
            service: 'ecs-service',
            resourceNames: [
                `ECS Task Definition '${await taskDefinitionResource.Family}'`,
                ...ecsServicesReferencingTaskDef.map(ecsService => `ECS Service '${ecsService.serviceArn.split('/')[2]}'`),
            ],
            apply: async (sdk) => {
                // Step 1 - update the changed TaskDefinition, creating a new TaskDefinition Revision
                // we need to lowercase the evaluated TaskDef from CloudFormation,
                // as the AWS SDK uses lowercase property names for these
                // The SDK requires more properties here than its worth doing explicit typing for
                // instead, just use all the old values in the diff to fill them in implicitly
                const lowercasedTaskDef = (0, common_1.transformObjectKeys)(taskDefinitionResource, common_1.lowerCaseFirstCharacter, {
                    // All the properties that take arbitrary string as keys i.e. { "string" : "string" }
                    // https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_RegisterTaskDefinition.html#API_RegisterTaskDefinition_RequestSyntax
                    ContainerDefinitions: {
                        DockerLabels: true,
                        FirelensConfiguration: {
                            Options: true,
                        },
                        LogConfiguration: {
                            Options: true,
                        },
                    },
                    Volumes: {
                        DockerVolumeConfiguration: {
                            DriverOpts: true,
                            Labels: true,
                        },
                    },
                });
                const registerTaskDefResponse = await sdk.ecs().registerTaskDefinition(lowercasedTaskDef).promise();
                const taskDefRevArn = registerTaskDefResponse.taskDefinition?.taskDefinitionArn;
                // Step 2 - update the services using that TaskDefinition to point to the new TaskDefinition Revision
                const servicePerClusterUpdates = {};
                for (const ecsService of ecsServicesReferencingTaskDef) {
                    const clusterName = ecsService.serviceArn.split('/')[1];
                    const existingClusterPromises = servicePerClusterUpdates[clusterName];
                    let clusterPromises;
                    if (existingClusterPromises) {
                        clusterPromises = existingClusterPromises;
                    }
                    else {
                        clusterPromises = [];
                        servicePerClusterUpdates[clusterName] = clusterPromises;
                    }
                    // Forcing New Deployment and setting Minimum Healthy Percent to 0.
                    // As CDK HotSwap is development only, this seems the most efficient way to ensure all tasks are replaced immediately, regardless of original amount.
                    clusterPromises.push({
                        promise: sdk.ecs().updateService({
                            service: ecsService.serviceArn,
                            taskDefinition: taskDefRevArn,
                            cluster: clusterName,
                            forceNewDeployment: true,
                            deploymentConfiguration: {
                                minimumHealthyPercent: 0,
                            },
                        }).promise(),
                        ecsService: ecsService,
                    });
                }
                // Limited set of updates per cluster
                // eslint-disable-next-line @cdklabs/promiseall-no-unbounded-parallelism
                await Promise.all(Object.values(servicePerClusterUpdates)
                    .map(clusterUpdates => {
                    // Limited set of updates per cluster
                    // eslint-disable-next-line @cdklabs/promiseall-no-unbounded-parallelism
                    return Promise.all(clusterUpdates.map(serviceUpdate => serviceUpdate.promise));
                }));
                // Step 3 - wait for the service deployments triggered in Step 2 to finish
                // configure a custom Waiter
                sdk.ecs().api.waiters.deploymentCompleted = {
                    name: 'DeploymentCompleted',
                    operation: 'describeServices',
                    delay: 6,
                    maxAttempts: 100,
                    acceptors: [
                        {
                            matcher: 'pathAny',
                            argument: 'failures[].reason',
                            expected: 'MISSING',
                            state: 'failure',
                        },
                        {
                            matcher: 'pathAny',
                            argument: 'services[].status',
                            expected: 'DRAINING',
                            state: 'failure',
                        },
                        {
                            matcher: 'pathAny',
                            argument: 'services[].status',
                            expected: 'INACTIVE',
                            state: 'failure',
                        },
                        // failure if any services report a deployment with status FAILED
                        {
                            matcher: 'path',
                            argument: "length(services[].deployments[? rolloutState == 'FAILED'][]) > `0`",
                            expected: true,
                            state: 'failure',
                        },
                        // wait for all services to report only a single deployment
                        {
                            matcher: 'path',
                            argument: 'length(services[? length(deployments) > `1`]) == `0`',
                            expected: true,
                            state: 'success',
                        },
                    ],
                };
                // create a custom Waiter that uses the deploymentCompleted configuration added above
                const deploymentWaiter = new AWS.ResourceWaiter(sdk.ecs(), 'deploymentCompleted');
                // wait for all of the waiters to finish
                // eslint-disable-next-line @cdklabs/promiseall-no-unbounded-parallelism
                await Promise.all(Object.entries(servicePerClusterUpdates).map(([clusterName, serviceUpdates]) => {
                    return deploymentWaiter.wait({
                        cluster: clusterName,
                        services: serviceUpdates.map(serviceUpdate => serviceUpdate.ecsService.serviceArn),
                    }).promise();
                }));
            },
        });
    }
    return ret;
}
exports.isHotswappableEcsServiceChange = isHotswappableEcsServiceChange;
async function prepareTaskDefinitionChange(evaluateCfnTemplate, logicalId, change) {
    const taskDefinitionResource = {
        ...change.oldValue.Properties,
        ContainerDefinitions: change.newValue.Properties?.ContainerDefinitions,
    };
    // first, let's get the name of the family
    const familyNameOrArn = await evaluateCfnTemplate.establishResourcePhysicalName(logicalId, taskDefinitionResource?.Family);
    if (!familyNameOrArn) {
        // if the Family property has not been provided, and we can't find it in the current Stack,
        // this means hotswapping is not possible
        return;
    }
    // the physical name of the Task Definition in CloudFormation includes its current revision number at the end,
    // remove it if needed
    const familyNameOrArnParts = familyNameOrArn.split(':');
    const family = familyNameOrArnParts.length > 1
        // familyNameOrArn is actually an ARN, of the format 'arn:aws:ecs:region:account:task-definition/<family-name>:<revision-nr>'
        // so, take the 6th element, at index 5, and split it on '/'
        ? familyNameOrArnParts[5].split('/')[1]
        // otherwise, familyNameOrArn is just the simple name evaluated from the CloudFormation template
        : familyNameOrArn;
    // then, let's evaluate the body of the remainder of the TaskDef (without the Family property)
    return {
        ...await evaluateCfnTemplate.evaluateCfnExpression({
            ...(taskDefinitionResource ?? {}),
            Family: undefined,
        }),
        Family: family,
    };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZWNzLXNlcnZpY2VzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiZWNzLXNlcnZpY2VzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLCtCQUErQjtBQUMvQixxQ0FBd0s7QUFJakssS0FBSyxVQUFVLDhCQUE4QixDQUNsRCxTQUFpQixFQUFFLE1BQW1DLEVBQUUsbUJBQW1EO0lBRTNHLHlFQUF5RTtJQUN6RSxJQUFJLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxLQUFLLDBCQUEwQixFQUFFLENBQUM7UUFDeEQsT0FBTyxFQUFFLENBQUM7SUFDWixDQUFDO0lBRUQsTUFBTSxHQUFHLEdBQXdCLEVBQUUsQ0FBQztJQUVwQyxxRkFBcUY7SUFDckYscUZBQXFGO0lBQ3JGLHVEQUF1RDtJQUN2RCxNQUFNLGlCQUFpQixHQUFHLElBQUEsd0JBQWUsRUFBQyxNQUFNLEVBQUUsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDLENBQUM7SUFDNUUsaUJBQWlCLENBQUMsb0NBQW9DLENBQUMsR0FBRyxDQUFDLENBQUM7SUFFNUQsdUVBQXVFO0lBQ3ZFLE1BQU0sMkJBQTJCLEdBQUcsbUJBQW1CLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDcEYsTUFBTSxxQ0FBcUMsR0FBRywyQkFBMkIsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxLQUFLLG1CQUFtQixDQUFDLENBQUM7SUFDdEgsTUFBTSw2QkFBNkIsR0FBRyxJQUFJLEtBQUssRUFBYyxDQUFDO0lBQzlELEtBQUssTUFBTSxrQkFBa0IsSUFBSSxxQ0FBcUMsRUFBRSxDQUFDO1FBQ3ZFLE1BQU0sVUFBVSxHQUFHLE1BQU0sbUJBQW1CLENBQUMsbUJBQW1CLENBQUMsa0JBQWtCLENBQUMsU0FBUyxDQUFDLENBQUM7UUFDL0YsSUFBSSxVQUFVLEVBQUUsQ0FBQztZQUNmLDZCQUE2QixDQUFDLElBQUksQ0FBQyxFQUFFLFVBQVUsRUFBRSxDQUFD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O1FBQzVELENBQUMsQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3ZDLGdHQUFnRztRQUNoRyxDQUFDLENBQUMsZUFBZSxDQUFDO0lBQ3BCLDhGQUE4RjtJQUM5RixPQUFPO1FBQ0wsR0FBRyxNQUFNLG1CQUFtQixDQUFDLHFCQUFxQixDQUFDO1lBQ2pELEdBQUcsQ0FBQyxzQkFBc0IsSUFBSSxFQUFFLENBQUM7WUFDakMsTUFBTSxFQUFFLFNBQVM7U0FDbEIsQ0FBQztRQUNGLE1BQU0sRUFBRSxNQUFNO0tBQ2YsQ0FBQztBQUNKLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBBV1MgZnJvbSAnYXdzLXNkayc7XG5pbXBvcnQgeyBDaGFuZ2VIb3Rzd2FwUmVzdWx0LCBjbGFzc2lmeUNoYW5nZXMsIEhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSwgbG93ZXJDYXNlRmlyc3RDaGFyYWN0ZXIsIHJlcG9ydE5vbkhvdHN3YXBwYWJsZUNoYW5nZSwgdHJhbnNmb3JtT2JqZWN0S2V5cyB9IGZyb20gJy4vY29tbW9uJztcbmltcG9ydCB7IElTREsgfSBmcm9tICcuLi9hd3MtYXV0aCc7XG5pbXBvcnQgeyBFdmFsdWF0ZUNsb3VkRm9ybWF0aW9uVGVtcGxhdGUgfSBmcm9tICcuLi9ldmFsdWF0ZS1jbG91ZGZvcm1hdGlvbi10ZW1wbGF0ZSc7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBpc0hvdHN3YXBwYWJsZUVjc1NlcnZpY2VDaGFuZ2UoXG4gIGxvZ2ljYWxJZDogc3RyaW5nLCBjaGFuZ2U6IEhvdHN3YXBwYWJsZUNoYW5nZUNhbmRpZGF0ZSwgZXZhbHVhdGVDZm5UZW1wbGF0ZTogRXZhbHVhdGVDbG91ZEZvcm1hdGlvblRlbXBsYXRlLFxuKTogUHJvbWlzZTxDaGFuZ2VIb3Rzd2FwUmVzdWx0PiB7XG4gIC8vIHRoZSBvbmx5IHJlc291cmNlIGNoYW5nZSB3ZSBjYW4gZXZhbHVhdGUgaGVyZSBpcyBhbiBFQ1MgVGFza0RlZmluaXRpb25cbiAgaWYgKGNoYW5nZS5uZXdWYWx1ZS5UeXBlICE9PSAnQVdTOjpFQ1M6OlRhc2tEZWZpbml0aW9uJykge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGNvbnN0IHJldDogQ2hhbmdlSG90c3dhcFJlc3VsdCA9IFtdO1xuXG4gIC8vIFdlIG9ubHkgYWxsb3cgYSBjaGFuZ2UgaW4gdGhlIENvbnRhaW5lckRlZmluaXRpb25zIG9mIHRoZSBUYXNrRGVmaW5pdGlvbiBmb3Igbm93IC1cbiAgLy8gaXQgY29udGFpbnMgdGhlIGltYWdlIGFuZCBlbnZpcm9ubWVudCB2YXJpYWJsZXMsIHNvIHNlZW1zIGxpa2UgYSBzYWZlIGJldCBmb3Igbm93LlxuICAvLyBXZSBtaWdodCByZXZpc2l0IHRoaXMgZGVjaXNpb24gaW4gdGhlIGZ1dHVyZSB0aG91Z2ghXG4gIGNvbnN0IGNsYXNzaWZpZWRDaGFuZ2VzID0gY2xhc3NpZnlDaGFuZ2VzKGNoYW5nZSwgWydDb250YWluZXJEZWZpbml0aW9ucyddKTtcbiAgY2xhc3NpZmllZENoYW5nZXMucmVwb3J0Tm9uSG90c3dhcHBhYmxlUHJvcGVydHlDaGFuZ2VzKHJldCk7XG5cbiAgLy8gZmluZCBhbGwgRUNTIFNlcnZpY2VzIHRoYXQgcmVmZXJlbmNlIHRoZSBUYXNrRGVmaW5pdGlvbiB0aGF0IGNoYW5nZWRcbiAgY29uc3QgcmVzb3VyY2VzUmVmZXJlbmNpbmdUYXNrRGVmID0gZXZhbHVhdGVDZm5UZW1wbGF0ZS5maW5kUmVmZXJlbmNlc1RvKGxvZ2ljYWxJZCk7XG4gIGNvbnN0IGVjc1NlcnZpY2VSZXNvdXJjZXNSZWZlcmVuY2luZ1Rhc2tEZWYgPSByZXNvdXJjZXNSZWZlcmVuY2luZ1Rhc2tEZWYuZmlsdGVyKHIgPT4gci5UeXBlID09PSAnQVdTOjpFQ1M6OlNlcnZpY2UnKTtcbiAgY29uc3QgZWNzU2VydmljZXNSZWZlcmVuY2luZ1Rhc2tEZWYgPSBuZXcgQXJyYXk8RWNzU2VydmljZT4oKTtcbiAgZm9yIChjb25zdCBlY3NTZXJ2aWNlUmVzb3VyY2Ugb2YgZWNzU2VydmljZVJlc291cmNlc1JlZmVyZW5jaW5nVGFza0RlZikge1xuICAgIGNvbnN0IHNlcnZpY2VBcm4gPSBhd2FpdCBldmFsdWF0ZUNmblRlbXBsYXRlLmZpbmRQaHlzaWNhbE5hbWVGb3IoZWNzU2VydmljZVJlc291cmNlLkxvZ2ljYWxJZCk7XG4gICAgaWYgKHNlcnZpY2VBcm4pIHtcbiAgICAgIGVjc1NlcnZpY2VzUmVmZXJlbmNpbmdUYXNrRGVmLnB1c2goeyBzZXJ2aWNlQXJuIH0pO1xuICAgIH1cbiAgfVxuICBpZiAoZWNzU2VydmljZXNSZWZlcmVuY2luZ1Rhc2tEZWYubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gaWYgdGhlcmUgYXJlIG5vIHJlc291cmNlcyByZWZlcmVuY2luZyB0aGUgVGFza0RlZmluaXRpb24sXG4gICAgLy8gaG90c3dhcCBpcyBub3QgcG9zc2libGUgaW4gRkFMTF9CQUNLIG1vZGVcbiAgICByZXBvcnROb25Ib3Rzd2FwcGFibGVDaGFuZ2UocmV0LCBjaGFuZ2UsIHVuZGVmaW5lZCwgJ05vIEVDUyBzZXJ2aWNlcyByZWZlcmVuY2UgdGhlIGNoYW5nZWQgdGFzayBkZWZpbml0aW9uJywgZmFsc2UpO1xuICB9IGlmIChyZXNvdXJjZXNSZWZlcmVuY2luZ1Rhc2tEZWYubGVuZ3RoID4gZWNzU2VydmljZXNSZWZlcmVuY2luZ1Rhc2tEZWYubGVuZ3RoKSB7XG4gICAgLy8gaWYgc29tZXRoaW5nIGJlc2lkZXMgYW4gRUNTIFNlcnZpY2UgaXMgcmVmZXJlbmNpbmcgdGhlIFRhc2tEZWZpbml0aW9uLFxuICAgIC8vIGhvdHN3YXAgaXMgbm90IHBvc3NpYmxlIGluIEZBTExfQkFDSyBtb2RlXG4gICAgY29uc3Qgbm9uRWNzU2VydmljZVRhc2tEZWZSZWZzID0gcmVzb3VyY2VzUmVmZXJlbmNpbmdUYXNrRGVmLmZpbHRlcihyID0+IHIuVHlwZSAhPT0gJ0FXUzo6RUNTOjpTZXJ2aWNlJyk7XG4gICAgZm9yIChjb25zdCB0YXNrUmVmIG9mIG5vbkVjc1NlcnZpY2VUYXNrRGVmUmVmcykge1xuICAgICAgcmVwb3J0Tm9uSG90c3dhcHBhYmxlQ2hhbmdlKHJldCwgY2hhbmdlLCB1bmRlZmluZWQsIGBBIHJlc291cmNlICcke3Rhc2tSZWYuTG9naWNhbElkfScgd2l0aCBUeXBlICcke3Rhc2tSZWYuVHlwZX0nIHRoYXQgaXMgbm90IGFuIEVDUyBTZXJ2aWNlIHdhcyBmb3VuZCByZWZlcmVuY2luZyB0aGUgY2hhbmdlZCBUYXNrRGVmaW5pdGlvbiAnJHtsb2dpY2FsSWR9J2ApO1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IG5hbWVzT2ZIb3Rzd2FwcGFibGVDaGFuZ2VzID0gT2JqZWN0LmtleXMoY2xhc3NpZmllZENoYW5nZXMuaG90c3dhcHBhYmxlUHJvcHMpO1xuICBpZiAobmFtZXNPZkhvdHN3YXBwYWJsZUNoYW5nZXMubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IHRhc2tEZWZpbml0aW9uUmVzb3VyY2UgPSBhd2FpdCBwcmVwYXJlVGFza0RlZmluaXRpb25DaGFuZ2UoZXZhbHVhdGVDZm5UZW1wbGF0ZSwgbG9naWNhbElkLCBjaGFuZ2UpO1xuICAgIHJldC5wdXNoKHtcbiAgICAgIGhvdHN3YXBwYWJsZTogdHJ1ZSxcbiAgICAgIHJlc291cmNlVHlwZTogY2hhbmdlLm5ld1ZhbHVlLlR5cGUsXG4gICAgICBwcm9wc0NoYW5nZWQ6IG5hbWVzT2ZIb3Rzd2FwcGFibGVDaGFuZ2VzLFxuICAgICAgc2VydmljZTogJ2Vjcy1zZXJ2aWNlJyxcbiAgICAgIHJlc291cmNlTmFtZXM6IFtcbiAgICAgICAgYEVDUyBUYXNrIERlZmluaXRpb24gJyR7YXdhaXQgdGFza0RlZmluaXRpb25SZXNvdXJjZS5GYW1pbHl9J2AsXG4gICAgICAgIC4uLmVjc1NlcnZpY2VzUmVmZXJlbmNpbmdUYXNrRGVmLm1hcChlY3NTZXJ2aWNlID0+IGBFQ1MgU2VydmljZSAnJHtlY3NTZXJ2aWNlLnNlcnZpY2VBcm4uc3BsaXQoJy8nKVsyXX0nYCksXG4gICAgICBdLFxuICAgICAgYXBwbHk6IGFzeW5jIChzZGs6IElTREspID0+IHtcbiAgICAgICAgLy8gU3RlcCAxIC0gdXBkYXRlIHRoZSBjaGFuZ2VkIFRhc2tEZWZpbml0aW9uLCBjcmVhdGluZyBhIG5ldyBUYXNrRGVmaW5pdGlvbiBSZXZpc2lvblxuICAgICAgICAvLyB3ZSBuZWVkIHRvIGxvd2VyY2FzZSB0aGUgZXZhbHVhdGVkIFRhc2tEZWYgZnJvbSBDbG91ZEZvcm1hdGlvbixcbiAgICAgICAgLy8gYXMgdGhlIEFXUyBTREsgdXNlcyBsb3dlcmNhc2UgcHJvcGVydHkgbmFtZXMgZm9yIHRoZXNlXG5cbiAgICAgICAgLy8gVGhlIFNESyByZXF1aXJlcyBtb3JlIHByb3BlcnRpZXMgaGVyZSB0aGFuIGl0cyB3b3J0aCBkb2luZyBleHBsaWNpdCB0eXBpbmcgZm9yXG4gICAgICAgIC8vIGluc3RlYWQsIGp1c3QgdXNlIGFsbCB0aGUgb2xkIHZhbHVlcyBpbiB0aGUgZGlmZiB0byBmaWxsIHRoZW0gaW4gaW1wbGljaXRseVxuICAgICAgICBjb25zdCBsb3dlcmNhc2VkVGFza0RlZiA9IHRyYW5zZm9ybU9iamVjdEtleXModGFza0RlZmluaXRpb25SZXNvdXJjZSwgbG93ZXJDYXNlRmlyc3RDaGFyYWN0ZXIsIHtcbiAgICAgICAgICAvLyBBbGwgdGhlIHByb3BlcnRpZXMgdGhhdCB0YWtlIGFyYml0cmFyeSBzdHJpbmcgYXMga2V5cyBpLmUuIHsgXCJzdHJpbmdcIiA6IFwic3RyaW5nXCIgfVxuICAgICAgICAgIC8vIGh0dHBzOi8vZG9jcy5hd3MuYW1hem9uLmNvbS9BbWF6b25FQ1MvbGF0ZXN0L0FQSVJlZmVyZW5jZS9BUElfUmVnaXN0ZXJUYXNrRGVmaW5pdGlvbi5odG1sI0FQSV9SZWdpc3RlclRhc2tEZWZpbml0aW9uX1JlcXVlc3RTeW50YXhcbiAgICAgICAgICBDb250YWluZXJEZWZpbml0aW9uczoge1xuICAgICAgICAgICAgRG9ja2VyTGFiZWxzOiB0cnVlLFxuICAgICAgICAgICAgRmlyZWxlbnNDb25maWd1cmF0aW9uOiB7XG4gICAgICAgICAgICAgIE9wdGlvbnM6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgTG9nQ29uZmlndXJhdGlvbjoge1xuICAgICAgICAgICAgICBPcHRpb25zOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIFZvbHVtZXM6IHtcbiAgICAgICAgICAgIERvY2tlclZvbHVtZUNvbmZpZ3VyYXRpb246IHtcbiAgICAgICAgICAgICAgRHJpdmVyT3B0czogdHJ1ZSxcbiAgICAgICAgICAgICAgTGFiZWxzOiB0cnVlLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcmVnaXN0ZXJUYXNrRGVmUmVzcG9uc2UgPSBhd2FpdCBzZGsuZWNzKCkucmVnaXN0ZXJUYXNrRGVmaW5pdGlvbihsb3dlcmNhc2VkVGFza0RlZikucHJvbWlzZSgpO1xuICAgICAgICBjb25zdCB0YXNrRGVmUmV2QXJuID0gcmVnaXN0ZXJUYXNrRGVmUmVzcG9uc2UudGFza0RlZmluaXRpb24/LnRhc2tEZWZpbml0aW9uQXJuO1xuXG4gICAgICAgIC8vIFN0ZXAgMiAtIHVwZGF0ZSB0aGUgc2VydmljZXMgdXNpbmcgdGhhdCBUYXNrRGVmaW5pdGlvbiB0byBwb2ludCB0byB0aGUgbmV3IFRhc2tEZWZpbml0aW9uIFJldmlzaW9uXG4gICAgICAgIGNvbnN0IHNlcnZpY2VQZXJDbHVzdGVyVXBkYXRlczogeyBbY2x1c3Rlcjogc3RyaW5nXTogQXJyYXk8eyBwcm9taXNlOiBQcm9taXNlPGFueT47IGVjc1NlcnZpY2U6IEVjc1NlcnZpY2UgfT4gfSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGVjc1NlcnZpY2Ugb2YgZWNzU2VydmljZXNSZWZlcmVuY2luZ1Rhc2tEZWYpIHtcbiAgICAgICAgICBjb25zdCBjbHVzdGVyTmFtZSA9IGVjc1NlcnZpY2Uuc2VydmljZUFybi5zcGxpdCgnLycpWzFdO1xuXG4gICAgICAgICAgY29uc3QgZXhpc3RpbmdDbHVzdGVyUHJvbWlzZXMgPSBzZXJ2aWNlUGVyQ2x1c3RlclVwZGF0ZXNbY2x1c3Rlck5hbWVdO1xuICAgICAgICAgIGxldCBjbHVzdGVyUHJvbWlzZXM6IEFycmF5PHsgcHJvbWlzZTogUHJvbWlzZTxhbnk+OyBlY3NTZXJ2aWNlOiBFY3NTZXJ2aWNlIH0+O1xuICAgICAgICAgIGlmIChleGlzdGluZ0NsdXN0ZXJQcm9taXNlcykge1xuICAgICAgICAgICAgY2x1c3RlclByb21pc2VzID0gZXhpc3RpbmdDbHVzdGVyUHJvbWlzZXM7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNsdXN0ZXJQcm9taXNlcyA9IFtdO1xuICAgICAgICAgICAgc2VydmljZVBlckNsdXN0ZXJVcGRhdGVzW2NsdXN0ZXJOYW1lXSA9IGNsdXN0ZXJQcm9taXNlcztcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gRm9yY2luZyBOZXcgRGVwbG95bWVudCBhbmQgc2V0dGluZyBNaW5pbXVtIEhlYWx0aHkgUGVyY2VudCB0byAwLlxuICAgICAgICAgIC8vIEFzIENESyBIb3RTd2FwIGlzIGRldmVsb3BtZW50IG9ubHksIHRoaXMgc2VlbXMgdGhlIG1vc3QgZWZmaWNpZW50IHdheSB0byBlbnN1cmUgYWxsIHRhc2tzIGFyZSByZXBsYWNlZCBpbW1lZGlhdGVseSwgcmVnYXJkbGVzcyBvZiBvcmlnaW5hbCBhbW91bnQuXG4gICAgICAgICAgY2x1c3RlclByb21pc2VzLnB1c2goe1xuICAgICAgICAgICAgcHJvbWlzZTogc2RrLmVjcygpLnVwZGF0ZVNlcnZpY2Uoe1xuICAgICAgICAgICAgICBzZXJ2aWNlOiBlY3NTZXJ2aWNlLnNlcnZpY2VBcm4sXG4gICAgICAgICAgICAgIHRhc2tEZWZpbml0aW9uOiB0YXNrRGVmUmV2QXJuLFxuICAgICAgICAgICAgICBjbHVzdGVyOiBjbHVzdGVyTmFtZSxcbiAgICAgICAgICAgICAgZm9yY2VOZXdEZXBsb3ltZW50OiB0cnVlLFxuICAgICAgICAgICAgICBkZXBsb3ltZW50Q29uZmlndXJhdGlvbjoge1xuICAgICAgICAgICAgICAgIG1pbmltdW1IZWFsdGh5UGVyY2VudDogMCxcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0pLnByb21pc2UoKSxcbiAgICAgICAgICAgIGVjc1NlcnZpY2U6IGVjc1NlcnZpY2UsXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTGltaXRlZCBzZXQgb2YgdXBkYXRlcyBwZXIgY2x1c3RlclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQGNka2xhYnMvcHJvbWlzZWFsbC1uby11bmJvdW5kZWQtcGFyYWxsZWxpc21cbiAgICAgICAgYXdhaXQgUHJvbWlzZS5hbGwoT2JqZWN0LnZhbHVlcyhzZXJ2aWNlUGVyQ2x1c3RlclVwZGF0ZXMpXG4gICAgICAgICAgLm1hcChjbHVzdGVyVXBkYXRlcyA9PiB7XG4gICAgICAgICAgICAvLyBMaW1pdGVkIHNldCBvZiB1cGRhdGVzIHBlciBjbHVzdGVyXG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQGNka2xhYnMvcHJvbWlzZWFsbC1uby11bmJvdW5kZWQtcGFyYWxsZWxpc21cbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLmFsbChjbHVzdGVyVXBkYXRlcy5tYXAoc2VydmljZVVwZGF0ZSA9PiBzZXJ2aWNlVXBkYXRlLnByb21pc2UpKTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBTdGVwIDMgLSB3YWl0IGZvciB0aGUgc2VydmljZSBkZXBsb3ltZW50cyB0cmlnZ2VyZWQgaW4gU3RlcCAyIHRvIGZpbmlzaFxuICAgICAgICAvLyBjb25maWd1cmUgYSBjdXN0b20gV2FpdGVyXG4gICAgICAgIChzZGsuZWNzKCkgYXMgYW55KS5hcGkud2FpdGVycy5kZXBsb3ltZW50Q29tcGxldGVkID0ge1xuICAgICAgICAgIG5hbWU6ICdEZXBsb3ltZW50Q29tcGxldGVkJyxcbiAgICAgICAgICBvcGVyYXRpb246ICdkZXNjcmliZVNlcnZpY2VzJyxcbiAgICAgICAgICBkZWxheTogNixcbiAgICAgICAgICBtYXhBdHRlbXB0czogMTAwLFxuICAgICAgICAgIGFjY2VwdG9yczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBtYXRjaGVyOiAncGF0aEFueScsXG4gICAgICAgICAgICAgIGFyZ3VtZW50OiAnZmFpbHVyZXNbXS5yZWFzb24nLFxuICAgICAgICAgICAgICBleHBlY3RlZDogJ01JU1NJTkcnLFxuICAgICAgICAgICAgICBzdGF0ZTogJ2ZhaWx1cmUnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbWF0Y2hlcjogJ3BhdGhBbnknLFxuICAgICAgICAgICAgICBhcmd1bWVudDogJ3NlcnZpY2VzW10uc3RhdHVzJyxcbiAgICAgICAgICAgICAgZXhwZWN0ZWQ6ICdEUkFJTklORycsXG4gICAgICAgICAgICAgIHN0YXRlOiAnZmFpbHVyZScsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBtYXRjaGVyOiAncGF0aEFueScsXG4gICAgICAgICAgICAgIGFyZ3VtZW50OiAnc2VydmljZXNbXS5zdGF0dXMnLFxuICAgICAgICAgICAgICBleHBlY3RlZDogJ0lOQUNUSVZFJyxcbiAgICAgICAgICAgICAgc3RhdGU6ICdmYWlsdXJlJyxcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIGZhaWx1cmUgaWYgYW55IHNlcnZpY2VzIHJlcG9ydCBhIGRlcGxveW1lbnQgd2l0aCBzdGF0dXMgRkFJTEVEXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIG1hdGNoZXI6ICdwYXRoJyxcbiAgICAgICAgICAgICAgYXJndW1lbnQ6IFwibGVuZ3RoKHNlcnZpY2VzW10uZGVwbG95bWVudHNbPyByb2xsb3V0U3RhdGUgPT0gJ0ZBSUxFRCddW10pID4gYDBgXCIsXG4gICAgICAgICAgICAgIGV4cGVjdGVkOiB0cnVlLFxuICAgICAgICAgICAgICBzdGF0ZTogJ2ZhaWx1cmUnLFxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gd2FpdCBmb3IgYWxsIHNlcnZpY2VzIHRvIHJlcG9ydCBvbmx5IGEgc2luZ2xlIGRlcGxveW1lbnRcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbWF0Y2hlcjogJ3BhdGgnLFxuICAgICAgICAgICAgICBhcmd1bWVudDogJ2xlbmd0aChzZXJ2aWNlc1s/IGxlbmd0aChkZXBsb3ltZW50cykgPiBgMWBdKSA9PSBgMGAnLFxuICAgICAgICAgICAgICBleHBlY3RlZDogdHJ1ZSxcbiAgICAgICAgICAgICAgc3RhdGU6ICdzdWNjZXNzJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgXSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gY3JlYXRlIGEgY3VzdG9tIFdhaXRlciB0aGF0IHVzZXMgdGhlIGRlcGxveW1lbnRDb21wbGV0ZWQgY29uZmlndXJhdGlvbiBhZGRlZCBhYm92ZVxuICAgICAgICBjb25zdCBkZXBsb3ltZW50V2FpdGVyID0gbmV3IChBV1MgYXMgYW55KS5SZXNvdXJjZVdhaXRlcihzZGsuZWNzKCksICdkZXBsb3ltZW50Q29tcGxldGVkJyk7XG4gICAgICAgIC8vIHdhaXQgZm9yIGFsbCBvZiB0aGUgd2FpdGVycyB0byBmaW5pc2hcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEBjZGtsYWJzL3Byb21pc2VhbGwtbm8tdW5ib3VuZGVkLXBhcmFsbGVsaXNtXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKE9iamVjdC5lbnRyaWVzKHNlcnZpY2VQZXJDbHVzdGVyVXBkYXRlcykubWFwKChbY2x1c3Rlck5hbWUsIHNlcnZpY2VVcGRhdGVzXSkgPT4ge1xuICAgICAgICAgIHJldHVybiBkZXBsb3ltZW50V2FpdGVyLndhaXQoe1xuICAgICAgICAgICAgY2x1c3RlcjogY2x1c3Rlck5hbWUsXG4gICAgICAgICAgICBzZXJ2aWNlczogc2VydmljZVVwZGF0ZXMubWFwKHNlcnZpY2VVcGRhdGUgPT4gc2VydmljZVVwZGF0ZS5lY3NTZXJ2aWNlLnNlcnZpY2VBcm4pLFxuICAgICAgICAgIH0pLnByb21pc2UoKTtcbiAgICAgICAgfSkpO1xuICAgICAgfSxcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmludGVyZmFjZSBFY3NTZXJ2aWNlIHtcbiAgcmVhZG9ubHkgc2VydmljZUFybjogc3RyaW5nO1xufVxuXG5hc3luYyBmdW5jdGlvbiBwcmVwYXJlVGFza0RlZmluaXRpb25DaGFuZ2UoXG4gIGV2YWx1YXRlQ2ZuVGVtcGxhdGU6IEV2YWx1YXRlQ2xvdWRGb3JtYXRpb25UZW1wbGF0ZSwgbG9naWNhbElkOiBzdHJpbmcsIGNoYW5nZTogSG90c3dhcHBhYmxlQ2hhbmdlQ2FuZGlkYXRlLFxuKSB7XG4gIGNvbnN0IHRhc2tEZWZpbml0aW9uUmVzb3VyY2U6IHsgW25hbWU6IHN0cmluZ106IGFueSB9ID0ge1xuICAgIC4uLmNoYW5nZS5vbGRWYWx1ZS5Qcm9wZXJ0aWVzLFxuICAgIENvbnRhaW5lckRlZmluaXRpb25zOiBjaGFuZ2UubmV3VmFsdWUuUHJvcGVydGllcz8uQ29udGFpbmVyRGVmaW5pdGlvbnMsXG4gIH07XG4gIC8vIGZpcnN0LCBsZXQncyBnZXQgdGhlIG5hbWUgb2YgdGhlIGZhbWlseVxuICBjb25zdCBmYW1pbHlOYW1lT3JBcm4gPSBhd2FpdCBldmFsdWF0ZUNmblRlbXBsYXRlLmVzdGFibGlzaFJlc291cmNlUGh5c2ljYWxOYW1lKGxvZ2ljYWxJZCwgdGFza0RlZmluaXRpb25SZXNvdXJjZT8uRmFtaWx5KTtcbiAgaWYgKCFmYW1pbHlOYW1lT3JBcm4pIHtcbiAgICAvLyBpZiB0aGUgRmFtaWx5IHByb3BlcnR5IGhhcyBub3QgYmVlbiBwcm92aWRlZCwgYW5kIHdlIGNhbid0IGZpbmQgaXQgaW4gdGhlIGN1cnJlbnQgU3RhY2ssXG4gICAgLy8gdGhpcyBtZWFucyBob3Rzd2FwcGluZyBpcyBub3QgcG9zc2libGVcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gdGhlIHBoeXNpY2FsIG5hbWUgb2YgdGhlIFRhc2sgRGVmaW5pdGlvbiBpbiBDbG91ZEZvcm1hdGlvbiBpbmNsdWRlcyBpdHMgY3VycmVudCByZXZpc2lvbiBudW1iZXIgYXQgdGhlIGVuZCxcbiAgLy8gcmVtb3ZlIGl0IGlmIG5lZWRlZFxuICBjb25zdCBmYW1pbHlOYW1lT3JBcm5QYXJ0cyA9IGZhbWlseU5hbWVPckFybi5zcGxpdCgnOicpO1xuICBjb25zdCBmYW1pbHkgPSBmYW1pbHlOYW1lT3JBcm5QYXJ0cy5sZW5ndGggPiAxXG4gICAgLy8gZmFtaWx5TmFtZU9yQXJuIGlzIGFjdHVhbGx5IGFuIEFSTiwgb2YgdGhlIGZvcm1hdCAnYXJuOmF3czplY3M6cmVnaW9uOmFjY291bnQ6dGFzay1kZWZpbml0aW9uLzxmYW1pbHktbmFtZT46PHJldmlzaW9uLW5yPidcbiAgICAvLyBzbywgdGFrZSB0aGUgNnRoIGVsZW1lbnQsIGF0IGluZGV4IDUsIGFuZCBzcGxpdCBpdCBvbiAnLydcbiAgICA/IGZhbWlseU5hbWVPckFyblBhcnRzWzVdLnNwbGl0KCcvJylbMV1cbiAgICAvLyBvdGhlcndpc2UsIGZhbWlseU5hbWVPckFybiBpcyBqdXN0IHRoZSBzaW1wbGUgbmFtZSBldmFsdWF0ZWQgZnJvbSB0aGUgQ2xvdWRGb3JtYXRpb24gdGVtcGxhdGVcbiAgICA6IGZhbWlseU5hbWVPckFybjtcbiAgLy8gdGhlbiwgbGV0J3MgZXZhbHVhdGUgdGhlIGJvZHkgb2YgdGhlIHJlbWFpbmRlciBvZiB0aGUgVGFza0RlZiAod2l0aG91dCB0aGUgRmFtaWx5IHByb3BlcnR5KVxuICByZXR1cm4ge1xuICAgIC4uLmF3YWl0IGV2YWx1YXRlQ2ZuVGVtcGxhdGUuZXZhbHVhdGVDZm5FeHByZXNzaW9uKHtcbiAgICAgIC4uLih0YXNrRGVmaW5pdGlvblJlc291cmNlID8/IHt9KSxcbiAgICAgIEZhbWlseTogdW5kZWZpbmVkLFxuICAgIH0pLFxuICAgIEZhbWlseTogZmFtaWx5LFxuICB9O1xufVxuIl19