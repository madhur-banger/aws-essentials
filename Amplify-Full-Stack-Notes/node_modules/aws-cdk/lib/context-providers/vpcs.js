"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VpcNetworkContextProviderPlugin = void 0;
const cxapi = require("@aws-cdk/cx-api");
const sdk_provider_1 = require("../api/aws-auth/sdk-provider");
const logging_1 = require("../logging");
class VpcNetworkContextProviderPlugin {
    constructor(aws) {
        this.aws = aws;
    }
    async getValue(args) {
        const ec2 = (await (0, sdk_provider_1.initContextProviderSdk)(this.aws, args)).ec2();
        const vpcId = await this.findVpc(ec2, args);
        return this.readVpcProps(ec2, vpcId, args);
    }
    async findVpc(ec2, args) {
        // Build request filter (map { Name -> Value } to list of [{ Name, Values }])
        const filters = Object.entries(args.filter).map(([tag, value]) => ({ Name: tag, Values: [value] }));
        (0, logging_1.debug)(`Listing VPCs in ${args.account}:${args.region}`);
        const response = await ec2.describeVpcs({ Filters: filters }).promise();
        const vpcs = response.Vpcs || [];
        if (vpcs.length === 0) {
            throw new Error(`Could not find any VPCs matching ${JSON.stringify(args)}`);
        }
        if (vpcs.length > 1) {
            throw new Error(`Found ${vpcs.length} VPCs matching ${JSON.stringify(args)}; please narrow the search criteria`);
        }
        return vpcs[0];
    }
    async readVpcProps(ec2, vpc, args) {
        const vpcId = vpc.VpcId;
        (0, logging_1.debug)(`Describing VPC ${vpcId}`);
        const filters = { Filters: [{ Name: 'vpc-id', Values: [vpcId] }] };
        const subnetsResponse = await ec2.describeSubnets(filters).promise();
        const listedSubnets = subnetsResponse.Subnets || [];
        const routeTablesResponse = await ec2.describeRouteTables(filters).promise();
        const routeTables = new RouteTables(routeTablesResponse.RouteTables || []);
        // Now comes our job to separate these subnets out into AZs and subnet groups (Public, Private, Isolated)
        // We have the following attributes to go on:
        // - Type tag, we tag subnets with their type. In absence of this tag, we
        //   determine the subnet must be Public if either:
        //   a) it has the property MapPublicIpOnLaunch
        //   b) it has a route to an Internet Gateway
        //   If both of the above is false but the subnet has a route to a NAT Gateway
        //   and the destination CIDR block is "0.0.0.0/0", we assume it to be a Private subnet.
        //   Anything else is considered Isolated.
        // - Name tag, we tag subnets with their subnet group name. In absence of this tag,
        //   we use the type as the name.
        const azs = Array.from(new Set(listedSubnets.map(s => s.AvailabilityZone)));
        azs.sort();
        const subnets = listedSubnets.map(subnet => {
            let type = getTag('aws-cdk:subnet-type', subnet.Tags);
            if (type === undefined && subnet.MapPublicIpOnLaunch) {
                type = SubnetType.Public;
            }
            if (type === undefined && routeTables.hasRouteToIgw(subnet.SubnetId)) {
                type = SubnetType.Public;
            }
            if (type === undefined && routeTables.hasRouteToNatGateway(subnet.SubnetId)) {
                type = SubnetType.Private;
            }
            if (type === undefined && routeTables.hasRouteToTransitGateway(subnet.SubnetId)) {
                type = SubnetType.Private;
            }
            if (type === undefined) {
                type = SubnetType.Isolated;
            }
            if (!isValidSubnetType(type)) {
                // eslint-disable-next-line max-len
                throw new Error(`Subnet ${subnet.SubnetArn} has invalid subnet type ${type} (must be ${SubnetType.Public}, ${SubnetType.Private} or ${SubnetType.Isolated})`);
            }
            if (args.subnetGroupNameTag && !getTag(args.subnetGroupNameTag, subnet.Tags)) {
                throw new Error(`Invalid subnetGroupNameTag: Subnet ${subnet.SubnetArn} does not have an associated tag with Key='${args.subnetGroupNameTag}'`);
            }
            const name = getTag(args.subnetGroupNameTag || 'aws-cdk:subnet-name', subnet.Tags) || type;
            const routeTableId = routeTables.routeTableIdForSubnetId(subnet.SubnetId);
            if (!routeTableId) {
                throw new Error(`Subnet ${subnet.SubnetArn} does not have an associated route table (and there is no "main" table)`);
            }
            return {
                az: subnet.AvailabilityZone,
                cidr: subnet.CidrBlock,
                type,
                name,
                subnetId: subnet.SubnetId,
                routeTableId,
            };
        });
        let grouped;
        let assymetricSubnetGroups;
        if (args.returnAsymmetricSubnets) {
            grouped = { azs: [], groups: [] };
            assymetricSubnetGroups = groupAsymmetricSubnets(subnets);
        }
        else {
            grouped = groupSubnets(subnets);
            assymetricSubnetGroups = undefined;
        }
        // Find attached+available VPN gateway for this VPC
        const vpnGatewayResponse = (args.returnVpnGateways ?? true)
            ? await ec2.describeVpnGateways({
                Filters: [
                    {
                        Name: 'attachment.vpc-id',
                        Values: [vpcId],
                    },
                    {
                        Name: 'attachment.state',
                        Values: ['attached'],
                    },
                    {
                        Name: 'state',
                        Values: ['available'],
                    },
                ],
            }).promise()
            : undefined;
        const vpnGatewayId = vpnGatewayResponse?.VpnGateways?.length === 1
            ? vpnGatewayResponse.VpnGateways[0].VpnGatewayId
            : undefined;
        return {
            vpcId,
            vpcCidrBlock: vpc.CidrBlock,
            ownerAccountId: vpc.OwnerId,
            availabilityZones: grouped.azs,
            isolatedSubnetIds: collapse(flatMap(findGroups(SubnetType.Isolated, grouped), group => group.subnets.map(s => s.subnetId))),
            isolatedSubnetNames: collapse(flatMap(findGroups(SubnetType.Isolated, grouped), group => group.name ? [group.name] : [])),
            isolatedSubnetRouteTableIds: collapse(flatMap(findGroups(SubnetType.Isolated, grouped), group => group.subnets.map(s => s.routeTableId))),
            privateSubnetIds: collapse(flatMap(findGroups(SubnetType.Private, grouped), group => group.subnets.map(s => s.subnetId))),
            privateSubnetNames: collapse(flatMap(findGroups(SubnetType.Private, grouped), group => group.name ? [group.name] : [])),
            privateSubnetRouteTableIds: collapse(flatMap(findGroups(SubnetType.Private, grouped), group => group.subnets.map(s => s.routeTableId))),
            publicSubnetIds: collapse(flatMap(findGroups(SubnetType.Public, grouped), group => group.subnets.map(s => s.subnetId))),
            publicSubnetNames: collapse(flatMap(findGroups(SubnetType.Public, grouped), group => group.name ? [group.name] : [])),
            publicSubnetRouteTableIds: collapse(flatMap(findGroups(SubnetType.Public, grouped), group => group.subnets.map(s => s.routeTableId))),
            vpnGatewayId,
            subnetGroups: assymetricSubnetGroups,
        };
    }
}
exports.VpcNetworkContextProviderPlugin = VpcNetworkContextProviderPlugin;
class RouteTables {
    constructor(tables) {
        this.tables = tables;
        this.mainRouteTable = this.tables.find(table => !!table.Associations && table.Associations.some(assoc => !!assoc.Main));
    }
    routeTableIdForSubnetId(subnetId) {
        const table = this.tableForSubnet(subnetId);
        return (table && table.RouteTableId) || (this.mainRouteTable && this.mainRouteTable.RouteTableId);
    }
    /**
     * Whether the given subnet has a route to a NAT Gateway
     */
    hasRouteToNatGateway(subnetId) {
        const table = this.tableForSubnet(subnetId) || this.mainRouteTable;
        return !!table && !!table.Routes && table.Routes.some(route => !!route.NatGatewayId && route.DestinationCidrBlock === '0.0.0.0/0');
    }
    /**
     * Whether the given subnet has a route to a Transit Gateway
     */
    hasRouteToTransitGateway(subnetId) {
        const table = this.tableForSubnet(subnetId) || this.mainRouteTable;
        return !!table && !!table.Routes && table.Routes.some(route => !!route.TransitGatewayId && route.DestinationCidrBlock === '0.0.0.0/0');
    }
    /**
     * Whether the given subnet has a route to an IGW
     */
    hasRouteToIgw(subnetId) {
        const table = this.tableForSubnet(subnetId) || this.mainRouteTable;
        return !!table && !!table.Routes && table.Routes.some(route => !!route.GatewayId && route.GatewayId.startsWith('igw-'));
    }
    tableForSubnet(subnetId) {
        return this.tables.find(table => !!table.Associations && table.Associations.some(assoc => assoc.SubnetId === subnetId));
    }
}
/**
 * Return the value of a tag from a set of tags
 */
function getTag(name, tags) {
    for (const tag of tags || []) {
        if (tag.Key === name) {
            return tag.Value;
        }
    }
    return undefined;
}
/**
 * Group subnets of the same type together, and order by AZ
 */
function groupSubnets(subnets) {
    const grouping = {};
    for (const subnet of subnets) {
        const key = [subnet.type, subnet.name].toString();
        if (!(key in grouping)) {
            grouping[key] = [];
        }
        grouping[key].push(subnet);
    }
    const groups = Object.values(grouping).map(sns => {
        sns.sort((a, b) => a.az.localeCompare(b.az));
        return {
            type: sns[0].type,
            name: sns[0].name,
            subnets: sns,
        };
    });
    const azs = groups[0].subnets.map(s => s.az);
    for (const group of groups) {
        const groupAZs = group.subnets.map(s => s.az);
        if (!arraysEqual(groupAZs, azs)) {
            throw new Error(`Not all subnets in VPC have the same AZs: ${groupAZs} vs ${azs}`);
        }
    }
    return { azs, groups };
}
function groupAsymmetricSubnets(subnets) {
    const grouping = {};
    for (const subnet of subnets) {
        const key = [subnet.type, subnet.name].toString();
        if (!(key in grouping)) {
            grouping[key] = [];
        }
        grouping[key].push(subnet);
    }
    return Object.values(grouping).map(subnetArray => {
        subnetArray.sort((subnet1, subnet2) => subnet1.az.localeCompare(subnet2.az));
        return {
            name: subnetArray[0].name,
            type: subnetTypeToVpcSubnetType(subnetArray[0].type),
            subnets: subnetArray.map(subnet => ({
                subnetId: subnet.subnetId,
                cidr: subnet.cidr,
                availabilityZone: subnet.az,
                routeTableId: subnet.routeTableId,
            })),
        };
    });
}
function subnetTypeToVpcSubnetType(type) {
    switch (type) {
        case SubnetType.Isolated: return cxapi.VpcSubnetGroupType.ISOLATED;
        case SubnetType.Private: return cxapi.VpcSubnetGroupType.PRIVATE;
        case SubnetType.Public: return cxapi.VpcSubnetGroupType.PUBLIC;
    }
}
var SubnetType;
(function (SubnetType) {
    SubnetType["Public"] = "Public";
    SubnetType["Private"] = "Private";
    SubnetType["Isolated"] = "Isolated";
})(SubnetType || (SubnetType = {}));
function isValidSubnetType(val) {
    return val === SubnetType.Public
        || val === SubnetType.Private
        || val === SubnetType.Isolated;
}
function arraysEqual(as, bs) {
    if (as.length !== bs.length) {
        return false;
    }
    for (let i = 0; i < as.length; i++) {
        if (as[i] !== bs[i]) {
            return false;
        }
    }
    return true;
}
function findGroups(type, groups) {
    return groups.groups.filter(g => g.type === type);
}
function flatMap(xs, fn) {
    const ret = new Array();
    for (const x of xs) {
        ret.push(...fn(x));
    }
    return ret;
}
function collapse(xs) {
    if (xs.length > 0) {
        return xs;
    }
    return undefined;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidnBjcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbInZwY3MudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQ0EseUNBQXlDO0FBRXpDLCtEQUFtRjtBQUVuRix3Q0FBbUM7QUFFbkMsTUFBYSwrQkFBK0I7SUFFMUMsWUFBNkIsR0FBZ0I7UUFBaEIsUUFBRyxHQUFILEdBQUcsQ0FBYTtJQUM3QyxDQUFDO0lBRU0sS0FBSyxDQUFDLFFBQVEsQ0FBQyxJQUE4QjtRQUNsRCxNQUFNLEdBQUcsR0FBRyxDQUFDLE1BQU0sSUFBQSxxQ0FBc0IsRUFBQyxJQUFJLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7UUFFakUsTUFBTSxLQUFLLEdBQUcsTUFBTSxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxJQUFJLENBQUMsQ0FBQztRQUU1QyxPQUFPLElBQUksQ0FBQyxZQUFZLENBQUMsR0FBRyxFQUFFLEtBQUssRUFBRSxJQUFJLENBQUMsQ0FBQztJQUM3QyxDQUFDO0lBRU8sS0FBSyxDQUFDLE9BQU8sQ0FBQyxHQUFZLEVBQUUsSUFBOEI7UUFDaEUsNkVBQTZFO1FBQzdFLE1BQU0sT0FBTyxHQUFxQixNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxFQUFFLElBQUksRUFBRSxHQUFHLEVBQUUsTUFBTSxFQUFFLENBQUMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFFdEgsSUFBQSxlQUFLLEVBQUMsbUJBQW1CLElBQUksQ0FBQyxPQUFPLElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUM7UUFDeEQsTUFBTSxRQUFRLEdBQUcsTUFBTSxHQUFHLENBQUMsWUFBWSxDQUFDLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUMsT0FB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c3NlbWJseS1zY2hlbWEnO1xuaW1wb3J0ICogYXMgY3hhcGkgZnJvbSAnQGF3cy1jZGsvY3gtYXBpJztcbmltcG9ydCAqIGFzIEFXUyBmcm9tICdhd3Mtc2RrJztcbmltcG9ydCB7IFNka1Byb3ZpZGVyLCBpbml0Q29udGV4dFByb3ZpZGVyU2RrIH0gZnJvbSAnLi4vYXBpL2F3cy1hdXRoL3Nkay1wcm92aWRlcic7XG5pbXBvcnQgeyBDb250ZXh0UHJvdmlkZXJQbHVnaW4gfSBmcm9tICcuLi9hcGkvcGx1Z2luJztcbmltcG9ydCB7IGRlYnVnIH0gZnJvbSAnLi4vbG9nZ2luZyc7XG5cbmV4cG9ydCBjbGFzcyBWcGNOZXR3b3JrQ29udGV4dFByb3ZpZGVyUGx1Z2luIGltcGxlbWVudHMgQ29udGV4dFByb3ZpZGVyUGx1Z2luIHtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IGF3czogU2RrUHJvdmlkZXIpIHtcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBnZXRWYWx1ZShhcmdzOiBjeHNjaGVtYS5WcGNDb250ZXh0UXVlcnkpIHtcbiAgICBjb25zdCBlYzIgPSAoYXdhaXQgaW5pdENvbnRleHRQcm92aWRlclNkayh0aGlzLmF3cywgYXJncykpLmVjMigpO1xuXG4gICAgY29uc3QgdnBjSWQgPSBhd2FpdCB0aGlzLmZpbmRWcGMoZWMyLCBhcmdzKTtcblxuICAgIHJldHVybiB0aGlzLnJlYWRWcGNQcm9wcyhlYzIsIHZwY0lkLCBhcmdzKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgZmluZFZwYyhlYzI6IEFXUy5FQzIsIGFyZ3M6IGN4c2NoZW1hLlZwY0NvbnRleHRRdWVyeSk6IFByb21pc2U8QVdTLkVDMi5WcGM+IHtcbiAgICAvLyBCdWlsZCByZXF1ZXN0IGZpbHRlciAobWFwIHsgTmFtZSAtPiBWYWx1ZSB9IHRvIGxpc3Qgb2YgW3sgTmFtZSwgVmFsdWVzIH1dKVxuICAgIGNvbnN0IGZpbHRlcnM6IEFXUy5FQzIuRmlsdGVyW10gPSBPYmplY3QuZW50cmllcyhhcmdzLmZpbHRlcikubWFwKChbdGFnLCB2YWx1ZV0pID0+ICh7IE5hbWU6IHRhZywgVmFsdWVzOiBbdmFsdWVdIH0pKTtcblxuICAgIGRlYnVnKGBMaXN0aW5nIFZQQ3MgaW4gJHthcmdzLmFjY291bnR9OiR7YXJncy5yZWdpb259YCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBlYzIuZGVzY3JpYmVWcGNzKHsgRmlsdGVyczogZmlsdGVycyB9KS5wcm9taXNlKCk7XG5cbiAgICBjb25zdCB2cGNzID0gcmVzcG9uc2UuVnBjcyB8fCBbXTtcbiAgICBpZiAodnBjcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ291bGQgbm90IGZpbmQgYW55IFZQQ3MgbWF0Y2hpbmcgJHtKU09OLnN0cmluZ2lmeShhcmdzKX1gKTtcbiAgICB9XG4gICAgaWYgKHZwY3MubGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGb3VuZCAke3ZwY3MubGVuZ3RofSBWUENzIG1hdGNoaW5nICR7SlNPTi5zdHJpbmdpZnkoYXJncyl9OyBwbGVhc2UgbmFycm93IHRoZSBzZWFyY2ggY3JpdGVyaWFgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdnBjc1swXTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgcmVhZFZwY1Byb3BzKGVjMjogQVdTLkVDMiwgdnBjOiBBV1MuRUMyLlZwYywgYXJnczogY3hzY2hlbWEuVnBjQ29udGV4dFF1ZXJ5KTogUHJvbWlzZTxjeGFwaS5WcGNDb250ZXh0UmVzcG9uc2U+IHtcbiAgICBjb25zdCB2cGNJZCA9IHZwYy5WcGNJZCE7XG5cbiAgICBkZWJ1ZyhgRGVzY3JpYmluZyBWUEMgJHt2cGNJZH1gKTtcblxuICAgIGNvbnN0IGZpbHRlcnMgPSB7IEZpbHRlcnM6IFt7IE5hbWU6ICd2cGMtaWQnLCBWYWx1ZXM6IFt2cGNJZF0gfV0gfTtcblxuICAgIGNvbnN0IHN1Ym5ldHNSZXNwb25zZSA9IGF3YWl0IGVjMi5kZXNjcmliZVN1Ym5ldHMoZmlsdGVycykucHJvbWlzZSgpO1xuICAgIGNvbnN0IGxpc3RlZFN1Ym5ldHMgPSBzdWJuZXRzUmVzcG9uc2UuU3VibmV0cyB8fCBbXTtcblxuICAgIGNvbnN0IHJvdXRlVGFibGVzUmVzcG9uc2UgPSBhd2FpdCBlYzIuZGVzY3JpYmVSb3V0ZVRhYmxlcyhmaWx0ZXJzKS5wcm9taXNlKCk7XG4gICAgY29uc3Qgcm91dGVUYWJsZXMgPSBuZXcgUm91dGVUYWJsZXMocm91dGVUYWJsZXNSZXNwb25zZS5Sb3V0ZVRhYmxlcyB8fCBbXSk7XG5cbiAgICAvLyBOb3cgY29tZXMgb3VyIGpvYiB0byBzZXBhcmF0ZSB0aGVzZSBzdWJuZXRzIG91dCBpbnRvIEFacyBhbmQgc3VibmV0IGdyb3VwcyAoUHVibGljLCBQcml2YXRlLCBJc29sYXRlZClcbiAgICAvLyBXZSBoYXZlIHRoZSBmb2xsb3dpbmcgYXR0cmlidXRlcyB0byBnbyBvbjpcbiAgICAvLyAtIFR5cGUgdGFnLCB3ZSB0YWcgc3VibmV0cyB3aXRoIHRoZWlyIHR5cGUuIEluIGFic2VuY2Ugb2YgdGhpcyB0YWcsIHdlXG4gICAgLy8gICBkZXRlcm1pbmUgdGhlIHN1Ym5ldCBtdXN0IGJlIFB1YmxpYyBpZiBlaXRoZXI6XG4gICAgLy8gICBhKSBpdCBoYXMgdGhlIHByb3BlcnR5IE1hcFB1YmxpY0lwT25MYXVuY2hcbiAgICAvLyAgIGIpIGl0IGhhcyBhIHJvdXRlIHRvIGFuIEludGVybmV0IEdhdGV3YXlcbiAgICAvLyAgIElmIGJvdGggb2YgdGhlIGFib3ZlIGlzIGZhbHNlIGJ1dCB0aGUgc3VibmV0IGhhcyBhIHJvdXRlIHRvIGEgTkFUIEdhdGV3YXlcbiAgICAvLyAgIGFuZCB0aGUgZGVzdGluYXRpb24gQ0lEUiBibG9jayBpcyBcIjAuMC4wLjAvMFwiLCB3ZSBhc3N1bWUgaXQgdG8gYmUgYSBQcml2YXRlIHN1Ym5ldC5cbiAgICAvLyAgIEFueXRoaW5nIGVsc2UgaXMgY29uc2lkZXJlZCBJc29sYXRlZC5cbiAgICAvLyAtIE5hbWUgdGFnLCB3ZSB0YWcgc3VibmV0cyB3aXRoIHRoZWlyIHN1Ym5ldCBncm91cCBuYW1lLiBJbiBhYnNlbmNlIG9mIHRoaXMgdGFnLFxuICAgIC8vICAgd2UgdXNlIHRoZSB0eXBlIGFzIHRoZSBuYW1lLlxuXG4gICAgY29uc3QgYXpzID0gQXJyYXkuZnJvbShuZXcgU2V0PHN0cmluZz4obGlzdGVkU3VibmV0cy5tYXAocyA9PiBzLkF2YWlsYWJpbGl0eVpvbmUhKSkpO1xuICAgIGF6cy5zb3J0KCk7XG5cbiAgICBjb25zdCBzdWJuZXRzOiBTdWJuZXRbXSA9IGxpc3RlZFN1Ym5ldHMubWFwKHN1Ym5ldCA9PiB7XG4gICAgICBsZXQgdHlwZSA9IGdldFRhZygnYXdzLWNkazpzdWJuZXQtdHlwZScsIHN1Ym5ldC5UYWdzKTtcbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgJiYgc3VibmV0Lk1hcFB1YmxpY0lwT25MYXVuY2gpIHsgdHlwZSA9IFN1Ym5ldFR5cGUuUHVibGljOyB9XG4gICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkICYmIHJvdXRlVGFibGVzLmhhc1JvdXRlVG9JZ3coc3VibmV0LlN1Ym5ldElkKSkgeyB0eXBlID0gU3VibmV0VHlwZS5QdWJsaWM7IH1cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgJiYgcm91dGVUYWJsZXMuaGFzUm91dGVUb05hdEdhdGV3YXkoc3VibmV0LlN1Ym5ldElkKSkgeyB0eXBlID0gU3VibmV0VHlwZS5Qcml2YXRlOyB9XG4gICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkICYmIHJvdXRlVGFibGVzLmhhc1JvdXRlVG9UcmFuc2l0R2F0ZXdheShzdWJuZXQuU3VibmV0SWQpKSB7IHR5cGUgPSBTdWJuZXRUeXBlLlByaXZhdGU7IH1cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQpIHsgdHlwZSA9IFN1Ym5ldFR5cGUuSXNvbGF0ZWQ7IH1cblxuICAgICAgaWYgKCFpc1ZhbGlkU3VibmV0VHlwZSh0eXBlKSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFN1Ym5ldCAke3N1Ym5ldC5TdWJuZXRBcm59IGhhcyBpbnZhbGlkIHN1Ym5ldCB0eXBlICR7dHlwZX0gKG11c3QgYmUgJHtTdWJuZXRUeXBlLlB1YmxpY30sICR7U3VibmV0VHlwZS5Qcml2YXRlfSBvciAke1N1Ym5ldFR5cGUuSXNvbGF0ZWR9KWApO1xuICAgICAgfVxuXG4gICAgICBpZiAoYXJncy5zdWJuZXRHcm91cE5hbWVUYWcgJiYgIWdldFRhZyhhcmdzLnN1Ym5ldEdyb3VwTmFtZVRhZywgc3VibmV0LlRhZ3MpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBzdWJuZXRHcm91cE5hbWVUYWc6IFN1Ym5ldCAke3N1Ym5ldC5TdWJuZXRBcm59IGRvZXMgbm90IGhhdmUgYW4gYXNzb2NpYXRlZCB0YWcgd2l0aCBLZXk9JyR7YXJncy5zdWJuZXRHcm91cE5hbWVUYWd9J2ApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBuYW1lID0gZ2V0VGFnKGFyZ3Muc3VibmV0R3JvdXBOYW1lVGFnIHx8ICdhd3MtY2RrOnN1Ym5ldC1uYW1lJywgc3VibmV0LlRhZ3MpIHx8IHR5cGU7XG4gICAgICBjb25zdCByb3V0ZVRhYmxlSWQgPSByb3V0ZVRhYmxlcy5yb3V0ZVRhYmxlSWRGb3JTdWJuZXRJZChzdWJuZXQuU3VibmV0SWQpO1xuXG4gICAgICBpZiAoIXJvdXRlVGFibGVJZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFN1Ym5ldCAke3N1Ym5ldC5TdWJuZXRBcm59IGRvZXMgbm90IGhhdmUgYW4gYXNzb2NpYXRlZCByb3V0ZSB0YWJsZSAoYW5kIHRoZXJlIGlzIG5vIFwibWFpblwiIHRhYmxlKWApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBhejogc3VibmV0LkF2YWlsYWJpbGl0eVpvbmUhLFxuICAgICAgICBjaWRyOiBzdWJuZXQuQ2lkckJsb2NrISxcbiAgICAgICAgdHlwZSxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgc3VibmV0SWQ6IHN1Ym5ldC5TdWJuZXRJZCEsXG4gICAgICAgIHJvdXRlVGFibGVJZCxcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICBsZXQgZ3JvdXBlZDogU3VibmV0R3JvdXBzO1xuICAgIGxldCBhc3N5bWV0cmljU3VibmV0R3JvdXBzOiBjeGFwaS5WcGNTdWJuZXRHcm91cFtdIHwgdW5kZWZpbmVkO1xuICAgIGlmIChhcmdzLnJldHVybkFzeW1tZXRyaWNTdWJuZXRzKSB7XG4gICAgICBncm91cGVkID0geyBhenM6IFtdLCBncm91cHM6IFtdIH07XG4gICAgICBhc3N5bWV0cmljU3VibmV0R3JvdXBzID0gZ3JvdXBBc3ltbWV0cmljU3VibmV0cyhzdWJuZXRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ3JvdXBlZCA9IGdyb3VwU3VibmV0cyhzdWJuZXRzKTtcbiAgICAgIGFzc3ltZXRyaWNTdWJuZXRHcm91cHMgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gRmluZCBhdHRhY2hlZCthdmFpbGFibGUgVlBOIGdhdGV3YXkgZm9yIHRoaXMgVlBDXG4gICAgY29uc3QgdnBuR2F0ZXdheVJlc3BvbnNlID0gKGFyZ3MucmV0dXJuVnBuR2F0ZXdheXMgPz8gdHJ1ZSlcbiAgICAgID8gYXdhaXQgZWMyLmRlc2NyaWJlVnBuR2F0ZXdheXMoe1xuICAgICAgICBGaWx0ZXJzOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgTmFtZTogJ2F0dGFjaG1lbnQudnBjLWlkJyxcbiAgICAgICAgICAgIFZhbHVlczogW3ZwY0lkXSxcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIE5hbWU6ICdhdHRhY2htZW50LnN0YXRlJyxcbiAgICAgICAgICAgIFZhbHVlczogWydhdHRhY2hlZCddLFxuICAgICAgICAgIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgTmFtZTogJ3N0YXRlJyxcbiAgICAgICAgICAgIFZhbHVlczogWydhdmFpbGFibGUnXSxcbiAgICAgICAgICB9LFxuICAgICAgICBdLFxuICAgICAgfSkucHJvbWlzZSgpXG4gICAgICA6IHVuZGVmaW5lZDtcbiAgICBjb25zdCB2cG5HYXRld2F5SWQgPSB2cG5HYXRld2F5UmVzcG9uc2U/LlZwbkdhdGV3YXlzPy5sZW5ndGggPT09IDFcbiAgICAgID8gdnBuR2F0ZXdheVJlc3BvbnNlLlZwbkdhdGV3YXlzWzBdLlZwbkdhdGV3YXlJZFxuICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdnBjSWQsXG4gICAgICB2cGNDaWRyQmxvY2s6IHZwYy5DaWRyQmxvY2shLFxuICAgICAgb3duZXJBY2NvdW50SWQ6IHZwYy5Pd25lcklkLFxuICAgICAgYXZhaWxhYmlsaXR5Wm9uZXM6IGdyb3VwZWQuYXpzLFxuICAgICAgaXNvbGF0ZWRTdWJuZXRJZHM6IGNvbGxhcHNlKGZsYXRNYXAoZmluZEdyb3VwcyhTdWJuZXRUeXBlLklzb2xhdGVkLCBncm91cGVkKSwgZ3JvdXAgPT4gZ3JvdXAuc3VibmV0cy5tYXAocyA9PiBzLnN1Ym5ldElkKSkpLFxuICAgICAgaXNvbGF0ZWRTdWJuZXROYW1lczogY29sbGFwc2UoZmxhdE1hcChmaW5kR3JvdXBzKFN1Ym5ldFR5cGUuSXNvbGF0ZWQsIGdyb3VwZWQpLCBncm91cCA9PiBncm91cC5uYW1lID8gW2dyb3VwLm5hbWVdIDogW10pKSxcbiAgICAgIGlzb2xhdGVkU3VibmV0Um91dGVUYWJsZUlkczogY29sbGFwc2UoZmxhdE1hcChmaW5kR3JvdXBzKFN1Ym5ldFR5cGUuSXNvbGF0ZWQsIGdyb3VwZWQpLCBncm91cCA9PiBncm91cC5zdWJuZXRzLm1hcChzID0+IHMucm91dGVUYWJsZUlkKSkpLFxuICAgICAgcHJpdmF0ZVN1Ym5ldElkczogY29sbGFwc2UoZmxhdE1hcChmaW5kR3JvdXBzKFN1Ym5ldFR5cGUuUHJpdmF0ZSwgZ3JvdXBlZCksIGdyb3VwID0+IGdyb3VwLnN1Ym5ldHMubWFwKHMgPT4gcy5zdWJuZXRJZCkpKSxcbiAgICAgIHByaXZhdGVTdWJuZXROYW1lczogY29sbGFwc2UoZmxhdE1hcChmaW5kR3JvdXBzKFN1Ym5ldFR5cGUuUHJpdmF0ZSwgZ3JvdXBlZCksIGdyb3VwID0+IGdyb3VwLm5hbWUgPyBbZ3JvdXAubmFtZV0gOiBbXSkpLFxuICAgICAgcHJpdmF0ZVN1Ym5ldFJvdXRlVGFibGVJZHM6IGNvbGxhcHNlKGZsYXRNYXAoZmluZEdyb3VwcyhTdWJuZXRUeXBlLlByaXZhdGUsIGdyb3VwZWQpLCBncm91cCA9PiBncm91cC5zdWJuZXRzLm1hcChzID0+IHMucm91dGVUYWJsZUlkKSkpLFxuICAgICAgcHVibGljU3VibmV0SWRzOiBjb2xsYXBzZShmbGF0TWFwKGZpbmRHcm91cHMoU3VibmV0VHlwZS5QdWJsaWMsIGdyb3VwZWQpLCBncm91cCA9PiBncm91cC5zdWJuZXRzLm1hcChzID0+IHMuc3VibmV0SWQpKSksXG4gICAgICBwdWJsaWNTdWJuZXROYW1lczogY29sbGFwc2UoZmxhdE1hcChmaW5kR3JvdXBzKFN1Ym5ldFR5cGUuUHVibGljLCBncm91cGVkKSwgZ3JvdXAgPT4gZ3JvdXAubmFtZSA/IFtncm91cC5uYW1lXSA6IFtdKSksXG4gICAgICBwdWJsaWNTdWJuZXRSb3V0ZVRhYmxlSWRzOiBjb2xsYXBzZShmbGF0TWFwKGZpbmRHcm91cHMoU3VibmV0VHlwZS5QdWJsaWMsIGdyb3VwZWQpLCBncm91cCA9PiBncm91cC5zdWJuZXRzLm1hcChzID0+IHMucm91dGVUYWJsZUlkKSkpLFxuICAgICAgdnBuR2F0ZXdheUlkLFxuICAgICAgc3VibmV0R3JvdXBzOiBhc3N5bWV0cmljU3VibmV0R3JvdXBzLFxuICAgIH07XG4gIH1cbn1cblxuY2xhc3MgUm91dGVUYWJsZXMge1xuICBwdWJsaWMgcmVhZG9ubHkgbWFpblJvdXRlVGFibGU/OiBBV1MuRUMyLlJvdXRlVGFibGU7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSByZWFkb25seSB0YWJsZXM6IEFXUy5FQzIuUm91dGVUYWJsZVtdKSB7XG4gICAgdGhpcy5tYWluUm91dGVUYWJsZSA9IHRoaXMudGFibGVzLmZpbmQodGFibGUgPT4gISF0YWJsZS5Bc3NvY2lhdGlvbnMgJiYgdGFibGUuQXNzb2NpYXRpb25zLnNvbWUoYXNzb2MgPT4gISFhc3NvYy5NYWluKSk7XG4gIH1cblxuICBwdWJsaWMgcm91dGVUYWJsZUlkRm9yU3VibmV0SWQoc3VibmV0SWQ6IHN0cmluZyB8IHVuZGVmaW5lZCk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gICAgY29uc3QgdGFibGUgPSB0aGlzLnRhYmxlRm9yU3VibmV0KHN1Ym5ldElkKTtcbiAgICByZXR1cm4gKHRhYmxlICYmIHRhYmxlLlJvdXRlVGFibGVJZCkgfHwgKHRoaXMubWFpblJvdXRlVGFibGUgJiYgdGhpcy5tYWluUm91dGVUYWJsZS5Sb3V0ZVRhYmxlSWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIGdpdmVuIHN1Ym5ldCBoYXMgYSByb3V0ZSB0byBhIE5BVCBHYXRld2F5XG4gICAqL1xuICBwdWJsaWMgaGFzUm91dGVUb05hdEdhdGV3YXkoc3VibmV0SWQ6IHN0cmluZyB8IHVuZGVmaW5lZCk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IHRhYmxlID0gdGhpcy50YWJsZUZvclN1Ym5ldChzdWJuZXRJZCkgfHwgdGhpcy5tYWluUm91dGVUYWJsZTtcblxuICAgIHJldHVybiAhIXRhYmxlICYmICEhdGFibGUuUm91dGVzICYmIHRhYmxlLlJvdXRlcy5zb21lKHJvdXRlID0+ICEhcm91dGUuTmF0R2F0ZXdheUlkICYmIHJvdXRlLkRlc3RpbmF0aW9uQ2lkckJsb2NrID09PSAnMC4wLjAuMC8wJyk7XG4gIH1cblxuICAvKipcbiAgICogV2hldGhlciB0aGUgZ2l2ZW4gc3VibmV0IGhhcyBhIHJvdXRlIHRvIGEgVHJhbnNpdCBHYXRld2F5XG4gICAqL1xuICBwdWJsaWMgaGFzUm91dGVUb1RyYW5zaXRHYXRld2F5KHN1Ym5ldElkOiBzdHJpbmcgfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgICBjb25zdCB0YWJsZSA9IHRoaXMudGFibGVGb3JTdWJuZXQoc3VibmV0SWQpIHx8IHRoaXMubWFpblJvdXRlVGFibGU7XG5cbiAgICByZXR1cm4gISF0YWJsZSAmJiAhIXRhYmxlLlJvdXRlcyAmJiB0YWJsZS5Sb3V0ZXMuc29tZShyb3V0ZSA9PiAhIXJvdXRlLlRyYW5zaXRHYXRld2F5SWQgJiYgcm91dGUuRGVzdGluYXRpb25DaWRyQmxvY2sgPT09ICcwLjAuMC4wLzAnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBnaXZlbiBzdWJuZXQgaGFzIGEgcm91dGUgdG8gYW4gSUdXXG4gICAqL1xuICBwdWJsaWMgaGFzUm91dGVUb0lndyhzdWJuZXRJZDogc3RyaW5nIHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gICAgY29uc3QgdGFibGUgPSB0aGlzLnRhYmxlRm9yU3VibmV0KHN1Ym5ldElkKSB8fCB0aGlzLm1haW5Sb3V0ZVRhYmxlO1xuXG4gICAgcmV0dXJuICEhdGFibGUgJiYgISF0YWJsZS5Sb3V0ZXMgJiYgdGFibGUuUm91dGVzLnNvbWUocm91dGUgPT4gISFyb3V0ZS5HYXRld2F5SWQgJiYgcm91dGUuR2F0ZXdheUlkLnN0YXJ0c1dpdGgoJ2lndy0nKSk7XG4gIH1cblxuICBwdWJsaWMgdGFibGVGb3JTdWJuZXQoc3VibmV0SWQ6IHN0cmluZyB8IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB0aGlzLnRhYmxlcy5maW5kKHRhYmxlID0+ICEhdGFibGUuQXNzb2NpYXRpb25zICYmIHRhYmxlLkFzc29jaWF0aW9ucy5zb21lKGFzc29jID0+IGFzc29jLlN1Ym5ldElkID09PSBzdWJuZXRJZCkpO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSB2YWx1ZSBvZiBhIHRhZyBmcm9tIGEgc2V0IG9mIHRhZ3NcbiAqL1xuZnVuY3Rpb24gZ2V0VGFnKG5hbWU6IHN0cmluZywgdGFncz86IEFXUy5FQzIuVGFnW10pOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICBmb3IgKGNvbnN0IHRhZyBvZiB0YWdzIHx8IFtdKSB7XG4gICAgaWYgKHRhZy5LZXkgPT09IG5hbWUpIHtcbiAgICAgIHJldHVybiB0YWcuVmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogR3JvdXAgc3VibmV0cyBvZiB0aGUgc2FtZSB0eXBlIHRvZ2V0aGVyLCBhbmQgb3JkZXIgYnkgQVpcbiAqL1xuZnVuY3Rpb24gZ3JvdXBTdWJuZXRzKHN1Ym5ldHM6IFN1Ym5ldFtdKTogU3VibmV0R3JvdXBzIHtcbiAgY29uc3QgZ3JvdXBpbmc6IHtba2V5OiBzdHJpbmddOiBTdWJuZXRbXX0gPSB7fTtcbiAgZm9yIChjb25zdCBzdWJuZXQgb2Ygc3VibmV0cykge1xuICAgIGNvbnN0IGtleSA9IFtzdWJuZXQudHlwZSwgc3VibmV0Lm5hbWVdLnRvU3RyaW5nKCk7XG4gICAgaWYgKCEoa2V5IGluIGdyb3VwaW5nKSkgeyBncm91cGluZ1trZXldID0gW107IH1cbiAgICBncm91cGluZ1trZXldLnB1c2goc3VibmV0KTtcbiAgfVxuXG4gIGNvbnN0IGdyb3VwcyA9IE9iamVjdC52YWx1ZXMoZ3JvdXBpbmcpLm1hcChzbnMgPT4ge1xuICAgIHNucy5zb3J0KChhOiBTdWJuZXQsIGI6IFN1Ym5ldCkgPT4gYS5hei5sb2NhbGVDb21wYXJlKGIuYXopKTtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogc25zWzBdLnR5cGUsXG4gICAgICBuYW1lOiBzbnNbMF0ubmFtZSxcbiAgICAgIHN1Ym5ldHM6IHNucyxcbiAgICB9O1xuICB9KTtcblxuICBjb25zdCBhenMgPSBncm91cHNbMF0uc3VibmV0cy5tYXAocyA9PiBzLmF6KTtcblxuICBmb3IgKGNvbnN0IGdyb3VwIG9mIGdyb3Vwcykge1xuICAgIGNvbnN0IGdyb3VwQVpzID0gZ3JvdXAuc3VibmV0cy5tYXAocyA9PiBzLmF6KTtcbiAgICBpZiAoIWFycmF5c0VxdWFsKGdyb3VwQVpzLCBhenMpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vdCBhbGwgc3VibmV0cyBpbiBWUEMgaGF2ZSB0aGUgc2FtZSBBWnM6ICR7Z3JvdXBBWnN9IHZzICR7YXpzfWApO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7IGF6cywgZ3JvdXBzIH07XG59XG5cbmZ1bmN0aW9uIGdyb3VwQXN5bW1ldHJpY1N1Ym5ldHMoc3VibmV0czogU3VibmV0W10pOiBjeGFwaS5WcGNTdWJuZXRHcm91cFtdIHtcbiAgY29uc3QgZ3JvdXBpbmc6IHsgW2tleTogc3RyaW5nXTogU3VibmV0W10gfSA9IHt9O1xuICBmb3IgKGNvbnN0IHN1Ym5ldCBvZiBzdWJuZXRzKSB7XG4gICAgY29uc3Qga2V5ID0gW3N1Ym5ldC50eXBlLCBzdWJuZXQubmFtZV0udG9TdHJpbmcoKTtcbiAgICBpZiAoIShrZXkgaW4gZ3JvdXBpbmcpKSB7XG4gICAgICBncm91cGluZ1trZXldID0gW107XG4gICAgfVxuICAgIGdyb3VwaW5nW2tleV0ucHVzaChzdWJuZXQpO1xuICB9XG5cbiAgcmV0dXJuIE9iamVjdC52YWx1ZXMoZ3JvdXBpbmcpLm1hcChzdWJuZXRBcnJheSA9PiB7XG4gICAgc3VibmV0QXJyYXkuc29ydCgoc3VibmV0MTogU3VibmV0LCBzdWJuZXQyOiBTdWJuZXQpID0+IHN1Ym5ldDEuYXoubG9jYWxlQ29tcGFyZShzdWJuZXQyLmF6KSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogc3VibmV0QXJyYXlbMF0ubmFtZSxcbiAgICAgIHR5cGU6IHN1Ym5ldFR5cGVUb1ZwY1N1Ym5ldFR5cGUoc3VibmV0QXJyYXlbMF0udHlwZSksXG4gICAgICBzdWJuZXRzOiBzdWJuZXRBcnJheS5tYXAoc3VibmV0ID0+ICh7XG4gICAgICAgIHN1Ym5ldElkOiBzdWJuZXQuc3VibmV0SWQsXG4gICAgICAgIGNpZHI6IHN1Ym5ldC5jaWRyLFxuICAgICAgICBhdmFpbGFiaWxpdHlab25lOiBzdWJuZXQuYXosXG4gICAgICAgIHJvdXRlVGFibGVJZDogc3VibmV0LnJvdXRlVGFibGVJZCxcbiAgICAgIH0pKSxcbiAgICB9O1xuICB9KTtcbn1cblxuZnVuY3Rpb24gc3VibmV0VHlwZVRvVnBjU3VibmV0VHlwZSh0eXBlOiBTdWJuZXRUeXBlKTogY3hhcGkuVnBjU3VibmV0R3JvdXBUeXBlIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBTdWJuZXRUeXBlLklzb2xhdGVkOiByZXR1cm4gY3hhcGkuVnBjU3VibmV0R3JvdXBUeXBlLklTT0xBVEVEO1xuICAgIGNhc2UgU3VibmV0VHlwZS5Qcml2YXRlOiByZXR1cm4gY3hhcGkuVnBjU3VibmV0R3JvdXBUeXBlLlBSSVZBVEU7XG4gICAgY2FzZSBTdWJuZXRUeXBlLlB1YmxpYzogcmV0dXJuIGN4YXBpLlZwY1N1Ym5ldEdyb3VwVHlwZS5QVUJMSUM7XG4gIH1cbn1cblxuZW51bSBTdWJuZXRUeXBlIHtcbiAgUHVibGljID0gJ1B1YmxpYycsXG4gIFByaXZhdGUgPSAnUHJpdmF0ZScsXG4gIElzb2xhdGVkID0gJ0lzb2xhdGVkJyxcbn1cblxuZnVuY3Rpb24gaXNWYWxpZFN1Ym5ldFR5cGUodmFsOiBzdHJpbmcpOiB2YWwgaXMgU3VibmV0VHlwZSB7XG4gIHJldHVybiB2YWwgPT09IFN1Ym5ldFR5cGUuUHVibGljXG4gICAgfHwgdmFsID09PSBTdWJuZXRUeXBlLlByaXZhdGVcbiAgICB8fCB2YWwgPT09IFN1Ym5ldFR5cGUuSXNvbGF0ZWQ7XG59XG5cbmludGVyZmFjZSBTdWJuZXQge1xuICBhejogc3RyaW5nO1xuICBjaWRyOiBzdHJpbmc7XG4gIHR5cGU6IFN1Ym5ldFR5cGU7XG4gIG5hbWU6IHN0cmluZztcbiAgcm91dGVUYWJsZUlkOiBzdHJpbmc7XG4gIHN1Ym5ldElkOiBzdHJpbmc7XG59XG5cbmludGVyZmFjZSBTdWJuZXRHcm91cCB7XG4gIHR5cGU6IFN1Ym5ldFR5cGU7XG4gIG5hbWU6IHN0cmluZztcbiAgc3VibmV0czogU3VibmV0W107XG59XG5cbmludGVyZmFjZSBTdWJuZXRHcm91cHMge1xuICBhenM6IHN0cmluZ1tdO1xuICBncm91cHM6IFN1Ym5ldEdyb3VwW107XG59XG5cbmZ1bmN0aW9uIGFycmF5c0VxdWFsKGFzOiBzdHJpbmdbXSwgYnM6IHN0cmluZ1tdKTogYm9vbGVhbiB7XG4gIGlmIChhcy5sZW5ndGggIT09IGJzLmxlbmd0aCkgeyByZXR1cm4gZmFsc2U7IH1cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGFzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFzW2ldICE9PSBic1tpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBmaW5kR3JvdXBzKHR5cGU6IFN1Ym5ldFR5cGUsIGdyb3VwczogU3VibmV0R3JvdXBzKTogU3VibmV0R3JvdXBbXSB7XG4gIHJldHVybiBncm91cHMuZ3JvdXBzLmZpbHRlcihnID0+IGcudHlwZSA9PT0gdHlwZSk7XG59XG5cbmZ1bmN0aW9uIGZsYXRNYXA8VCwgVT4oeHM6IFRbXSwgZm46ICh4OiBUKSA9PiBVW10pOiBVW10ge1xuICBjb25zdCByZXQgPSBuZXcgQXJyYXk8VT4oKTtcbiAgZm9yIChjb25zdCB4IG9mIHhzKSB7XG4gICAgcmV0LnB1c2goLi4uZm4oeCkpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGNvbGxhcHNlPFQ+KHhzOiBUW10pOiBUW10gfCB1bmRlZmluZWQge1xuICBpZiAoeHMubGVuZ3RoID4gMCkgeyByZXR1cm4geHM7IH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcblxufVxuIl19